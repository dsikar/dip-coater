MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ; ###############################################################################
                      00002 ; Name of this file:           USB18.ASM
                      00003 ;
                      00004 ; USB library routines for use by HIDMaker FS with Microchip C18
                      00005 ;
                      00006 ; Based on a USB source file for PicBasic Pro [Copyright (c) 2005 by microEngineering Labs, Inc.],
                      00007 ; developed jointly by microEngineering Labs, Inc. and Trace Systems, Inc..
                      00008 ; Enhancements for use with HIDmaker FS are Copyright (c) 2005 by Trace Systems, Inc.
                      00009 ;
                      00010 ; All rights reserved by Trace Systems Inc. and microEngineering Labs, Inc..
                      00011 ;
                      00012 ; This version works with Microchip C18
                      00013 ;
                      00014 ; ###############################################################################
                      00015 
                      00016 
                      00017 ; Enable ONE SET of the following pairs of lines, to select processor:
                      00018   list p=18f4550
                      00019   #include p18f4550.inc
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC18F4550 processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2007 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
                      01643         LIST
                      00020 ;  list p=18f2550
                      00021 ;  #include p18f2550.inc
                      00022 ;  list p=18f4555
                      00023 ;  #include p18f4555.inc
                      00024 ;  list p=18f4455
                      00025 ;  #include p18f4455.inc
                      00026 ;  list p=18f4450
                      00027 ;  #include p18f4450.inc
                      00028 ;  list p=18f2450
                      00029 ;  #include p18f2450.inc
                      00030   
                      00031   #include usb18.inc
                      00001 ; Compiler directives:
                      00002 
                      00003   radix dec
                      00004   
                      00005 ; MUID = Microchip USB Class ID
                      00006 ; Used to identify which of the USB classes owns the current
                      00007 ; session of control transfer over EP0
                      00008 #define MUID_NULL               0
                      00009 #define MUID_USB9               1
                      00010 #define MUID_HID                2
                      00011 #define MUID_CDC                3
                      00012 #define MUID_MSD                4
                      00013 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00014 ; Buffer Descriptor Status Register Initialization Parameters
                      00015 #define _BSTALL                 0x04    ; Buffer Stall enable
                      00016 #define _DTSEN                  0x08    ; Data Toggle Synch enable
                      00017 #define _INCDIS                 0x10    ; Address increment disable
                      00018 #define _KEN                    0x20    ; SIE keeps buff descriptors enable
                      00019 #define _DAT0                   0x00    ; DATA0 packet expected next
                      00020 #define _DAT1                   0x40    ; DATA1 packet expected next
                      00021 #define _DTSMASK                0x40    ; DTS Mask
                      00022 #define _USIE                   0x80    ; SIE owns buffer
                      00023 #define _UCPU                   0x00    ; CPU owns buffer
                      00024 
                      00025 ; USB Device States - To be used with [byte usb_device_state]
                      00026 #define DETACHED_STATE          0
                      00027 #define ATTACHED_STATE          1
                      00028 #define POWERED_STATE           2
                      00029 #define DEFAULT_STATE           3
                      00030 #define ADR_PENDING_STATE       4
                      00031 #define ADDRESS_STATE           5
                      00032 #define CONFIGURED_STATE        6
                      00033 
                      00034 ; Memory Types for Control Transfer - used in USB_DEVICE_STATUS
                      00035 ;#define        _RAM                    0
                      00036 ;#define        _ROM                    1
                      00037 
                      00038 
                      00039 ; From usbdefs_std_dsc.h
                      00040 ; Descriptor Types
                      00041 #define DSC_DEV     0x01
                      00042 #define DSC_CFG     0x02
                      00043 #define DSC_STR     0x03
                      00044 #define DSC_INTF    0x04
                      00045 #define DSC_EP      0x05
                      00046 
                      00047 ; USB Endpoint Definitions
                      00048 #define _EP01_OUT   0x01
                      00049 #define _EP01_IN    0x81
                      00050 #define _EP02_OUT   0x02
                      00051 #define _EP02_IN    0x82
                      00052 #define _EP03_OUT   0x03
                      00053 #define _EP03_IN    0x83
                      00054 #define _EP04_OUT   0x04
                      00055 #define _EP04_IN    0x84
                      00056 #define _EP05_OUT   0x05
                      00057 #define _EP05_IN    0x85
                      00058 #define _EP06_OUT   0x06
                      00059 #define _EP06_IN    0x86
                      00060 #define _EP07_OUT   0x07
                      00061 #define _EP07_IN    0x87
                      00062 #define _EP08_OUT   0x08
                      00063 #define _EP08_IN    0x88
                      00064 #define _EP09_OUT   0x09
                      00065 #define _EP09_IN    0x89
                      00066 #define _EP10_OUT   0x0A
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00067 #define _EP10_IN    0x8A
                      00068 #define _EP11_OUT   0x0B
                      00069 #define _EP11_IN    0x8B
                      00070 #define _EP12_OUT   0x0C
                      00071 #define _EP12_IN    0x8C
                      00072 #define _EP13_OUT   0x0D
                      00073 #define _EP13_IN    0x8D
                      00074 #define _EP14_OUT   0x0E
                      00075 #define _EP14_IN    0x8E
                      00076 #define _EP15_OUT   0x0F
                      00077 #define _EP15_IN    0x8F
                      00078 
                      00079 ; Configuration Attributes
                      00080 ;#define        _DEFAULT        0x01<<7         ; Default Value (Bit 7 is set)
                      00081 ;#define        _SELF           0x01<<6         ; Self-powered (Supports if set)
                      00082 ;#define        _RWU            0x01<<5         ; Remote Wakeup (Supports if set)
                      00083 
                      00084 ; Endpoint Transfer Type
                      00085 ;#define        _CTRL           0x00            ; Control Transfer
                      00086 ;#define        _ISO            0x01            ; Isochronous Transfer
                      00087 ;#define        _BULK           0x02            ; Bulk Transfer
                      00088 ;#define        _INT            0x03            ; Interrupt Transfer
                      00089 
                      00090 ; Isochronous Endpoint Synchronization Type
                      00091 ;#define        _NS             0x00<<2         ; No Synchronization
                      00092 ;#define        _AS             0x01<<2         ; Asynchronous
                      00093 ;#define        _AD             0x02<<2         ; Adaptive
                      00094 ;#define        _SY             0x03<<2         ; Synchronous
                      00095 
                      00096 ; Isochronous Endpoint Usage Type
                      00097 ;#define        _DE             0x00<<4         ; Data endpoint
                      00098 ;#define        _FE             0x01<<4         ; Feedback endpoint
                      00099 ;#define        _IE             0x02<<4         ; Implicit feedback Data endpoint
                      00100 
                      00101 
                      00102 ; From usb9.h
                      00103 ; Standard Request Codes
                      00104 ; USB 2.0 Spec Ref Table 9-4
                      00105 #define GET_STATUS              0
                      00106 #define CLR_FEATURE             1
                      00107 #define SET_FEATURE             3
                      00108 #define SET_ADR                 5
                      00109 #define GET_DSC                 6
                      00110 #define SET_DSC                 7
                      00111 #define GET_CFG                 8
                      00112 #define SET_CFG                 9
                      00113 #define GET_INTF                10
                      00114 #define SET_INTF                11
                      00115 #define SYNCH_FRAME             12
                      00116 
                      00117 ; Standard Feature Selectors
                      00118 #define DEVICE_REMOTE_WAKEUP    0x01
                      00119 #define ENDPOINT_HALT           0x00
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00120 
                      00121 
                      00122 ; From hid.h
                      00123 ; Class-Specific Requests
                      00124 #define GET_REPORT              0x01
                      00125 #define GET_IDLE                0x02
                      00126 #define GET_PROTOCOL            0x03
                      00127 #define SET_REPORT              0x09
                      00128 #define SET_IDLE                0x0A
                      00129 #define SET_PROTOCOL            0x0B
                      00130 
                      00131 ; Class Descriptor Types
                      00132 #define DSC_HID                 0x21
                      00133 #define DSC_RPT                 0x22
                      00134 #define DSC_PHY                 0x23
                      00135 
                      00136 ; Protocol Selection
                      00137 #define BOOT_PROTOCOL           0x00
                      00138 #define RPT_PROTOCOL            0x01
                      00139 
                      00140 ; HID Interface Class Code
                      00141 #define HID_INTF                0x03
                      00142 
                      00143 ; HID Interface Class SubClass Codes
                      00144 #define BOOT_INTF_SUBCLASS      0x01
                      00145 
                      00146 ; HID Interface Class Protocol Codes
                      00147 #define HID_PROTOCOL_NONE       0x00
                      00148 #define HID_PROTOCOL_KEYBOAD    0x01
                      00149 #define HID_PROTOCOL_MOUSE      0x02
                      00150 
                      00151 ; HID Report codes used in GET_REPORT and SET_REPORT requests
                      00152 #define HID_INPUT_REPORT     1
                      00153 #define HID_OUTPUT_REPORT    2
                      00154 #define HID_FEATURE_REPORT   3
                      00155 
                      00156 ; From cdc.h
                      00157 ; Class-Specific Requests
                      00158 #define SEND_ENCAPSULATED_COMMAND 0x00
                      00159 #define GET_ENCAPSULATED_RESPONSE 0x01
                      00160 #define SET_COMM_FEATURE        0x02
                      00161 #define GET_COMM_FEATURE        0x03
                      00162 #define CLEAR_COMM_FEATURE      0x04
                      00163 #define SET_LINE_CODING         0x20
                      00164 #define GET_LINE_CODING         0x21
                      00165 #define SET_CONTROL_LINE_STATE  0x22
                      00166 #define SEND_BREAK              0x23
                      00167 
                      00168 ; Notifications
                      00169 ;  Note: Notifications are polled over
                      00170 ;  Communication Interface (Interrupt Endpoint)
                      00171 #define NETWORK_CONNECTION      0x00
                      00172 #define RESPONSE_AVAILABLE      0x01
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00173 #define SERIAL_STATE            0x20
                      00174 
                      00175 ; Device Class Code
                      00176 #define CDC_DEVICE              0x02
                      00177 
                      00178 ; Communication Interface Class Code
                      00179 #define COMM_INTF               0x02
                      00180 
                      00181 ; Communication Interface Class SubClass Codes
                      00182 #define ABSTRACT_CONTROL_MODEL  0x02
                      00183 
                      00184 ; Communication Interface Class Control Protocol Codes
                      00185 #define V25TER                  0x01    ; Common AT commands ("Hayes(TM)")
                      00186 
                      00187 ; Data Interface Class Codes
                      00188 #define DATA_INTF               0x0A
                      00189 
                      00190 ; Data Interface Class Protocol Codes
                      00191 #define NO_PROTOCOL             0x00    ; No class specific protocol required
                      00192 
                      00193 ; Communication Feature Selector Codes
                      00194 #define ABSTRACT_STATE          0x01
                      00195 #define COUNTRY_SETTING         0x02
                      00196 
                      00197 ; Functional Descriptors
                      00198 ; Type Values for the bDscType Field
                      00199 #define CS_INTERFACE            0x24
                      00200 #define CS_ENDPOINT             0x25
                      00201 
                      00202 ; bDscSubType in Functional Descriptors
                      00203 #define DSC_FN_HEADER           0x00
                      00204 #define DSC_FN_CALL_MGT         0x01
                      00205 #define DSC_FN_ACM              0x02    ; ACM - Abstract Control Management
                      00206 #define DSC_FN_DLM              0x03    ; DLM - Direct Line Managment
                      00207 #define DSC_FN_TELEPHONE_RINGER 0x04
                      00208 #define DSC_FN_RPT_CAPABILITIES 0x05
                      00209 #define DSC_FN_UNION            0x06
                      00210 #define DSC_FN_COUNTRY_SELECTION 0x07
                      00211 #define DSC_FN_TEL_OP_MODES     0x08
                      00212 #define DSC_FN_USB_TERMINAL     0x09
                      00213 ; more.... see Table 25 in USB CDC Specification 1.1
                      00214 
                      00215 ; CDC Bulk IN transfer states
                      00216 #define CDC_TX_READY            0
                      00217 #define CDC_TX_BUSY             1
                      00218 #define CDC_TX_BUSY_ZLP         2       ; ZLP: Zero Length Packet
                      00219 #define CDC_TX_COMPLETING       3
                      00220 
                      00221 #define LINE_CODING_LENGTH      0x07
                      00222 #define dummy_length            0x08
                      00223 
                      00224 
                      00225 ; From usbctrltrf.h
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00226 ; Control Transfer States
                      00227 #define WAIT_SETUP              0
                      00228 #define CTRL_TRF_TX             1
                      00229 #define CTRL_TRF_RX             2
                      00230 
                      00231 ; USB PID: Token Types - See chapter 8 in the USB specification
                      00232 #define SETUP_TOKEN             0x0d
                      00233 #define OUT_TOKEN               0x01
                      00234 #define IN_TOKEN                0x09
                      00235 
                      00236 ; bmRequestType Definitions
                      00237 #define HOST_TO_DEV             0
                      00238 #define DEV_TO_HOST             1
                      00239 
                      00240 #define STANDARD                0x00
                      00241 #define CLASS                   0x01
                      00242 #define VENDOR                  0x02
                      00243 
                      00244 #define RCPT_DEV                0
                      00245 #define RCPT_INTF               1
                      00246 #define RCPT_EP                 2
                      00247 #define RCPT_OTH                3
                      00248 
                      00249 
                      00250 ; From usbdrv.h
                      00251 ; UCFG Initialization Parameters
                      00252 #define _PPBM0                  0x00    ; Pingpong Buffer Mode 0
                      00253 #define _PPBM1                  0x01    ; Pingpong Buffer Mode 1
                      00254 #define _PPBM2                  0x02    ; Pingpong Buffer Mode 2
                      00255 #define _LS                     0x00    ; Use Low-Speed USB Mode
                      00256 #define _FS                     0x04    ; Use Full-Speed USB Mode
                      00257 #define _TRINT                  0x00    ; Use internal transceiver
                      00258 #define _TREXT                  0x08    ; Use external transceiver
                      00259 #define _PUEN                   0x10    ; Use internal pull-up resistor
                      00260 #define _OEMON                  0x40    ; Use SIE output indicator
                      00261 #define _UTEYE                  0x80    ; Use Eye-Pattern test
                      00262 
                      00263 ; UEPn Initialization Parameters
                      00264 #define EP_CTRL                 0x06    ; Cfg Control pipe for this ep
                      00265 #define EP_OUT                  0x0C    ; Cfg OUT only pipe for this ep
                      00266 #define EP_IN                   0x0A    ; Cfg IN only pipe for this ep
                      00267 #define EP_OUT_IN               0x0E    ; Cfg both OUT & IN pipes for this ep
                      00268 #define HSHK_EN                 0x10    ; Enable handshake packet
                      00269 
                      00270 #define OUT             0
                      00271 #define IN              1
                      00272 
                      00273 #define PIC_EP_NUM_MASK 0b01111000
                      00274 #define PIC_EP_DIR_MASK 0b00000100
                      00275 
                      00276 #define EP00_OUT        (0x00<<3)|(OUT<<2)
                      00277 #define EP00_IN         (0x00<<3)|(IN<<2)
                      00278 #define EP01_OUT        (0x01<<3)|(OUT<<2)
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00279 #define EP01_IN         (0x01<<3)|(IN<<2)
                      00280 #define EP02_OUT        (0x02<<3)|(OUT<<2)
                      00281 #define EP02_IN         (0x02<<3)|(IN<<2)
                      00282 #define EP03_OUT        (0x03<<3)|(OUT<<2)
                      00283 #define EP03_IN         (0x03<<3)|(IN<<2)
                      00284 #define EP04_OUT        (0x04<<3)|(OUT<<2)
                      00285 #define EP04_IN         (0x04<<3)|(IN<<2)
                      00286 #define EP05_OUT        (0x05<<3)|(OUT<<2)
                      00287 #define EP05_IN         (0x05<<3)|(IN<<2)
                      00288 #define EP06_OUT        (0x06<<3)|(OUT<<2)
                      00289 #define EP06_IN         (0x06<<3)|(IN<<2)
                      00290 #define EP07_OUT        (0x07<<3)|(OUT<<2)
                      00291 #define EP07_IN         (0x07<<3)|(IN<<2)
                      00292 #define EP08_OUT        (0x08<<3)|(OUT<<2)
                      00293 #define EP08_IN         (0x08<<3)|(IN<<2)
                      00294 #define EP09_OUT        (0x09<<3)|(OUT<<2)
                      00295 #define EP09_IN         (0x09<<3)|(IN<<2)
                      00296 #define EP10_OUT        (0x0A<<3)|(OUT<<2)
                      00297 #define EP10_IN         (0x0A<<3)|(IN<<2)
                      00298 #define EP11_OUT        (0x0B<<3)|(OUT<<2)
                      00299 #define EP11_IN         (0x0B<<3)|(IN<<2)
                      00300 #define EP12_OUT        (0x0C<<3)|(OUT<<2)
                      00301 #define EP12_IN         (0x0C<<3)|(IN<<2)
                      00302 #define EP13_OUT        (0x0D<<3)|(OUT<<2)
                      00303 #define EP13_IN         (0x0D<<3)|(IN<<2)
                      00304 #define EP14_OUT        (0x0E<<3)|(OUT<<2)
                      00305 #define EP14_IN         (0x0E<<3)|(IN<<2)
                      00306 #define EP15_OUT        (0x0F<<3)|(OUT<<2)
                      00307 #define EP15_IN         (0x0F<<3)|(IN<<2)
                      00308 
                      00309 
                      00310 ; Buffer Descriptor Byte Aliases
                      00311 #define  Stat   0   ; Buffer Descriptor Status Register
                      00312 #define  Cnt    1   ; Buffer Count
                      00313 ;#define  ADR    2   ; Buffer Address
                      00314 #define  ADRL   2   ; Buffer Address Low
                      00315 #define  ADRH   3   ; Buffer Address High
                      00316 
                      00317 ; Stat Bit Aliases
                      00318 #define  BC8    0   ; Upper Count Bit
                      00319 #define  BC9    1   ; Upper Count Bit
                      00320 #define  BSTALL 2   ; Buffer Stall Enable
                      00321 #define  DTSEN  3   ; Data Toggle Synch Enable
                      00322 #define  INCDIS 4   ; Address Increment Disable
                      00323 #define  KEN    5   ; BD Keep Enable
                      00324 #define  DTS    6   ; Data Toggle Synch Value
                      00325 #define  UOWN   7   ; USB Ownership
                      00326 #define  PID    2   ; Packet Identifier (4 bits)
                      00327 ;#define  PID0   2
                      00328 ;#define  PID1   3
                      00329 ;#define  PID2   4
                      00330 ;#define  PID3   5
                      00331 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00332 ; usb_stat bit aliases
                      00333 #define  RemoteWakeup  0    ; [0]Disabled [1]Enabled
                      00334 #define  ctrl_trf_mem  1    ; [0]RAM      [1]ROM
                      00335 #define  cdc_mem_type  2    ; [0]RAM      [1]ROM
                      00336 
                      00337 ; SetupPkt Byte and Bit Aliases
                      00338 #define  bmRequestType 0
                      00339 #define  bRequest    1
                      00340 #define  wValue      2
                      00341 #define  wValueHi    3
                      00342 #define  wIndex      4
                      00343 #define  wIndexHi    5
                      00344 #define  wLength     6
                      00345 #define  wLengthHi   7
                      00346 
                      00347 #define  Recipient   0    ; Device,Interface,Endpoint,Other (5 bits)
                      00348 #define  RequestType 5    ; Standard,Class,Vendor,Reserved (2 bits)
                      00349 #define  DataDir     7    ; Host-to-device,Device-to-host
                      00350 #define  bFeature    2    ; DEVICE_REMOTE_WAKEUP,ENDPOINT_HALT
                      00351 
                      00352 #define  bReportID   2    ; In a SET_REPORT or GET_REPORT request
                      00353 #define  bReportType 3    ; In a SET_REPORT or GET_REPORT request
                      00354 
                      00355 #define  bDscIndex   2    ; For Configuration and String DSC Only
                      00356 #define  bDscType    3    ; Device,Configuration,String
                      00357 #define  wLangID     4    ; Language ID
                      00358 
                      00359 #define  bDevADR     2    ; Device Address 0-127
                      00360 #define  bDevADRH    3    ; Must equal zero
                      00361 
                      00362 #define  bCfgValue   2    ; Configuration Value 0-255
                      00363 #define  bCfgRSD     3    ; Must equal zero (Reserved)
                      00364 
                      00365 #define  bAltID      2    ; Alternate Setting Value 0-255
                      00366 #define  bAltID_H    3    ; Must equal zero (Reserved)
                      00367 #define  bIntfID     4    ; Interface Number Value 0-255
                      00368 #define  bIntfID_H   5    ; Must equal zero
                      00369 
                      00370 #define  bEPID       4    ; Endpoint ID (Number & Direction)
                      00371 #define  bEPID_H     5    ; Must equal zero
                      00372 
                      00373 #define  EPNum       0    ; Endpoint Number 0-15 (4 bits)
                      00374 #define  EPDir       7    ; Endpoint Direction: 0-OUT, 1-IN
                      00375 
                      00376 ; For CDC device class
                      00377   
                      00378 ; line_coding Byte and Bit Aliases
                      00379 #define  dwDTERate    0   ; Complex data structure
                      00380 #define  bCharFormat  4
                      00381 #define  bParityType  5
                      00382 #define  bDataBits    6
                      00383 
                      00384 ; control_signal_bitmap Byte and Bit Aliases
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00385 #define  DTE_PRESENT      0   ; [0] Not Present  [1] Present
                      00386 #define  CARRIER_CONTROL  1   ; [0] Deactivate   [1] Activate
                      00387 
                      00388 
                      00032   #include pdconsts.inc
                      00001 ;=============================================================
                      00002 ;FILE:      pdconsts.inc
                      00003 ; PROJECT:   Tour1.hpr
                      00004 ; Project Created 31/12/2009 14:45:43 by HIDmaker
                      00005 ; Copyright (c) 2005 by Trace Systems, Inc.  
                      00006 
                      00007 ;This file generated 15/01/2010 17:45:38
                      00008 
                      00009 ; Product Name/Project Description: Dip Coater
                      00010 ; Mfr. Name: Construmaq
                      00011 
                      00012 ; Generated by HIDmaker FS ver. 1.5.0.1 [Copyright (c) 2005 by Trace Systems, Inc.]
                      00013 
                      00014 ;=============================================================
                      00015 
                      00016 ; ******************************************************************
                      00017 ; Project-dependent constants go here: things like number & size of
                      00018 ; endpoints, number of Configurations and Interfaces, and so on.
                      00019 ; ******************************************************************
                      00020 
                      00021 #define  MODE_PP     _PPBM0
                      00022 ; Enable ONE of the following two lines, to choose either full speed (default)
                      00023 ; or low speed USB 
                      00024 #define  UCFG_VAL    _PUEN|_TRINT|_FS|MODE_PP  ; Full-speed
                      00025 ;#define  UCFG_VAL    _PUEN|_TRINT|MODE_PP      ; Low-speed
                      00026 
                      00027 ; Enable one of these if you are dedicating a pin to sense connection to the USB
                      00028 ;#define  USE_SELF_POWER_SENSE_IO
                      00029 ;#define  USE_USB_BUS_SENSE_IO
                      00030 
                      00031 ; Project-specific constants that pertain to the whole device 
                      00032 #define  EP0_BUFF_SIZE   8      ; 8, 16, 32, or 64
                      00033 #define  MAX_NUM_INT     3      ; For Interface Alternates
                      00034 
                      00035 ; CLASS USAGE in this device
                      00036 ; Indicate that HID class is being used (for conditional compile directives)
                      00037 #define  USB_USE_HID
                      00038 
                      00039 #define  NUM_CONFIGURATIONS  1
                      00040 
                      00041 ; For Configuration 1: 
                      00042 ; ==================== 
                      00043 #define  NUM_INTERFACES  1
                      00044 #define  C1_MAX_EP_NUMBER   1
                      00045 ; Define Endpoint size constants for Configuration 1:
                      00046 
                      00047 ; C1_In_Endpoints:
                      00048 #define  EP1_IN_BUFF_SIZE    64  ; 8, 16, 32, or 64 if used; 0 if EP is unused
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00049 #define  EP2_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00050 #define  EP3_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00051 #define  EP4_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00052 #define  EP5_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00053 #define  EP6_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00054 #define  EP7_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00055 #define  EP8_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00056 #define  EP9_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00057 #define  EP10_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00058 #define  EP11_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00059 #define  EP12_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00060 #define  EP13_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00061 #define  EP14_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00062 #define  EP15_IN_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00063 
                      00064 ; C1_OUT_Endpoints:
                      00065 #define  EP1_OUT_BUFF_SIZE    64  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00066 #define  EP2_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00067 #define  EP3_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00068 #define  EP4_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00069 #define  EP5_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00070 #define  EP6_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00071 #define  EP7_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00072 #define  EP8_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00073 #define  EP9_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00074 #define  EP10_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00075 #define  EP11_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00076 #define  EP12_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00077 #define  EP13_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00078 #define  EP14_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00079 #define  EP15_OUT_BUFF_SIZE    0  ; 8, 16, 32, or 64 if used; 0 if EP is unused
                      00080 
                      00081 
                      00082 ;This should have the maximum value of C1_MAX_EP_NUMBER or C2_MAX_EP_NUMBER
                      00083 #define  MAX_EP_NUMBER   1
                      00084 
                      00085 
                      00033   #include USBwatch.inc
                      00001 #ifdef __DO_NOT_DEFINE_THIS
                      00002 ; Note: In order to be able to #include this same file into both C modules and
                      00003 ; assembler modules, we put all comments in this file inside an #ifdef block that is
                      00004 ; never #define-d.  This is done because the assembler and C compiler both
                      00005 ; recognize #ifdef, but they do not agree on the syntax of comments.
                      00006 
                      00007 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00008 
                      00009 ; ************************************************************************
                      00010 ; USBwatch constant definitions
                      00011 
                      00012 ; To use use USBWatch feature, you must enable the line
                      00013 ; that #defines the constant  USB_WATCH  in this file.
                      00014 ;
                      00015 ; To do so, you should move the line "#define USB_WATCH" outside of this
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00016 ; #ifdef block.
                      00017 ;
                      00018 ; To disable USBwatch again, you should move this line back inside this
                      00019 ; #ifdef block again.
                      00020 ;
                      00021 ; ************************************************************************
                      00022 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00023 
                      00024 #define USB_WATCH
                      00025 
                      00026 #endif
                      00027 
                      00028 #ifdef USB_WATCH
                      00029 
                      00030 #define  USBW_POWERED_BIT    0
                      00031 #define  USBW_DEFAULT_BIT    1
                      00032 #define  USBW_ADDRESSED_BIT  2
                      00033 #define  USBW_CONFIGURED_BIT 3
                      00034 #define  USBW_SLEEPING_BIT   4
                      00035 #define  USBW_EP0_BIT        5
                      00036 #define  USBW_EP1_BIT        6
                      00037 #define  USBW_EP2_BIT        7
                      00038 
                      00039 #define  USBW_POWERED_STATE    0x01
                      00040 #define  USBW_DEFAULT_STATE    0x02
                      00041 #define  USBW_ADDRESSED_STATE  0x04
                      00042 #define  USBW_CONFIGURED_STATE 0x08
                      00043 #define  USBW_SLEEPING_STATE   0x10
                      00044 #define  USBW_EP0_STATE        0x20
                      00045 #define  USBW_EP1_STATE        0x40
                      00046 #define  USBW_EP2_STATE        0x80
                      00047 
                      00048 #endif
                      00049 
                      00034 
                      00035 ; Externs from usb18mem.asm:
                      00036 
  0000                00037   extern R0
                      00038 
                      00039 #if(0 <= MAX_EP_NUMBER)
  0000                00040   extern ep0Bo, ep0Bi
                      00041 #endif
                      00042 
                      00043 #if(1 <= MAX_EP_NUMBER)
  0000                00044   extern ep1Bo, ep1Bi
                      00045 #endif
                      00046 
                      00047 #if(2 <= MAX_EP_NUMBER)
                      00048   extern ep2Bo, ep2Bi
                      00049 #endif
                      00050 
                      00051 #if(3 <= MAX_EP_NUMBER)
                      00052   extern ep3Bo, ep3Bi
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00053 #endif
                      00054 
                      00055 #if(4 <= MAX_EP_NUMBER)
                      00056   extern ep4Bo, ep4Bi
                      00057 #endif
                      00058 
                      00059 #if(5 <= MAX_EP_NUMBER)
                      00060   extern ep5Bo, ep5Bi
                      00061 #endif
                      00062 
                      00063 #if(6 <= MAX_EP_NUMBER)
                      00064   extern ep6Bo, ep6Bi
                      00065 #endif
                      00066 
                      00067 #if(7 <= MAX_EP_NUMBER)
                      00068   extern ep7Bo, ep7Bi
                      00069 #endif
                      00070 
                      00071 #if(8 <= MAX_EP_NUMBER)
                      00072   extern ep8Bo, ep8Bi
                      00073 #endif
                      00074 
                      00075 #if(9 <= MAX_EP_NUMBER)
                      00076   extern ep9Bo, ep9Bi
                      00077 #endif
                      00078 
                      00079 #if(10 <= MAX_EP_NUMBER)
                      00080   extern ep10Bo, ep10Bi
                      00081 #endif
                      00082 
                      00083 #if(11 <= MAX_EP_NUMBER)
                      00084   extern ep11Bo, ep11Bi
                      00085 #endif
                      00086 
                      00087 #if(12 <= MAX_EP_NUMBER)
                      00088   extern ep12Bo, ep12Bi
                      00089 #endif
                      00090 
                      00091 #if(13 <= MAX_EP_NUMBER)
                      00092   extern ep13Bo, ep13Bi
                      00093 #endif
                      00094 
                      00095 #if(14 <= MAX_EP_NUMBER)
                      00096   extern ep14Bo, ep14Bi
                      00097 #endif
                      00098 
                      00099 #if(15 <= MAX_EP_NUMBER)
                      00100   extern ep15Bo, ep15Bi
                      00101 #endif
                      00102 
  0000                00103   extern  usb_temp, pSrc, pDst
  0000                00104   extern  SavedFSR0, SavedFSR1, SavedFSR2
  0000                00105   extern  ctrl_trf_state, ctrl_trf_session_owner, wCount
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 13


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                00106   extern  usb_device_state, usb_active_cfg, usb_alt_intf, usb_stat
  0000                00107   extern  SetupPktLen, SetupPkt, CtrlTrfDataLen, CtrlTrfData, CtrlTrfDataStorage
  0000                00108   extern  C1_InEpTable, C1_OutEpTable, C2_InEpTable, C2_OutEpTable
                      00109 
                      00110   
                      00111 #ifdef USB_WATCH
                      00112 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00113   extern  USBWtemp, USBWstate, UmsgBuf
                      00114 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00115 #endif  ;  #ifdef USB_WATCH
                      00116 
  0000                00117   extern  MaxPacketSize, PacketBitIndex, PacketByteIndex, TempByte
  0000                00118   extern  TempCount, VarBits, VarBytes, VarSign, VarSize
                      00119 
                      00120 #ifdef  USB_USE_CDC    ; (See  )
                      00121   extern  line_coding, control_signal_bitmap, dummy_encapsulated_cmd_response
                      00122   extern  dwDTERate, bCharFormat, bParityType, bDataBits
                      00123   extern  cdc_notice, cdc_data_rx, cdc_data_tx
                      00124 #endif   ;  #ifdef USB_USE_CDC
                      00125 
                      00126 ; Externs from descript.asm:
                      00127 
  0000                00128   extern  DeviceDescriptor, Config1, Config1Len, HID0, Config2, Config2Len
  0000                00129   extern  C1_RD_Table, C2_RD_Table, USB_SD_Ptr
                      00130 
                      00131   #include VTextern.inc
                      00001 ;=============================================================
                      00002 ;FILE:      VTextern.inc
                      00003 ; PROJECT:   Tour1.hpr
                      00004 ; Project Created 31/12/2009 14:45:43 by HIDmaker
                      00005 ; Copyright (c) 2005 by Trace Systems, Inc.  
                      00006 
                      00007 ;This file generated 15/01/2010 17:45:38
                      00008 
                      00009 ; Product Name/Project Description: Dip Coater
                      00010 ; Mfr. Name: Construmaq
                      00011 
                      00012 ; Generated by HIDmaker FS ver. 1.5.0.1 [Copyright (c) 2005 by Trace Systems, Inc.]
                      00013 
                      00014 ;=============================================================
                      00015 
                      00016 
                      00017 #ifdef USB_USE_HID
                      00018 
  0000                00019   extern  EP1_InBuffer
  0000                00020   extern  EP1_OutBuffer
                      00021 
                      00022 #endif   ; #ifdef USB_USE_HID
                      00023 
  0000                00024   extern  Ep1RcvVarTable, Ep1XmtVarTable, Ep2RcvVarTable, Ep2XmtVarTable
  0000                00025   extern  FeatureVarTable, CtlOutVarTable
                      00132 
                      00133 ; Externs from main module:
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 14


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                00134   extern  HLL_IdleRate, HLL_ActiveProtocol, USB_Curr_Config, USB_Curr_Identity
  0000                00135   extern  FeatureIn, RcvFeatureRpt, RcvOutRpt
                      00136 
                      00137 #ifdef USB_WATCH
                      00138 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00139   extern  USBW_On
                      00140 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00141 #endif  ;  #ifdef USB_WATCH
                      00142   
                      00143   code
                      00144 
                      00145 ;=====================================================================
                      00146 ; Wrapper routines callable from C18
                      00147 ;=====================================================================
                      00148 
                      00149 
                      00150 ;/******************************************************************************
                      00151 ; * Function:        void USBInit(void)
                      00152 ; *
                      00153 ; * PreCondition:    None
                      00154 ; *
                      00155 ; * Input:           None
                      00156 ; *
                      00157 ; * Output:          None
                      00158 ; *
                      00159 ; * Side Effects:    None
                      00160 ; *
                      00161 ; * Overview:        This routine initializes the USB module and driver 
                      00162 ; *                  routines.
                      00163 ; *
                      00164 ; * Note:            None
                      00165 ; *****************************************************************************/
000000                00166 USBInit
  0000                00167   global USBInit
                      00168 
                      00169 ; Save C18 FSR0, FSR1 and FSR2
000000 D???           00170   rcall   SaveFSRs
                      00171   
                      00172 #ifdef USE_USB_BUS_SENSE_IO
                      00173   bsf  tris_usb_bus_sense
                      00174 #endif
                      00175   
                      00176 #ifdef USE_USB_SELF_PWER_SENSE_IO
                      00177   bsf  tris_self_power
                      00178 #endif
                      00179   
000002 D???           00180   rcall   InitializeUSBDriver
                      00181   
                      00182 ; Restore C18 FSR0, FSR1 and FSR2
000004 D???           00183   rcall   RestoreFSRs
                      00184   
000006 0012           00185   return
                      00186 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 15


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00187 
                      00188 ;/******************************************************************************
                      00189 ; * Function:        void USBService(void)
                      00190 ; *
                      00191 ; * PreCondition:    None
                      00192 ; *
                      00193 ; * Input:           None
                      00194 ; *
                      00195 ; * Output:          None
                      00196 ; *
                      00197 ; * Side Effects:    None
                      00198 ; *
                      00199 ; * Overview:        This routine must be called regularly to service
                      00200 ; *                  all USB requests from PC.
                      00201 ; *
                      00202 ; *****************************************************************************/
000008                00203 USBService
  0000                00204   global USBService
                      00205   
                      00206 ; Save C18 FSR0, FSR1 and FSR2
000008 D???           00207   rcall   SaveFSRs
                      00208   
00000A D???           00209   rcall    USBCheckBusStatus
                      00210   
00000C D???           00211   rcall    USBDriverService
                      00212   
                      00213 ; Restore C18 FSR0, FSR1 and FSR2
00000E D???           00214   rcall   RestoreFSRs
                      00215   
000010 0012           00216   return
                      00217 
                      00218 
                      00219 ; ************************************************************************
                      00220 ; ReadAndUnpackOnePacket
                      00221 ;
                      00222 ; Precondition: None
                      00223 ;
                      00224 ; Inputs:  EpNum: number of the OUTPUT endpoint to get this Output Report from
                      00225 ;          VarTable: address of the corresponding Variable Info Table
                      00226 ;                      (located in file DESCRIPT.ASM)
                      00227 ;
                      00228 ; Output:  0 if report is done or no report is in progress
                      00229 ;          0xFF if a multi-paccket report is in progress,
                      00230 ;                  (i.e., more packets are expected)
                      00231 ;
                      00232 ; Side effects:
                      00233 ;
                      00234 ; Overview: This function is called multiple times from the main loop.
                      00235 ;           It should be called repeatedly, until it returns 0 (FALSE),
                      00236 ;           which indicates that the entire Output Report has been received,
                      00237 ;           and is now ready for processing of the data.
                      00238 ;
                      00239 ; unsigned char ReadAndUnpackOnePacket( unsigned char EpNum, rom const * VarTable);
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 16


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00240 ;
                      00241 ; ************************************************************************
000012                00242 ReadAndUnpackOnePacket
  0000                00243   global ReadAndUnpackOnePacket
                      00244   
                      00245 ; Adjust the C18 software stack. As in C18, assumes FSR2H = FSR1H
000012 CFD9 FFE6      00246   movff   FSR2L, POSTINC1     ; push FSR2 on stack
000016 CFE1 FFD9      00247   movff   FSR1L, FSR2L        ; Copy FSR1 to FSR2
                      00248 ;  movf    POSTINC1, F, a      ; OPTIONAL: Increment stack ptr to allocate space for 1 local var
00001A 0104           00249   movlb   4                   ; point to USB ram
                      00250 
                      00251 ; Save C18 FSR1 and FSR2
00001C D???           00252   rcall   SaveFSRs
                      00253   
                      00254 ; Rearrange the C18 parameters and call UnPacket  
00001E 0EFD           00255   movlw   0xFD                ; high (Arg2 = &VarTable) is at offset -3 from FSR2
000020 50DB           00256   movf    PLUSW2, W           ; VarTable -> W
000022 6EF7           00257   movwf   TBLPTRH                         ; parameter VarTable -> local var pVarTable
                      00258 
000024 0EFC           00259   movlw   0xFC                ; low (Arg2 = &VarTable) is at offset -4 from FSR2
000026 50DB           00260   movf    PLUSW2, W           ; VarTable -> W
000028 6EF6           00261   movwf   TBLPTRL                         ; parameter VarTable -> local var pVarTable
00002A 6AF8           00262   clrf  TBLPTRU
                      00263 
00002C 0EFE           00264   movlw   0xFE                ; Arg1, EpNum, is at offset -2 from FSR2
00002E 50DB           00265   movf    PLUSW2, W           ; EpNum -> W
                      00266   
000030 EC?? F???      00267   call   UnPacket
                      00268   
                      00269 ; Result to be returned is already in W
                      00270    
                      00271 ; Restore C18 FSR1 and FSR2
000034 D???           00272   rcall   RestoreFSRs
                      00273 
                      00274 ; Adjust s/w stack for return
000036 52E5           00275   movf    POSTDEC1, F         ; Point to previous frame pointer
000038 CFE7 FFD9      00276   movff   INDF1, FSR2L        ; Restore previous value of FSR2 (calling frame ptr) 
                      00277   
00003C 0012           00278   return  
                      00279 
                      00280 
                      00281 ; ************************************************************************
                      00282 ; PackAndSendOnePacket
                      00283 ;
                      00284 ; Precondition: None
                      00285 ;
                      00286 ; Inputs:  EpNum: number of the INPUT endpoint to send this Input Report to
                      00287 ;          VarTable: address of the corresponding Variable Info Table
                      00288 ;                      (located in file DESCRIPT.ASM)
                      00289 ;
                      00290 ; Output:  0 if report is done or no report is in progress
                      00291 ;          0xFF if a multi-paccket report is in progress,
                      00292 ;                  (i.e., more packets remain to be sent)
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 17


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00293 ;
                      00294 ; Side effects:
                      00295 ;
                      00296 ; Overview: This function is called multiple times from the main loop.
                      00297 ;           It should be called repeatedly, until it returns 0 (FALSE),
                      00298 ;           which indicates that the entire Input Report has been sent to the PC.
                      00299 ;
                      00300 ; unsigned char PackAndSendOnePacket( unsigned char EpNum, rom const * VarTable);
                      00301 ;
                      00302 ; ************************************************************************
                      00303 
00003E                00304 PackAndSendOnePacket
  0000                00305   global PackAndSendOnePacket
                      00306 
                      00307   
                      00308 ; Adjust the C18 software stack. As in C18, assumes FSR2H = FSR1H
00003E CFD9 FFE6      00309   movff   FSR2L, POSTINC1     ; push FSR2 on stack
000042 CFE1 FFD9      00310   movff   FSR1L, FSR2L        ; Copy FSR1 to FSR2
                      00311 ;  movf    POSTINC1, F, a      ; OPTIONAL: Increment stack ptr to allocate space for 1 local var    
000046 0104           00312   movlb   4                   ; point to USB ram
                      00313 
                      00314 ; Save C18 FSR1 and FSR2
000048 D???           00315   rcall   SaveFSRs
                      00316 ;  movff   FSR1L, SavedFSR1
                      00317 ;  movff   FSR1H, SavedFSR1+1
                      00318 ;  movff   FSR2L, SavedFSR2
                      00319 ;  movff   FSR2H, SavedFSR2+1
                      00320   
                      00321 ; Rearrange the C18 parameters and call PackandShipPacket
                      00322 ; * Input:           W contains EndPoint number
                      00323 ; *                  TBLPTRH/L is VarTable address
00004A 0EFD           00324   movlw   0xFD                ; high (Arg2 = &VarTable) is at offset -3 from FSR2
00004C 50DB           00325   movf    PLUSW2, W           ; VarTable -> W
00004E 6EF7           00326   movwf   TBLPTRH                         ; parameter VarTable -> local var pVarTable
                      00327 
000050 0EFC           00328   movlw   0xFC                ; low (Arg2 = &VarTable) is at offset -4 from FSR2
000052 50DB           00329   movf    PLUSW2, W           ; VarTable -> W
000054 6EF6           00330   movwf   TBLPTRL                         ; parameter VarTable -> local var pVarTable
000056 6AF8           00331   clrf  TBLPTRU
                      00332 
000058 0EFE           00333   movlw   0xFE                ; Arg1, EpNum, is at offset -2 from FSR2
00005A 50DB           00334   movf    PLUSW2, W           ; EpNum -> W
                      00335 
00005C EC?? F???      00336   call   PackandShipPacket
                      00337 ; *
                      00338 ; * Output:          Returns W = 0 when Report is all packed,
                      00339 ; *                  W != 0 if there are still more packets to go or if Endpoint busy
                      00340   
                      00341 ; Result to be returned is already in W
                      00342    
                      00343 ; Restore C18 FSR1 and FSR2
000060 D???           00344   rcall   RestoreFSRs
                      00345 ;  movff   SavedFSR1, FSR1L
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 18


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00346 ;  movff   SavedFSR1+1, FSR1H
                      00347 ;  movff   SavedFSR2, FSR2L
                      00348 ;  movff   SavedFSR2+1, FSR2H
                      00349   
                      00350 ; Adjust s/w stack for return
000062 52E5           00351   movf    POSTDEC1, F         ; Point to previous frame pointer
000064 CFE7 FFD9      00352   movff   INDF1, FSR2L        ; Restore previous value of FSR2 (calling frame ptr) 
                      00353   
000068 0012           00354   return  
                      00355 
                      00356 
                      00357 ; ************************************************************************
                      00358 ; UsbPutPacket
                      00359 ;
                      00360 ; Precondition: Buffer must be of suitable length to hold data
                      00361 ;
                      00362 ; Inputs:  EpNum    : number of the OUTPUT endpoint to which to send this Output packet
                      00363 ;          pBuffPtr : pointer into the buffer which holds data to be sent
                      00364 ;          Count    : Number of bytes in Buffer
                      00365 ;
                      00366 ;
                      00367 ; Returns: 0 if endpoint is unavailable due to a pending transfer
                      00368 ;          0xFF data was sent to endpoint buffer
                      00369 ;          Count is modified to hold number of bytes actually SENT, if any
                      00370 ;          pBuffPtr is updated as well
                      00371 ;
                      00372 ; Side effects:  
                      00373 ;
                      00374 ; Overview: Takes Count number of bytes from Buffer and sends them to USB endpoint EpNum.
                      00375 ;           If buffer size > Count, 
                      00376 ;           If buffer size < Count, 
                      00377 ;
                      00378 ; unsigned char UsbPutPacket( unsigned char EpNum, unsigned char * * pBuffPtr, unsigned char * Count);
                      00379 ;
                      00380 ; ************************************************************************
00006A                00381 UsbPutPacket
  0000                00382   global UsbPutPacket
                      00383 
                      00384 ; Adjust the C18 software stack. As in C18, assumes FSR2H = FSR1H
00006A CFD9 FFE6      00385   movff   FSR2L, POSTINC1     ; push FSR2 on stack
00006E CFE1 FFD9      00386   movff   FSR1L, FSR2L        ; Copy FSR1 to FSR2
                      00387 ;  movf    POSTINC1, F, a      ; OPTIONAL: Increment stack ptr to allocate space for 1 local var
000072 0104           00388   movlb   4                   ; point to USB ram
                      00389 
                      00390 ; Save C18 FSR1 and FSR2
000074 D???           00391   rcall   SaveFSRs
                      00392 
                      00393 ; Rearrange the C18 parameters and call PutUSB
                      00394 ; * Input:           FSR0L is endpoint number (FSR0H = 0)
                      00395 ; *                  FSR1 is source buffer pointer
                      00396 ; *                  W is count
000076 0EFC           00397   movlw   0xFC                ; Low (Arg2 = &pBuffPtr) is at offset -4 from FSR2
000078 CFDB FFE9      00398   movff   PLUSW2, FSR0L       ; Low(&pBuffPtr) -> FSR0L
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 19


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00007C 0EFD           00399   movlw   0xFD                ; High (Arg2 = pBuffPtr) is at offset -3 from FSR2
00007E CFDB FFEA      00400   movff   PLUSW2, FSR0H       ; High(&pBuffPtr) -> FSR0H
000082 CFEE FFE1      00401   movff   POSTINC0, FSR1L     ; Now copy contents of pBuffPtr to FSR1
000086 CFEE FFE2      00402   movff   POSTINC0, FSR1H     
                      00403 
00008A 0EFA           00404   movlw   0xFA                ; Low (Arg3 = &Count) is at offset -6 from FSR2
00008C CFDB FFE9      00405   movff   PLUSW2, FSR0L       ; Low(&Count) -> FSR0L
000090 0EFB           00406   movlw   0xFB                ; High (Arg3 = &Count) is at offset -5 from FSR2
000092 CFDB FFEA      00407   movff   PLUSW2, FSR0H       ; High(&Count) -> FSR0H
000096 CFEF F???      00408   movff   INDF0, usb_temp     ; Count -> usb_temp
                      00409 
00009A 0EFE           00410   movlw   0xFE                ; Arg1, EpNum, is at offset -2 from FSR2
00009C CFDB FFE9      00411   movff   PLUSW2, FSR0L       ; EpNum -> FSR0L
0000A0 0E00           00412   movlw   0
0000A2 6EEA           00413   movwf   FSR0H
                      00414 
0000A4 50??           00415   movf    usb_temp, W
                      00416 
0000A6 EC?? F???      00417   call   PutUSB
                      00418 
                      00419 ; Rearrange the C18 parameters returned from PutUSB
                      00420 ; * Output:          FSR1 is updated source buffer pointer
                      00421 ; *                  W returns number sent
                      00422 ; *                  Carry is clear for buffer not available
0000AA 6E??           00423   movwf   usb_temp            ; Temporarily stash number sent
0000AC 0E00           00424   movlw   0                   ; Determine return value based on Carry...
0000AE B0D8           00425   btfsc   STATUS, C
0000B0 0EFF           00426   movlw   0xFF
0000B2 6E??           00427   movwf   usb_temp+1          ; .. & temporarily stash return value
                      00428 
                      00429 ; Restore C18 FSR2
0000B4 C??? FFD9      00430   movff   SavedFSR2, FSR2L
0000B8 C??? FFDA      00431   movff   SavedFSR2+1, FSR2H
                      00432 
                      00433   ; Update pBuffPtr
0000BC 0EFC           00434   movlw   0xFC                ; Low (Arg2 = &pBuffPtr) is at offset -4 from FSR2
0000BE CFDB FFE9      00435   movff   PLUSW2, FSR0L       ; Low(&pBuffPtr) -> FSR0L
0000C2 0EFD           00436   movlw   0xFD                ; High (Arg2 = pBuffPtr) is at offset -3 from FSR2
0000C4 CFDB FFEA      00437   movff   PLUSW2, FSR0H       ; High(&pBuffPtr) -> FSR0H
0000C8 CFE1 FFEE      00438   movff   FSR1L, POSTINC0     ; Now copy contents of FSR1 to pBuffPtr
0000CC CFE2 FFEE      00439   movff   FSR1H, POSTINC0
                      00440 
                      00441   ; Update Count
0000D0 0EFA           00442   movlw   0xFA                ; Low (Arg3 = &Count) is at offset -6 from FSR2
0000D2 CFDB FFE1      00443   movff   PLUSW2, FSR1L       ; Low(&Count) -> FSR1L
0000D6 0EFB           00444   movlw   0xFB                ; High (Arg3 = &Count) is at offset -5 from FSR2
0000D8 CFDB FFE2      00445   movff   PLUSW2, FSR1H       ; High(&Count) -> FSR1H
0000DC C??? FFE7      00446   movff   usb_temp, INDF1     ; Update value of Count
                      00447 
                      00448 ; Now we can restore C18 FSR0 and FSR1
0000E0 C??? FFE9      00449   movff   SavedFSR0, FSR0L
0000E4 C??? FFEA      00450   movff   SavedFSR0+1, FSR0H
0000E8 C??? FFE1      00451   movff   SavedFSR1, FSR1L
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 20


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0000EC C??? FFE2      00452   movff   SavedFSR1+1, FSR1H
                      00453 
                      00454   ; Set return value
0000F0 50??           00455   movf    usb_temp+1, W
                      00456 
                      00457 ; Adjust s/w stack for return
0000F2 52E5           00458   movf    POSTDEC1, F         ; Point to previous frame pointer
0000F4 CFE7 FFD9      00459   movff   INDF1, FSR2L        ; Restore previous value of FSR2 (calling frame ptr)
                      00460   
0000F8 0012           00461   return
                      00462 
                      00463 
                      00464 ; ************************************************************************
                      00465 ; UsbGetPacket
                      00466 ;
                      00467 ; Precondition: Buffer must be of suitable length to hold data
                      00468 ;
                      00469 ; Inputs:  EpNum    : number of the INPUT endpoint from which to send this Input packet
                      00470 ;          pBuffPtr : pointer into the buffer which holds data to be sent
                      00471 ;          Count    : max buffer length
                      00472 ;
                      00473 ;
                      00474 ; Returns: 0 if endpoint is unavailable due to a pending transfer
                      00475 ;          0xFF data was transferred from endpoint buffer
                      00476 ;          Count is modified to hold number of bytes actually RECEIVED, if any
                      00477 ;          pBuffPtr is updated as well
                      00478 ;
                      00479 ; Side effects:  
                      00480 ;
                      00481 ; Overview: Transfers up to Count number of bytes from USB endpoint EpNum to pBuffer*.
                      00482 ;           If buffer size > Count, 
                      00483 ;           If buffer size < Count, 
                      00484 ;
                      00485 ; unsigned char UsbGetPacket( unsigned char EpNum, unsigned char * * pBuffPtr, unsigned char * Count);
                      00486 ;
                      00487 ; ************************************************************************
0000FA                00488 UsbGetPacket
  0000                00489   global UsbGetPacket
                      00490 
                      00491 ; Adjust the C18 software stack. As in C18, assumes FSR2H = FSR1H
0000FA CFD9 FFE6      00492   movff   FSR2L, POSTINC1     ; push FSR2 on stack
0000FE CFE1 FFD9      00493   movff   FSR1L, FSR2L        ; Copy FSR1 to FSR2
                      00494 ;  movf    POSTINC1, F, a      ; OPTIONAL: Increment stack ptr to allocate space for 1 local var
000102 0104           00495   movlb   4                   ; point to USB ram
                      00496 
                      00497 ; Save C18 FSR1 and FSR2
000104 D???           00498   rcall   SaveFSRs
                      00499 
                      00500 ; Rearrange the C18 parameters and call GetUSB
                      00501 ; * Input:           FSR0L is endpoint number
                      00502 ; *                  FSR1 is destination buffer pointer
                      00503 ; *                  W is max buffer length
000106 0EFC           00504   movlw   0xFC                ; Low (Arg2 = &pBuffPtr) is at offset -4 from FSR2
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 21


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000108 CFDB FFE9      00505   movff   PLUSW2, FSR0L       ; Low(&pBuffPtr) -> FSR0L
00010C 0EFD           00506   movlw   0xFD                ; High (Arg2 = pBuffPtr) is at offset -3 from FSR2
00010E CFDB FFEA      00507   movff   PLUSW2, FSR0H       ; High(&pBuffPtr) -> FSR0H
000112 CFEE FFE1      00508   movff   POSTINC0, FSR1L     ; Now copy contents of pBuffPtr to FSR1
000116 CFEE FFE2      00509   movff   POSTINC0, FSR1H     
                      00510 
00011A 0EFA           00511   movlw   0xFA                ; Low (Arg3 = &Count) is at offset -6 from FSR2
00011C CFDB FFE9      00512   movff   PLUSW2, FSR0L       ; Low(&Count) -> FSR0L
000120 0EFB           00513   movlw   0xFB                ; High (Arg3 = &Count) is at offset -5 from FSR2
000122 CFDB FFEA      00514   movff   PLUSW2, FSR0H       ; High(&Count) -> FSR0H
000126 CFEF F???      00515   movff   INDF0, usb_temp     ; Count -> usb_temp
                      00516 
00012A 0EFE           00517   movlw   0xFE                ; Arg1, EpNum, is at offset -2 from FSR2
00012C CFDB FFE9      00518   movff   PLUSW2, FSR0L       ; EpNum -> FSR0L
000130 0E00           00519   movlw   0
000132 6EEA           00520   movwf   FSR0H
                      00521 
000134 50??           00522   movf    usb_temp, W
                      00523 
000136 EC?? F???      00524   call   GetUSB
                      00525 
                      00526 ; Rearrange the C18 parameters returned from GetUSB
                      00527 ; * Output:          FSR1 is updated destination buffer pointer
                      00528 ; *                  W returns number received
                      00529 ; *                  Carry is clear for buffer not available
00013A 6E??           00530   movwf   usb_temp            ; Temporarily stash number sent
00013C 0E00           00531   movlw   0                   ; Determine return value based on Carry...
00013E B0D8           00532   btfsc   STATUS, C
000140 0EFF           00533   movlw   0xFF
000142 6E??           00534   movwf   usb_temp+1          ; .. & temporarily stash return value
                      00535 
                      00536 ; Restore C18 FSR2
000144 C??? FFD9      00537   movff   SavedFSR2, FSR2L
000148 C??? FFDA      00538   movff   SavedFSR2+1, FSR2H
                      00539 
                      00540   ; Update pBuffPtr
00014C 0EFC           00541   movlw   0xFC                ; Low (Arg2 = &pBuffPtr) is at offset -4 from FSR2
00014E CFDB FFE9      00542   movff   PLUSW2, FSR0L       ; Low(&pBuffPtr) -> FSR0L
000152 0EFD           00543   movlw   0xFD                ; High (Arg2 = pBuffPtr) is at offset -3 from FSR2
000154 CFDB FFEA      00544   movff   PLUSW2, FSR0H       ; High(&pBuffPtr) -> FSR0H
000158 CFE1 FFEE      00545   movff   FSR1L, POSTINC0     ; Now copy contents of FSR1 to pBuffPtr
00015C CFE2 FFEE      00546   movff   FSR1H, POSTINC0
                      00547 
                      00548   ; Update Count
000160 0EFA           00549   movlw   0xFA                ; Low (Arg3 = &Count) is at offset -6 from FSR2
000162 CFDB FFE1      00550   movff   PLUSW2, FSR1L       ; Low(&Count) -> FSR1L
000166 0EFB           00551   movlw   0xFB                ; High (Arg3 = &Count) is at offset -5 from FSR2
000168 CFDB FFE2      00552   movff   PLUSW2, FSR1H       ; High(&Count) -> FSR1H
00016C C??? FFE7      00553   movff   usb_temp, INDF1     ; Update value of Count
                      00554 
                      00555 ; Now we can restore C18 FSR0 and FSR1
000170 C??? FFE9      00556   movff   SavedFSR0, FSR0L
000174 C??? FFEA      00557   movff   SavedFSR0+1, FSR0H
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 22


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000178 C??? FFE1      00558   movff   SavedFSR1, FSR1L
00017C C??? FFE2      00559   movff   SavedFSR1+1, FSR1H
                      00560 
                      00561   ; Set return value
000180 50??           00562   movf    usb_temp+1, W
                      00563 
                      00564 ; Adjust s/w stack for return
000182 52E5           00565   movf    POSTDEC1, F         ; Point to previous frame pointer
000184 CFE7 FFD9      00566   movff   INDF1, FSR2L        ; Restore previous value of FSR2 (calling frame ptr)
                      00567 
000188 0012           00568   return
                      00569 
                      00570 #ifdef USB_WATCH
                      00571 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00572 ; Add USBwatch activity reporting over hardware serial port
                      00573 ;
                      00574 ; Two wrapper functions to make it easy to send USBwatch user-defined 
                      00575 ; messages from C code
                      00576 
                      00577 ; ************************************************************************
                      00578 ; UsbwSendU
                      00579 ;
                      00580 ; Precondition: None
                      00581 ;
                      00582 ; Inputs:  ByteCount: number bytes to send
                      00583 ;          Buf: address of buffer (in data memory)
                      00584 ;
                      00585 ; Output:  none
                      00586 ;
                      00587 ; Side effects:
                      00588 ;
                      00589 ; Overview: Sends a user-defined USBwatch message, from data in RAM
                      00590 ;
                      00591 ; void UsbwSendU(unsigned char ByteCount, const unsigned char * Buf);
                      00592 ;
                      00593 ; ************************************************************************
                      00594 UsbwSendU:
                      00595   global  UsbwSendU
                      00596 
                      00597 ; Adjust the C18 software stack. As in C18, assumes FSR2H = FSR1H
                      00598   movff   FSR2L, POSTINC1     ; push FSR2 on stack
                      00599   movff   FSR1L, FSR2L        ; Copy FSR1 to FSR2
                      00600 ;  movf    POSTINC1, F, a      ; OPTIONAL: Increment stack ptr to allocate space for 1 local var
                      00601   movlb   4                   ; point to USB ram
                      00602 
                      00603 ; Save C18 FSR1 and FSR2
                      00604   rcall   SaveFSRs
                      00605   
                      00606 ; Rearrange the C18 parameters and call UsbwSendUSR  
                      00607 ; UsbwSendUSR
                      00608 ;
                      00609 ; Sends a 'U' (User) message
                      00610 ;
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 23


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00611 ; From within PicBasic Pro code, use: HSEROUT ["U", <byte count>, <data>]
                      00612 ;
                      00613 ; Use this version for sending 'U' messages from assembler code in this file
                      00614 ; INPUTS: WREG = byte count
                      00615 ;         FSR0 : IRP point to buffer
                      00616 ;
                      00617 ; Example:
                      00618 ; ========
                      00619 ;  lfsr    0, UmsgBuf     ; Address of buffer that contains your message
                      00620 ;  movlw   <byte count>   ; Number of bytes you want to send
                      00621 ;  rcall    UsbwSendUSR
                      00622 ;
                      00623 ; Rearrange the C18 parameters and call UsbwSendUSR
                      00624 
                      00625   movlw   0xFD                ; high (Arg2 = &Buf) is at offset -3 from FSR2
                      00626   movff    PLUSW2, FSR0H       ; high (Arg2 = &Buf) -> FSR0H
                      00627 
                      00628   movlw   0xFC                ; low (Arg2 = &Buf) is at offset -4 from FSR2
                      00629   movff    PLUSW2, FSR0L       ; low (Arg2 = &Buf) -> FSR0L
                      00630 
                      00631   movlw   0xFE                ; Arg1, EpNum, is at offset -2 from FSR2
                      00632   movf    PLUSW2, W           ; ByteCount -> W
                      00633 
                      00634   call    UsbwSendUSR
                      00635 
                      00636 ; Restore C18 FSR1 and FSR2
                      00637   rcall   RestoreFSRs
                      00638   
                      00639 ; Adjust s/w stack for return
                      00640   movf    POSTDEC1, F         ; Point to previous frame pointer
                      00641   movff   INDF1, FSR2L        ; Restore previous value of FSR2 (calling frame ptr) 
                      00642   
                      00643   return
                      00644 
                      00645 
                      00646 ; ************************************************************************
                      00647 ; UsbwSendU_R
                      00648 ;
                      00649 ; Precondition: None
                      00650 ;
                      00651 ; Inputs:  ByteCount: number bytes to send
                      00652 ;          Buf: address of buffer (in program memory)
                      00653 ;
                      00654 ; Output:  none
                      00655 ;
                      00656 ; Side effects:
                      00657 ;
                      00658 ; Overview: Sends a user-defined USBwatch message, from data in program ROM
                      00659 ;
                      00660 ; void UsbwSendU_R(unsigned char ByteCount, rom const unsigned char * RomStr);
                      00661 ;
                      00662 ; ************************************************************************
                      00663 UsbwSendU_R:
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 24


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00664   global  UsbwSendU_R
                      00665 
                      00666 ; Adjust the C18 software stack. As in C18, assumes FSR2H = FSR1H
                      00667   movff   FSR2L, POSTINC1     ; push FSR2 on stack
                      00668   movff   FSR1L, FSR2L        ; Copy FSR1 to FSR2
                      00669 ;  movf    POSTINC1, F, a      ; OPTIONAL: Increment stack ptr to allocate space for 1 local var
                      00670   movlb   4                   ; point to USB ram
                      00671 
                      00672 ; Save C18 FSR1 and FSR2
                      00673   rcall   SaveFSRs
                      00674   
                      00675 ; Rearrange the C18 parameters and call UsbwSendUSR  
                      00676   movlw   0xFD                ; high (Arg2 = &RomStr) is at offset -3 from FSR2
                      00677   movff    PLUSW2, TBLPTRH     ; high (Arg2 = &RomStr) -> TBLPTRH
                      00678 
                      00679   movlw   0xFC                ; low (Arg2 = &Buf) is at offset -4 from FSR2
                      00680   movff    PLUSW2, TBLPTRL     ; low (Arg2 = &Buf) -> TBLPTRL
                      00681   clrf  TBLPTRU
                      00682 
                      00683   movlw   0xFE                ; Arg1, ByteCount, is at offset -2 from FSR2
                      00684   movf    PLUSW2, W           ; ByteCount -> W
                      00685   bz      UsbwSendU_R2        ; Bail out if zero  
                      00686 
                      00687 ; Copy the bytes from RomStr to UmsgBuf
                      00688   lfsr    0, UmsgBuf
                      00689 UsbwSendU_R1:
                      00690   tblrd   *+
                      00691   movff   TABLAT, POSTINC0
                      00692   decfsz   WREG
                      00693   bra     UsbwSendU_R1
                      00694 
                      00695 ; Now call UsbwSendUSR and transmit bytes from UmsgBuf
                      00696   lfsr    0, UmsgBuf
                      00697   movlw   0xFE                ; Arg1, ByteCount, is at offset -2 from FSR2
                      00698   movf    PLUSW2, W           ; ByteCount -> W
                      00699 
                      00700   call    UsbwSendUSR
                      00701 
                      00702 ; Restore C18 FSR1 and FSR2
                      00703 UsbwSendU_R2:
                      00704   rcall   RestoreFSRs
                      00705   
                      00706 ; Adjust s/w stack for return
                      00707   movf    POSTDEC1, F         ; Point to previous frame pointer
                      00708   movff   INDF1, FSR2L        ; Restore previous value of FSR2 (calling frame ptr) 
                      00709   
                      00710   return
                      00711 
                      00712 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      00713 #endif  ;  #ifdef USB_WATCH
                      00714 
                      00715 
                      00716 ;=====================================================================
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 25


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00717 ; Utility routines for C18 interface :
                      00718 ;=====================================================================
                      00719 
                      00720 ; Save FSR0 .. FSR2 in USB ram variables
00018A                00721 SaveFSRs
                      00722 ; Push old values of SavedFSR0..2 onto software stack  
00018A C??? FFE6      00723   movff   SavedFSR0,   POSTINC1       ; push SavedFSR0 on s/w stack
00018E C??? FFE6      00724   movff   SavedFSR0+1, POSTINC1     
000192 C??? FFE6      00725   movff   SavedFSR1,   POSTINC1       ; push SavedFSR1 on s/w stack
000196 C??? FFE6      00726   movff   SavedFSR1+1, POSTINC1     
00019A C??? FFE6      00727   movff   SavedFSR2,   POSTINC1       ; push SavedFSR2 on s/w stack
00019E C??? FFE7      00728   movff   SavedFSR2+1, INDF1     
                      00729   
0001A2 CFE9 F???      00730   movff   FSR0L, SavedFSR0
0001A6 CFEA F???      00731   movff   FSR0H, SavedFSR0+1
0001AA CFE1 F???      00732   movff   FSR1L, SavedFSR1
0001AE CFE2 F???      00733   movff   FSR1H, SavedFSR1+1
0001B2 CFD9 F???      00734   movff   FSR2L, SavedFSR2
0001B6 CFDA F???      00735   movff   FSR2H, SavedFSR2+1
                      00736 
0001BA 0012           00737   return
                      00738 
                      00739 ; Restore FSR0 .. FSR2 from USB ram variables
0001BC                00740 RestoreFSRs
0001BC C??? FFE9      00741   movff   SavedFSR0, FSR0L
0001C0 C??? FFEA      00742   movff   SavedFSR0+1, FSR0H
0001C4 C??? FFE1      00743   movff   SavedFSR1, FSR1L
0001C8 C??? FFE2      00744   movff   SavedFSR1+1, FSR1H
0001CC C??? FFD9      00745   movff   SavedFSR2, FSR2L
0001D0 C??? FFDA      00746   movff   SavedFSR2+1, FSR2H
                      00747 
                      00748 ; Pop old values of SavedFSR0..2 from software stack  
0001D4 CFE5 F???      00749   movff   POSTDEC1, SavedFSR2+1       ; pop SavedFSR2 from s/w stack      
0001D8 CFE5 F???      00750   movff   POSTDEC1, SavedFSR2     
0001DC CFE5 F???      00751   movff   POSTDEC1, SavedFSR1+1       ; pop SavedFSR1 from s/w stack      
0001E0 CFE5 F???      00752   movff   POSTDEC1, SavedFSR1     
0001E4 CFE5 F???      00753   movff   POSTDEC1, SavedFSR0+1       ; pop SavedFSR0 from s/w stack      
0001E8 CFE7 F???      00754   movff   INDF1, SavedFSR0     
                      00755 
0001EC 0012           00756   return
                      00757 
                      00758 
                      00759 
                      00760 
                      00761 
                      00762 
                      00763 ;=====================================================================
                      00764 ; Core routines :
                      00765 ;=====================================================================
                      00766 
                      00767 
                      00768 ; Put Address into source pointer
                      00769 mSetSourcePointer macro Address
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 26


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00770         movlw   low (Address)
                      00771         movwf   pSrc
                      00772         movlw   high (Address)
                      00773         movwf   pSrc + 1
                      00774         endm
                      00775 
                      00776 ; Put Address into destination pointer
                      00777 mSetDestinationPointer macro Address
                      00778         movlw   low (Address)
                      00779         movwf   pDst
                      00780         movlw   high (Address)
                      00781         movwf   pDst + 1
                      00782         endm
                      00783 
                      00784 ; Get count from first location of ROM table pointed to by pSrc
                      00785 mGetRomTableCount macro
                      00786         movff   pSrc, TBLPTRL           ; Set source address
                      00787         movff   pSrc + 1, TBLPTRH
                      00788         clrf    TBLPTRU
                      00789         tblrd   *                       ; Read count
                      00790         movff   TABLAT, wCount
                      00791         clrf    wCount + 1
                      00792         endm
                      00793 
                      00794 
                      00795 ; From usb9.c  line 70
                      00796 ;/******************************************************************************
                      00797 ; * Function:        void USBCheckStdRequest(void)
                      00798 ; *
                      00799 ; * PreCondition:    None
                      00800 ; *
                      00801 ; * Input:           None
                      00802 ; *
                      00803 ; * Output:          None
                      00804 ; *
                      00805 ; * Side Effects:    None
                      00806 ; *
                      00807 ; * Overview:        This routine checks the setup data packet to see if it
                      00808 ; *                  knows how to handle it
                      00809 ; *
                      00810 ; * Note:            None
                      00811 ; *****************************************************************************/
0001EE                00812 USBCheckStdRequest
0001EE 0104           00813         movlb   high 0x400              ; Point to proper bank
0001F0 50??           00814         movf    SetupPkt, W             ; RequestType = STANDARD?
0001F2 0B60           00815         andlw   0x60                    ; Mask to proper bits
0001F4 0800           00816         sublw   (STANDARD) << 5
0001F6 E1??           00817         bnz     USBCheckStdRequestExit  ; No
0001F8 0E05           00818         movlw   SET_ADR                 ; Handle request
0001FA 62??           00819         cpfseq  SetupPkt + bRequest
0001FC D???           00820         bra     USBCheckStdRequest1
0001FE 0E04           00821         movlw   ADR_PENDING_STATE
000200 6E??           00822         movwf   usb_device_state
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 27


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000202 D???           00823         bra     USBStdSetSessionOwnerUSB9
                      00824 
                      00825 ; GET_DESCRIPTOR request?
000204                00826 USBCheckStdRequest1
000204 0E06           00827         movlw   GET_DSC
000206 62??           00828         cpfseq  SetupPkt + bRequest
000208 D???           00829         bra     USBCheckStdRequest2
00020A D???           00830         bra     USBStdGetDscHandler
                      00831 
                      00832 ; GET_CONFIGURATION request?
00020C                00833 USBCheckStdRequest2
00020C 0E08           00834         movlw   GET_CFG
00020E 62??           00835         cpfseq  SetupPkt + bRequest
000210 D???           00836         bra     USBCheckStdRequest3
                      00837         mSetSourcePointer usb_active_cfg
000212 0E??               M         movlw   low (usb_active_cfg)
000214 6E??               M         movwf   pSrc
000216 0E??               M         movlw   high (usb_active_cfg)
000218 6E??               M         movwf   pSrc + 1
00021A 0E01           00838         movlw   1
00021C 6E??           00839         movwf   wCount
00021E 6A??           00840         clrf    wCount + 1
000220 92??           00841         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
000222 D???           00842         bra     USBStdSetSessionOwnerUSB9
                      00843 
                      00844 ; SET_CONFIGURATION request?
000224                00845 USBCheckStdRequest3
000224 0E09           00846         movlw   SET_CFG
000226 62??           00847         cpfseq  SetupPkt + bRequest
000228 D???           00848         bra     USBCheckStdRequest4
00022A D???           00849         bra     USBStdSetCfgHandler
                      00850 
                      00851 ; GET_STATUS request?
00022C                00852 USBCheckStdRequest4
00022C 0E00           00853         movlw   GET_STATUS
00022E 62??           00854         cpfseq  SetupPkt + bRequest
000230 D???           00855         bra     USBCheckStdRequest5
000232 D???           00856         bra     USBStdGetStatusHandler
                      00857 
                      00858 ; CLEAR_FEATURE request?
000234                00859 USBCheckStdRequest5
000234 0E01           00860         movlw   CLR_FEATURE
000236 62??           00861         cpfseq  SetupPkt + bRequest
000238 D???           00862         bra     USBCheckStdRequest6
00023A D???           00863         bra     USBStdFeatureReqHandler
                      00864 
                      00865 ; SET_FEATURE request?
00023C                00866 USBCheckStdRequest6
00023C 0E03           00867         movlw   SET_FEATURE
00023E 62??           00868         cpfseq  SetupPkt + bRequest
000240 D???           00869         bra     USBCheckStdRequest7
000242 D???           00870         bra     USBStdFeatureReqHandler
                      00871 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 28


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00872 ; GET_INTERFACE request?
000244                00873 USBCheckStdRequest7
000244 0E0A           00874         movlw   GET_INTF
000246 62??           00875         cpfseq  SetupPkt + bRequest
000248 D???           00876         bra     USBCheckStdRequest8
                      00877         mSetSourcePointer usb_alt_intf
00024A 0E??               M         movlw   low (usb_alt_intf)
00024C 6E??               M         movwf   pSrc
00024E 0E??               M         movlw   high (usb_alt_intf)
000250 6E??               M         movwf   pSrc + 1
000252 50??           00878         movf    SetupPkt + bIntfID, W
000254 26??           00879         addwf   pSrc, F
000256 0E01           00880         movlw   1
000258 6E??           00881         movwf   wCount
00025A 6A??           00882         clrf    wCount + 1
00025C 92??           00883         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
00025E D???           00884         bra     USBStdSetSessionOwnerUSB9
                      00885 
                      00886 ; SET_INTERFACE request?
000260                00887 USBCheckStdRequest8
000260 0E0B           00888         movlw   SET_INTF
000262 62??           00889         cpfseq  SetupPkt + bRequest
000264 0012           00890         return
000266 EE?? F0??      00891         lfsr    2, usb_alt_intf
00026A 50??           00892         movf    SetupPkt + bIntfID, W
00026C C??? FFDB      00893         movff   SetupPkt + bAltID, PLUSW2
                      00894 ; Branch here after decoding one of the above USB standard requests.
                      00895 ; Assign a value to ctrl_trf_session_owner, to prevent stalling
000270                00896 USBStdSetSessionOwnerUSB9
000270 0E01           00897         movlw   MUID_USB9
000272 6E??           00898         movwf   ctrl_trf_session_owner
000274                00899 USBCheckStdRequestExit
000274 0012           00900         return
                      00901 
                      00902 ; From usb9.c  line 136
                      00903 ;/******************************************************************************
                      00904 ; * Function:        void USBStdGetDscHandler(void)
                      00905 ; *
                      00906 ; * PreCondition:    None
                      00907 ; *
                      00908 ; * Input:           None
                      00909 ; *
                      00910 ; * Output:          None
                      00911 ; *
                      00912 ; * Side Effects:    None
                      00913 ; *
                      00914 ; * Overview:        This routine handles the standard GET_DESCRIPTOR request.
                      00915 ; *                  It utilizes tables dynamically looks up descriptor size.
                      00916 ; *                  This routine should never have to be modified if the tables
                      00917 ; *                  in usbdsc.c are declared correctly.
                      00918 ; *
                      00919 ; * Note:            None
                      00920 ; *****************************************************************************/
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 29


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000276                00921 USBStdGetDscHandler
                      00922 ;       movlb   high 0x400              ; Point to proper bank
000276 0E80           00923         movlw   0x80
000278 62??           00924         cpfseq  SetupPkt + bmRequestType
00027A 0012           00925         return
00027C 0E01           00926         movlw   DSC_DEV
00027E 62??           00927         cpfseq  SetupPkt + bDscType
000280 D???           00928         bra     USBStdGetDscHandler1
                      00929         mSetSourcePointer DeviceDescriptor
000282 0E??               M         movlw   low (DeviceDescriptor)
000284 6E??               M         movwf   pSrc
000286 0E??               M         movlw   high (DeviceDescriptor)
000288 6E??               M         movwf   pSrc + 1
                      00930         mGetRomTableCount               ; Set wCount
00028A C??? FFF6          M         movff   pSrc, TBLPTRL           ; Set source address
00028E C??? FFF7          M         movff   pSrc + 1, TBLPTRH
000292 6AF8               M         clrf    TBLPTRU
000294 0008               M         tblrd   *                       ; Read count
000296 CFF5 F???          M         movff   TABLAT, wCount
00029A 6A??               M         clrf    wCount + 1
00029C 82??           00931         bsf     usb_stat, ctrl_trf_mem  ; Indicate ROM
00029E D???           00932         bra     USBStdSetSessionOwnerUSB9
0002A0                00933 USBStdGetDscHandler1
0002A0 0E02           00934         movlw   DSC_CFG
0002A2 62??           00935         cpfseq  SetupPkt + bDscType
0002A4 D???           00936         bra     USBStdGetDscHandler2
                      00937         
                      00938 #ifndef SUPPORT_MULTI_IDENTITY
                      00939         ; Normal case: only a single Configuration or "Identity"
                      00940         mSetSourcePointer Config1
0002A6 0E??               M         movlw   low (Config1)
0002A8 6E??               M         movwf   pSrc
0002AA 0E??               M         movlw   high (Config1)
0002AC 6E??               M         movwf   pSrc + 1
0002AE 0E??           00941         movlw   low Config1Len          ; Set wCount to total length
0002B0 6EF6           00942         movwf   TBLPTRL
0002B2 0E??           00943         movlw   high Config1Len
0002B4 6EF7           00944         movwf   TBLPTRH
                      00945 #else
                      00946     ; Used with Soft Detach devices: supports multiple "Identities"
                      00947     ; that are handled like "Configurations"
                      00948     movlw   2
                      00949     cpfseq  USB_Curr_Identity
                      00950     bra     USBStdGetDscHandler1_ID1
                      00951 ; Identity 2
                      00952         mSetSourcePointer Config2
                      00953         movlw   low Config2Len          ; Set wCount to total length
                      00954         movwf   TBLPTRL
                      00955         movlw   high Config2Len
                      00956         movwf   TBLPTRH
                      00957         bra     USBStdGetDscHandler1_X
                      00958 ; Identity 1
                      00959 USBStdGetDscHandler1_ID1:
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 30


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00960         mSetSourcePointer Config1
                      00961         movlw   low Config1Len          ; Set wCount to total length
                      00962         movwf   TBLPTRL
                      00963         movlw   high Config1Len
                      00964         movwf   TBLPTRH
                      00965 USBStdGetDscHandler1_X:    
                      00966 #endif
                      00967 
0002B6 6AF8           00968         clrf    TBLPTRU
0002B8 0009           00969         tblrd   *+                      ; Read count low
0002BA CFF5 F???      00970         movff   TABLAT, wCount
0002BE 0009           00971         tblrd   *+                      ; Ignore RETLW opcode
0002C0 0009           00972         tblrd   *+                      ; Read count high
0002C2 CFF5 F???      00973         movff   TABLAT, wCount + 1
0002C6 82??           00974         bsf     usb_stat, ctrl_trf_mem  ; Indicate ROM
0002C8 D???           00975         bra     USBStdSetSessionOwnerUSB9
0002CA                00976 USBStdGetDscHandler2
0002CA 0E03           00977         movlw   DSC_STR
0002CC 62??           00978         cpfseq  SetupPkt + bDscType
0002CE 0012           00979         return
0002D0 6AF8           00980         clrf    TBLPTRU
0002D2 6AF7           00981         clrf    TBLPTRH
0002D4 44??           00982         rlncf   SetupPkt + bDscIndex, W ; Index * 2
0002D6 0F??           00983         addlw   low (USB_SD_Ptr)        ; Add element offset to low address
0002D8 6EF6           00984         movwf   TBLPTRL
0002DA 0E??           00985         movlw   high (USB_SD_Ptr)
0002DC 22F7           00986         addwfc  TBLPTRH, F
0002DE 0009           00987   tblrd   *+                    ; Get the data to TABLAT and move pointer forward
0002E0 CFF5 F???      00988         movff   TABLAT, pSrc            ; Get low source address
0002E4 0008           00989   tblrd   *
0002E6 CFF5 F???      00990         movff   TABLAT, pSrc + 1        ; Get high source address
                      00991         mGetRomTableCount               ; Set wCount
0002EA C??? FFF6          M         movff   pSrc, TBLPTRL           ; Set source address
0002EE C??? FFF7          M         movff   pSrc + 1, TBLPTRH
0002F2 6AF8               M         clrf    TBLPTRU
0002F4 0008               M         tblrd   *                       ; Read count
0002F6 CFF5 F???          M         movff   TABLAT, wCount
0002FA 6A??               M         clrf    wCount + 1
0002FC 82??           00992         bsf     usb_stat, ctrl_trf_mem  ; Indicate ROM
0002FE D???           00993         bra     USBStdSetSessionOwnerUSB9
                      00994 
                      00995 
                      00996 ; From usb9.c  line 180
                      00997 ;/******************************************************************************
                      00998 ; * Function:        void USBStdSetCfgHandler(void)
                      00999 ; *
                      01000 ; * PreCondition:    None
                      01001 ; *
                      01002 ; * Input:           None
                      01003 ; *
                      01004 ; * Output:          None
                      01005 ; *
                      01006 ; * Side Effects:    None
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 31


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01007 ; *
                      01008 ; * Overview:        This routine first disables all endpoints by clearing
                      01009 ; *                  UEP registers. It then configures (initializes) endpoints
                      01010 ; *                  specified in the modifiable section.
                      01011 ; *
                      01012 ; * Note:            HIDmaker compatible version: table driven, automatically
                      01013 ; *                  initializes endpoints, regardless of USB class, from info
                      01014 ; *                  in tables contained in HIDmaker's generated version of file
                      01015 ; *                  usb18mem.asm
                      01016 ; *****************************************************************************/
000300                01017 USBStdSetCfgHandler
                      01018 ;       movlb   high 0x400              ; Point to proper bank
000300 0E01           01019         movlw   MUID_USB9
000302 6E??           01020         movwf   ctrl_trf_session_owner
000304 EE2F F071      01021         lfsr    2, UEP1                 ; Reset all non-EP0 UEPn registers
000308 0E0F           01022         movlw   15
00030A                01023 USBStdSetCfgHandlerClearEPLoop
00030A 6ADE           01024         clrf    POSTINC2
00030C 2EE8           01025         decfsz  WREG, F
00030E D???           01026         bra     USBStdSetCfgHandlerClearEPLoop
000310 EE?? F0??      01027         lfsr    2, usb_alt_intf         ; Clear usb_alt_intf array
000314 0E03           01028         movlw   MAX_NUM_INT
000316                01029 USBStdSetCfgHandlerClearAltLoop
000316 6ADE           01030         clrf    POSTINC2
000318 2EE8           01031         decfsz  WREG, F
00031A D???           01032         bra     USBStdSetCfgHandlerClearAltLoop
00031C 50??           01033         movf    SetupPkt + bCfgValue, W
                      01034 #ifdef SUPPORT_MULTI_IDENTITY
                      01035     ; If here, substitute _USB_Curr_Identity for requested Configuration:
                      01036     ; Windows has been told that this device only has one Configuration 
                      01037     ; anyway, so it is the Indentity number that we want:
                      01038     ; i.e., which identity do we want to be the new official Configuration 1?
                      01039         bz      USBStdSetCfgHandler_M
                      01040     movf    USB_Curr_Identity, W  ; Only make the switch if requested Config > 0
                      01041 USBStdSetCfgHandler_M:
                      01042 #endif
00031E 6E??           01043         movwf   usb_active_cfg
000320 6E??           01044         movwf   USB_Curr_Config
                      01045 
000322 E1??           01046         bnz     USBStdSetCfgHandler1
000324 0E05           01047         movlw   ADDRESS_STATE           ; SetupPkt + bCfgValue = 0
000326 6E??           01048         movwf   usb_device_state
                      01049 
                      01050 #ifdef USB_WATCH
                      01051 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01052 ; Add USBwatch activity reporting over hardware serial port
                      01053 ; (13a)  'L'
                      01054     bcf     USBWstate, USBW_CONFIGURED_BIT
                      01055     call   UsbwSendState
                      01056 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01057 #endif
                      01058 
000328 0012           01059         return
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 32


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00032A                01060 USBStdSetCfgHandler1
00032A 0E06           01061         movlw   CONFIGURED_STATE
00032C 6E??           01062         movwf   usb_device_state
                      01063 
                      01064 #ifdef USB_WATCH
                      01065 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01066 ; Add USBwatch activity reporting over hardware serial port
                      01067 ; (13c)  'L'
                      01068     bsf     USBWstate, USBW_CONFIGURED_BIT
                      01069     call   UsbwSendState
                      01070 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01071 #endif
                      01072 
                      01073 ;#ifdef USB_USE_CDC
                      01074 ;       rcall   CDCInitEP
                      01075 ;#endif
                      01076 ; Initialize In endpoints
00032E 0E01           01077         movlw   1                       ; Start with endpoint 1
000330 6E??           01078         movwf   usb_temp                ; Save it
                      01079 ; See which Configuration we have to initialize: some projects may have 2 Configurations
000332 0E02           01080         movlw   2                       ; Config no. 2?
000334 62??           01081         cpfseq  usb_active_cfg
000336 D???           01082         bra     InitC1_InEps              ; No
                      01083 ; Set up for Config 2
000338 0E??           01084         movlw   low C2_InEpTable        ; Point to In endpoint table in USB18MEM.ASM
00033A 6EF6           01085         movwf   TBLPTRL
00033C 0E??           01086         movlw   high C2_InEpTable
00033E D???           01087         bra     Init_InEps
000340                01088 InitC1_InEps
000340 0E??           01089         movlw   low C1_InEpTable        ; Point to In endpoint table in USB18MEM.ASM
000342 6EF6           01090         movwf   TBLPTRL
000344 0E??           01091         movlw   high C1_InEpTable
000346                01092 Init_InEps
000346 6EF7           01093         movwf   TBLPTRH
000348 6AF8           01094         clrf    TBLPTRU
00034A 0009           01095         tblrd   *+                      ; Read number of endpoints
00034C CFF5 F???      01096         movff   TABLAT, usb_temp + 1    ; Save it somewhere
                      01097 ; Is the number of endpoints 0?
000350 52??           01098     movf    (usb_temp + 1), F
000352 E0??           01099     bz     USBStdSetCfgHandlerInitOuts  ; No Input endpoints
000354 0009           01100         tblrd   *+                      ; Skip next location
000356                01101 USBStdSetCfgHandlerInLoop
000356 C??? FFE9      01102         movff   usb_temp, FSR0L         ; Save endpoint number in FSR0L
00035A 2A??           01103         incf    usb_temp, F             ; Bump up endpoint number
00035C 0009           01104         tblrd   *+                      ; Read endpoint buffer address low
00035E CFF5 FFE1      01105         movff   TABLAT, FSR1L           ; Save it in FSR1
000362 0009           01106         tblrd   *+                      ; Skip next location
000364 0009           01107         tblrd   *+                      ; Read endpoint buffer address high
000366 CFF5 FFE2      01108         movff   TABLAT, FSR1H
00036A 0009           01109         tblrd   *+                      ; Skip next location
00036C 0009           01110         tblrd   *+                      ; Read endpoint size
00036E 50F5           01111         movf    TABLAT, W               ; Move it to W
000370 0009           01112         tblrd   *+                      ; Skip next location
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 33


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000372 A4D8           01113         btfss   STATUS, Z               ; If endpoint size is 0, don't initialize
000374 D???           01114         rcall   InitEPIn                ; Initialize the endpoint
000376 2E??           01115         decfsz  usb_temp + 1            ; Do next In endpoint, if any
000378 D???           01116         bra     USBStdSetCfgHandlerInLoop
00037A                01117 USBStdSetCfgHandlerInitOuts:
                      01118 ; Initialize Out endpoints
00037A 0E01           01119         movlw   1                       ; Start with endpoint 1
00037C 6E??           01120         movwf   usb_temp                ; Save it
                      01121 ; See which Configuration we have to initialize: some projects may have 2 Configurations
00037E 0E02           01122         movlw   2                       ; Config no. 2?
000380 62??           01123         cpfseq  usb_active_cfg
000382 D???           01124         bra     InitC1_OutEps              ; No
                      01125 ; Set up for Config 2
000384 0E??           01126         movlw   low C2_OutEpTable       ; Point to In endpoint table in USB18MEM.ASM
000386 6EF6           01127         movwf   TBLPTRL
000388 0E??           01128         movlw   high C2_OutEpTable
00038A D???           01129         bra     Init_OutEps
00038C                01130 InitC1_OutEps
00038C 0E??           01131         movlw   low C1_OutEpTable       ; Point to Out endpoint table in USB18MEM.ASM
00038E 6EF6           01132         movwf   TBLPTRL
000390 0E??           01133         movlw   high C1_OutEpTable
000392                01134 Init_OutEps
000392 6EF7           01135         movwf   TBLPTRH
000394 6AF8           01136         clrf    TBLPTRU
000396 0009           01137         tblrd   *+                      ; Read number of endpoints
000398 CFF5 F???      01138         movff   TABLAT, usb_temp + 1    ; Save it somewhere
                      01139 ; Is the number of endpoints 0?
00039C 52??           01140     movf    (usb_temp + 1), F
00039E E0??           01141     bz      USBStdSetCfgHandlerExit  ; No Output endpoints
0003A0 0009           01142         tblrd   *+                      ; Skip next location
0003A2                01143 USBStdSetCfgHandlerOutLoop
0003A2 C??? FFE9      01144         movff   usb_temp, FSR0L         ; Save endpoint number in FSR0L
0003A6 2A??           01145         incf    usb_temp, F             ; Bump up endpoint number
0003A8 0009           01146         tblrd   *+                      ; Read endpoint buffer address low
0003AA CFF5 FFE1      01147         movff   TABLAT, FSR1L           ; Save it in FSR1
0003AE 0009           01148         tblrd   *+                      ; Skip next location
0003B0 0009           01149         tblrd   *+                      ; Read endpoint buffer address high
0003B2 CFF5 FFE2      01150         movff   TABLAT, FSR1H
0003B6 0009           01151         tblrd   *+                      ; Skip next location
0003B8 0009           01152         tblrd   *+                      ; Read endpoint size
0003BA 50F5           01153         movf    TABLAT, W               ; Move it to W
0003BC 0009           01154         tblrd   *+                      ; Skip next location
0003BE A4D8           01155         btfss   STATUS, Z               ; If endpoint size is 0, don't initialize
0003C0 D???           01156         rcall   InitEPOut               ; Initialize the endpoint
0003C2 2E??           01157         decfsz  usb_temp + 1            ; Do next In endpoint, if any
0003C4 D???           01158         bra     USBStdSetCfgHandlerOutLoop
0003C6                01159 USBStdSetCfgHandlerExit:
0003C6 0012           01160         return
                      01161 
                      01162 
                      01163 ; From usb9.c  line 224
                      01164 ;/******************************************************************************
                      01165 ; * Function:        void USBStdGetStatusHandler(void)
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 34


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01166 ; *
                      01167 ; * PreCondition:    None
                      01168 ; *
                      01169 ; * Input:           None
                      01170 ; *
                      01171 ; * Output:          None
                      01172 ; *
                      01173 ; * Side Effects:    None
                      01174 ; *
                      01175 ; * Overview:        This routine handles the standard GET_STATUS request
                      01176 ; *
                      01177 ; * Note:            None
                      01178 ; *****************************************************************************/
0003C8                01179 USBStdGetStatusHandler
                      01180 ;       movlb   high 0x400              ; Point to proper bank
0003C8 6A??           01181         clrf    CtrlTrfData             ; Initialize content
0003CA 6A??           01182         clrf    CtrlTrfData + 1
0003CC 50??           01183         movf    SetupPkt, W             ; Recipient = RCPT_DEV?
0003CE 0B1F           01184         andlw   0x1f                    ; Mask to lower 5 bits
0003D0 0800           01185         sublw   RCPT_DEV
0003D2 E1??           01186         bnz     USBStdGetStatusHandler1 ; No
                      01187 ;
                      01188 ; Recipient of this Setup packet was "Device": set bits to indicate power & remote wakeup
                      01189 ; Decoding of "Self-powered" & "Remote Wakeup"
                      01190 ; _byte0: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
                      01191 ;         bit1: RemoteWakeup        [0] Disabled    [1] Enabled
                      01192 ;
                      01193 #ifdef USB_SELF_POWER
                      01194         bsf     CtrlTrfData, 0
                      01195 #endif
0003D4 B0??           01196         btfsc   usb_stat, RemoteWakeup
0003D6 82??           01197         bsf     CtrlTrfData, 1
0003D8 D???           01198         bra     USBStdGetStatusSetSessionOwner
                      01199 ;
0003DA                01200 USBStdGetStatusHandler1
0003DA 50??           01201         movf    SetupPkt, W             ; Recipient = RCPT_INTF?
0003DC 0B1F           01202         andlw   0x1f                    ; Mask to lower 5 bits
0003DE 0801           01203         sublw   RCPT_INTF
0003E0 E1??           01204         bnz     USBStdGetStatusHandler2 ; No
                      01205 ;
                      01206 ; Recipient of this Setup packet was "Interface": No data to update
0003E2 D???           01207         bra     USBStdGetStatusSetSessionOwner
                      01208 ;
0003E4                01209 USBStdGetStatusHandler2
0003E4 50??           01210         movf    SetupPkt, W             ; Recipient = RCPT_EP?
0003E6 0B1F           01211         andlw   0x1f                    ; Mask to lower 5 bits
0003E8 0802           01212         sublw   RCPT_EP
0003EA E1??           01213         bnz     USBStdGetStatusHandler3 ; No
                      01214 ;
                      01215 ; Recipient of this Setup packet was "Endpoint"
0003EC D???           01216         rcall   USBCalcEPAddress        ; Put endpoint buffer address in FSR2
0003EE 50DF           01217         movf    INDF2, W
0003F0 0B04           01218         andlw   _BSTALL
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 35


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0003F2 E0??           01219         bz      USBStdGetStatusSetSessionOwner
0003F4 80??           01220         bsf     CtrlTrfData, 0
0003F6                01221 USBStdGetStatusSetSessionOwner
0003F6 0E01           01222         movlw   MUID_USB9
0003F8 6E??           01223         movwf   ctrl_trf_session_owner
0003FA                01224 USBStdGetStatusHandler3
0003FA 0E01           01225         movlw   MUID_USB9
0003FC 62??           01226         cpfseq  ctrl_trf_session_owner
0003FE 0012           01227         return
                      01228         mSetSourcePointer CtrlTrfData
000400 0E??               M         movlw   low (CtrlTrfData)
000402 6E??               M         movwf   pSrc
000404 0E??               M         movlw   high (CtrlTrfData)
000406 6E??               M         movwf   pSrc + 1
000408 0E02           01229         movlw   2                       ; Set count
00040A 6E??           01230         movwf   wCount
00040C 6A??           01231         clrf    wCount + 1
00040E 92??           01232         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
000410 0012           01233         return
                      01234 
                      01235 ; From usb9.c  line 281
                      01236 ;/******************************************************************************
                      01237 ; * Function:        void USBStdFeatureReqHandler(void)
                      01238 ; *
                      01239 ; * PreCondition:    None
                      01240 ; *
                      01241 ; * Input:           None
                      01242 ; *
                      01243 ; * Output:          None
                      01244 ; *
                      01245 ; * Side Effects:    None
                      01246 ; *
                      01247 ; * Overview:        This routine handles the standard SET & CLEAR FEATURES
                      01248 ; *                  requests
                      01249 ; *
                      01250 ; * Note:            None
                      01251 ; *****************************************************************************/
000412                01252 USBStdFeatureReqHandler
                      01253 ;       movlb   high 0x400              ; Point to proper bank
000412 0E01           01254         movlw   DEVICE_REMOTE_WAKEUP    ; If Feature = DEVICE_REMOTE_WAKEUP &
000414 62??           01255         cpfseq  SetupPkt + bFeature
000416 D???           01256         bra     USBStdFeatureReqHandler1
000418 50??           01257         movf    SetupPkt, W     ; Recipient = RCPT_DEV?
00041A 0B1F           01258         andlw   0x1f                    ; Mask to lower 5 bits
00041C 0800           01259         sublw   RCPT_DEV
00041E E1??           01260         bnz     USBStdFeatureReqHandler1        ; No
000420 80??           01261         bsf     usb_stat, RemoteWakeup  ; Preset RemoteWakeup to 1
000422 0E03           01262         movlw   SET_FEATURE             ; Request = SET_FEATURE?
000424 62??           01263         cpfseq  SetupPkt + bRequest
000426 90??           01264         bcf     usb_stat, RemoteWakeup  ; No, RemoteWakeup = 0
000428 D???           01265         bra     USBStdSetSessionOwnerUSB9
00042A                01266 USBStdFeatureReqHandler1
00042A 0E00           01267         movlw   ENDPOINT_HALT           ; If Feature = ENDPOINT_HALT &
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 36


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00042C 62??           01268         cpfseq  SetupPkt + bFeature
00042E                01269 USBStdFeatureReqHandlerExit
00042E 0012           01270         return
000430 50??           01271         movf    SetupPkt, W     ; Recepient = RCPT_EP &
000432 0B1F           01272         andlw   0x1f                    ; Mask to lower 5 bits
000434 0802           01273         sublw   RCPT_EP
000436 E1??           01274         bnz     USBStdFeatureReqHandlerExit
000438 50??           01275         movf    SetupPkt + bEPID, W     ; EPNum != 0
00043A 0B0F           01276         andlw   0x0f                    ; Mask to EPNum
00043C E0??           01277         bz      USBStdFeatureReqHandlerExit
00043E D???           01278         rcall   USBCalcEPAddress        ; Put endpoint buffer address in FSR2
000440 0E03           01279         movlw   SET_FEATURE             ; Request = SET_FEATURE?
000442 62??           01280         cpfseq  SetupPkt + bRequest
000444 D???           01281         bra     USBStdFeatureReqHandler2        ; No
000446 0E84           01282         movlw   _USIE|_BSTALL
000448 6EDF           01283         movwf   INDF2                   ; Put in endpoint buffer
00044A D???           01284         bra     USBStdSetSessionOwnerUSB9
00044C                01285 USBStdFeatureReqHandler2
00044C 0E00           01286         movlw   _UCPU                   ; IN
00044E AE??           01287         btfss   SetupPkt + bEPID, EPDir ; EPDir = 1 (IN)?
000450 0E88           01288         movlw   _USIE|_DAT0|_DTSEN      ; No - OUT
000452 6EDF           01289         movwf   INDF2                   ; Put in endpoint buffer
000454 D???           01290         bra     USBStdSetSessionOwnerUSB9
                      01291 
                      01292 
                      01293 ; Put endpoint buffer address in FSR2 (ep0Bo+(EPNum*8)+(EPDir*4))
000456                01294 USBCalcEPAddress
000456 EE?? F0??      01295         lfsr    2, ep0Bo                ; Point FSR2 to beginning of buffer area
00045A 44??           01296         rlncf   SetupPkt + bEPID, W     ; Move endpoint direction to C
00045C 34??           01297         rlcf    SetupPkt + bEPID, W     ; Endpoint number * 8 (roll in ep direction)
00045E 46E8           01298         rlncf   WREG, F
000460 46E8           01299         rlncf   WREG, F
000462 26D9           01300         addwf   FSR2L, F                ; Add to FSR2 (can't overflow to FSR2H)
000464 0012           01301         return
                      01302 
                      01303 
                      01304 
                      01305 ; From usbctrltrf.c line 78
                      01306 ;/******************************************************************************
                      01307 ; * Function:        void USBCtrlEPService(void)
                      01308 ; *
                      01309 ; * PreCondition:    USTAT is loaded with a valid endpoint address.
                      01310 ; *
                      01311 ; * Input:           None
                      01312 ; *
                      01313 ; * Output:          None
                      01314 ; *
                      01315 ; * Side Effects:    None
                      01316 ; *
                      01317 ; * Overview:        USBCtrlEPService checks for three transaction types that
                      01318 ; *                  it knows how to service and services them:
                      01319 ; *                  1. EP0 SETUP
                      01320 ; *                  2. EP0 OUT
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 37


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01321 ; *                  3. EP0 IN
                      01322 ; *                  It ignores all other types (i.e. EP1, EP2, etc.)
                      01323 ; *
                      01324 ; * Note:            None
                      01325 ; *****************************************************************************/
000466                01326 USBCtrlEPService
                      01327 ;       movlb   high 0x400              ; Point to proper bank
000466 0E00           01328         movlw   EP00_OUT
000468 626C           01329         cpfseq  USTAT
00046A D???           01330         bra     USBCtrlEPService1
00046C 50??           01331         movf    ep0Bo + Stat, W
00046E 0B3C           01332         andlw   0x3c                    ; Mask to PID
000470 0834           01333         sublw   (SETUP_TOKEN) << 2
000472 E0??           01334         bz      USBCtrlTrfSetupHandler
000474 D???           01335         bra     USBCtrlTrfOutHandler
000476                01336 USBCtrlEPService1
000476 0E04           01337         movlw   EP00_IN
000478 626C           01338         cpfseq  USTAT
00047A 0012           01339         return
00047C D???           01340         bra     USBCtrlTrfInHandler
                      01341 
                      01342 
                      01343 ; From usbctrltrf.c line 133
                      01344 ;/******************************************************************************
                      01345 ; * Function:        void USBCtrlTrfSetupHandler(void)
                      01346 ; *
                      01347 ; * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
                      01348 ; *
                      01349 ; * Input:           None
                      01350 ; *
                      01351 ; * Output:          None
                      01352 ; *
                      01353 ; * Side Effects:    None
                      01354 ; *
                      01355 ; * Overview:        This routine is a task dispatcher and has 3 stages.
                      01356 ; *                  1. It initializes the control transfer state machine.
                      01357 ; *                  2. It calls on each of the module that may know how to
                      01358 ; *                     service the Setup Request from the host.
                      01359 ; *                     Module Example: USB9, HID, CDC, MSD, ...
                      01360 ; *                     As new classes are added, ClassReqHandler table in
                      01361 ; *                     usbdsc.c should be updated to call all available
                      01362 ; *                     class handlers.
                      01363 ; *                  3. Once each of the modules has had a chance to check if
                      01364 ; *                     it is responsible for servicing the request, stage 3
                      01365 ; *                     then checks direction of the transfer to determine how
                      01366 ; *                     to prepare EP0 for the control transfer.
                      01367 ; *                     Refer to USBCtrlEPServiceComplete() for more details.
                      01368 ; *
                      01369 ; * Note:            Microchip USB Firmware has three different states for
                      01370 ; *                  the control transfer state machine:
                      01371 ; *                  1. WAIT_SETUP
                      01372 ; *                  2. CTRL_TRF_TX
                      01373 ; *                  3. CTRL_TRF_RX
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 38


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01374 ; *                  Refer to firmware manual to find out how one state
                      01375 ; *                  is transitioned to another.
                      01376 ; *
                      01377 ; *                  A Control Transfer is composed of many USB transactions.
                      01378 ; *                  When transferring data over multiple transactions,
                      01379 ; *                  it is important to keep track of data source, data
                      01380 ; *                  destination, and data count. These three parameters are
                      01381 ; *                  stored in pSrc,pDst, and wCount. A flag is used to
                      01382 ; *                  note if the data source is from ROM or RAM.
                      01383 ; *
                      01384 ; *****************************************************************************/
00047E                01385 USBCtrlTrfSetupHandler
                      01386 ;       movlb   high 0x400              ; Point to proper bank
00047E 0E00           01387         movlw   WAIT_SETUP
000480 6E??           01388         movwf   ctrl_trf_state
                      01389 #ifdef  HID_SUPPORT_GET_SET_REPORT
                      01390   clrf  SetRptInProgress
                      01391   clrf  GetRptInProgress
                      01392 #endif
000482 0E00           01393         movlw   MUID_NULL               ; Set owner to NULL
000484 6E??           01394         movwf   ctrl_trf_session_owner
000486 6A??           01395         clrf    wCount
000488 6A??           01396         clrf    wCount + 1
                      01397 
                      01398 #ifdef USB_WATCH
                      01399 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01400 ; Add USBwatch activity reporting over hardware serial port
                      01401 ; (11) 'R'
                      01402 ; Report USB Request parameter data, now in SetupPkt
                      01403 
                      01404 ; Test if USBwatch reporting is ON
                      01405     movf     USBW_On, W
                      01406     bz       ExitUSBW_11         ; Abort
                      01407 UsbwSendSetupPkt
                      01408     movlw   'R'             ; Signal to USBwatch that we got a SETUP token
                      01409     call    UsbwSendChar
                      01410     lfsr     0, SetupPkt
                      01411     movlw    8
                      01412     movwf    USBWtemp
                      01413     call    UsbwSendBuf_NBC
                      01414 ExitUSBW_11
                      01415 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01416  endif
                      01417 
00048A D???           01418         rcall   USBCheckStdRequest
00048C 0E00           01419         movlw   MUID_NULL
00048E 62??           01420         cpfseq  ctrl_trf_session_owner
000490 D???           01421         bra     USBCtrlEPServiceComplete
                      01422 #ifdef USB_USE_HID
000492 D???           01423         rcall   USBCheckHIDRequest
                      01424 #endif ; USB_USE_HID
                      01425 #ifdef USB_USE_CDC
                      01426         rcall   USBCheckCDCRequest
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 39


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01427 #endif ; USB_USE_CDC
000494 D???           01428         bra     USBCtrlEPServiceComplete
                      01429 
                      01430 
                      01431 ; From usbctrltrf.c line 176
                      01432 ;/******************************************************************************
                      01433 ; * Function:        void USBCtrlTrfOutHandler(void)
                      01434 ; *
                      01435 ; * PreCondition:    None
                      01436 ; *
                      01437 ; * Input:           None
                      01438 ; *
                      01439 ; * Output:          None
                      01440 ; *
                      01441 ; * Side Effects:    None
                      01442 ; *
                      01443 ; * Overview:        This routine handles an OUT transaction according to
                      01444 ; *                  which control transfer state is currently active.
                      01445 ; *
                      01446 ; * Note:            Note that if the the control transfer was from
                      01447 ; *                  host to device, the session owner should be notified
                      01448 ; *                  at the end of each OUT transaction to service the
                      01449 ; *                  received data.
                      01450 ; *
                      01451 ; *****************************************************************************/
000496                01452 USBCtrlTrfOutHandler
                      01453 ;       movlb   high 0x400              ; Point to proper bank
000496 0E02           01454         movlw   CTRL_TRF_RX
000498 62??           01455         cpfseq  ctrl_trf_state
00049A D???           01456         bra     USBPrepareForNextSetupTrf
00049C D???           01457         rcall   USBCtrlTrfRxService
00049E 0EC8           01458         movlw   _USIE|_DAT1|_DTSEN
0004A0 BC??           01459         btfsc   ep0Bo + Stat, DTS
0004A2 0E88           01460         movlw   _USIE|_DAT0|_DTSEN
0004A4 6E??           01461         movwf   ep0Bo + Stat
0004A6 0012           01462         return
                      01463 
                      01464 
                      01465 ; From usbctrltrf.c line 221
                      01466 ;/******************************************************************************
                      01467 ; * Function:        void USBCtrlTrfInHandler(void)
                      01468 ; *
                      01469 ; * PreCondition:    None
                      01470 ; *
                      01471 ; * Input:           None
                      01472 ; *
                      01473 ; * Output:          None
                      01474 ; *
                      01475 ; * Side Effects:    None
                      01476 ; *
                      01477 ; * Overview:        This routine handles an IN transaction according to
                      01478 ; *                  which control transfer state is currently active.
                      01479 ; *
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 40


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01480 ; *
                      01481 ; * Note:            A Set Address Request must not change the acutal address
                      01482 ; *                  of the device until the completion of the control
                      01483 ; *                  transfer. The end of the control transfer for Set Address
                      01484 ; *                  Request is an IN transaction. Therefore it is necessary
                      01485 ; *                  to service this unique situation when the condition is
                      01486 ; *                  right. Macro mUSBCheckAdrPendingState is defined in
                      01487 ; *                  usb9.h and its function is to specifically service this
                      01488 ; *                  event.
                      01489 ; *****************************************************************************/
0004A8                01490 USBCtrlTrfInHandler
                      01491 ;       movlb   high 0x400              ; Point to proper bank
0004A8 0E04           01492         movlw   ADR_PENDING_STATE       ; Must check if in ADR_PENDING_STATE
0004AA 62??           01493         cpfseq  usb_device_state
0004AC D???           01494         bra     USBCtrlTrfInHandler1
0004AE 50??           01495         movf    SetupPkt + bDevADR, W
0004B0 6E6E           01496         movwf   UADDR
0004B2 0E05           01497         movlw   ADDRESS_STATE           ; If UADDR > 0
0004B4 B4D8           01498         btfsc   STATUS, Z
0004B6 0E03           01499         movlw   DEFAULT_STATE
0004B8 6E??           01500         movwf   usb_device_state
                      01501 
                      01502 #ifdef USB_WATCH
                      01503 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01504 ; Add USBwatch activity reporting over hardware serial port
                      01505 ; (12)  'L'
                      01506         movf    UADDR, W
                      01507   bsf     USBWstate, USBW_ADDRESSED_BIT         ; If UADDR > 0
                      01508         btfsc     STATUS, Z
                      01509   bcf     USBWstate, USBW_ADDRESSED_BIT         ; If UADDR > 0
                      01510   call   UsbwSendState
                      01511 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01512 #endif
                      01513 
0004BA                01514 USBCtrlTrfInHandler1
0004BA 0E01           01515         movlw   CTRL_TRF_TX
0004BC 62??           01516         cpfseq  ctrl_trf_state
0004BE D???           01517         bra     USBPrepareForNextSetupTrf
0004C0 D???           01518         rcall   USBCtrlTrfTxService
0004C2 0EC8           01519         movlw   _USIE|_DAT1|_DTSEN
0004C4 BC??           01520         btfsc   ep0Bi + Stat, DTS
0004C6 0E88           01521         movlw   _USIE|_DAT0|_DTSEN
0004C8 6E??           01522         movwf   ep0Bi + Stat
0004CA 0012           01523         return
                      01524 
                      01525 
                      01526 ; From usbctrltrf.c line 260
                      01527 ;/******************************************************************************
                      01528 ; * Function:        void USBCtrlTrfTxService(void)
                      01529 ; *
                      01530 ; * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
                      01531 ; *
                      01532 ; * Input:           None
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 41


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01533 ; *
                      01534 ; * Output:          None
                      01535 ; *
                      01536 ; * Side Effects:    None
                      01537 ; *
                      01538 ; * Overview:        This routine should be called from only two places.
                      01539 ; *                  One from USBCtrlEPServiceComplete() and one from
                      01540 ; *                  USBCtrlTrfInHandler(). It takes care of managing a
                      01541 ; *                  transfer over multiple USB transactions.
                      01542 ; *
                      01543 ; * Note:            Copies one packet-ful of data pSrc (either ROM or RAM) to
                      01544 ; *                  EP0 IN buffer. It then updates pSrc to be ready for next
                      01545 ; *                  piece.
                      01546 ; *                  This routine works with isochronous endpoint larger than
                      01547 ; *                  256 bytes and is shown here as an example of how to deal
                      01548 ; *                  with BC9 and BC8. In reality, a control endpoint can never
                      01549 ; *                  be larger than 64 bytes.
                      01550 ; *****************************************************************************/
0004CC                01551 USBCtrlTrfTxService
                      01552 ;       movlb   high 0x400              ; Point to proper bank
                      01553 
                      01554 #ifdef  HID_SUPPORT_GET_SET_REPORT
                      01555 ; Added for HIDmaker: Handle each IN packet of a GetReport request
                      01556   movf GetRptInProgress, W
                      01557   bz    NoGetRpt
                      01558   movlb 0             ; The Basic code needs bank 0
                      01559   call  FeatureIn    ; Pack data and load into EP0 buffer
                      01560   movlb high 0x400              ; Point to proper bank
                      01561 ;
                      01562 ; Because FeatureIn calls PackandShipPacket which toggles DTS, and the caller 
                      01563 ; of this routine, USBCtrlTrfInHandler, also toggles DTS, these would cancel.  
                      01564 ; We need to toggle DTS one more time here, to make things come out right.
                      01565         movlw   _USIE|_DAT1|_DTSEN
                      01566         btfsc   ep0Bi + Stat, DTS
                      01567         movlw   _USIE|_DAT0|_DTSEN
                      01568         movwf   ep0Bi + Stat
                      01569 ;  
                      01570   movf GetRptInProgress, W
                      01571   bnz    USBCtrlTrfTxServiceFinishUp  ; If GET_REPORT is still in progress, wait for next IN packet requ
                            est
                      01572 ; Need to clear ctrl_trf_state here: GET_REPORT operation is done
                      01573         movlw   WAIT_SETUP
                      01574         movwf   ctrl_trf_state
                      01575   bra   USBCtrlTrfTxServiceFinishUp
                      01576 NoGetRpt
                      01577 #endif
                      01578 
0004CC 50??           01579         movf    wCount, W               ; Preset wCount bytes to send
0004CE 6E??           01580         movwf   usb_temp
0004D0 50??           01581         movf    wCount + 1, W
0004D2 6E??           01582         movwf   usb_temp + 1
0004D4 0800           01583         sublw   high EP0_BUFF_SIZE      ; Make sure count does not exceed maximium length
0004D6 E3??           01584         bnc     USBCtrlTrfTxServiceCopy
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 42


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0004D8 E1??           01585         bnz     USBCtrlTrfTxServiceSub
0004DA 50??           01586         movf    wCount, W
0004DC 0808           01587         sublw   low EP0_BUFF_SIZE
0004DE E2??           01588         bc      USBCtrlTrfTxServiceSub
0004E0                01589 USBCtrlTrfTxServiceCopy
0004E0 0E08           01590         movlw   low EP0_BUFF_SIZE       ; Send buffer full of bytes
0004E2 6E??           01591         movwf   usb_temp
0004E4 0E00           01592         movlw   high EP0_BUFF_SIZE
0004E6 6E??           01593         movwf   usb_temp + 1
0004E8                01594 USBCtrlTrfTxServiceSub
0004E8 50??           01595         movf    usb_temp, W             ; Subtract actual bytes to be sent from the buffer
0004EA 6E??           01596         movwf   ep0Bi + Cnt             ; Save low number of bytes to send while we're here
0004EC 5E??           01597         subwf   wCount, F
0004EE 50??           01598         movf    usb_temp + 1, W
0004F0 5A??           01599         subwfb  wCount + 1, F
0004F2 50??           01600         movf    ep0Bi + Stat, W         ; Get full Stat byte
0004F4 0BFC           01601         andlw   0xfc                    ; Clear bottom bits
0004F6 10??           01602         iorwf   usb_temp + 1, W         ; Put in high bits of bytes to send
0004F8 6E??           01603         movwf   ep0Bi + Stat            ; Save it out
0004FA EE?? F0??      01604         lfsr    2, CtrlTrfData          ; Set destination pointer
0004FE 50??           01605         movf    usb_temp + 1, W         ; Check high byte for 0
000500 E1??           01606         bnz     USBCtrlTrfTxServiceRomRam       ; High byte not 0, must have something to do
000502 50??           01607         movf    usb_temp, W             ; Check low byte for 0
000504 E0??           01608         bz      USBCtrlTrfTxServiceExit ; If both 0 then nothing to send this time
000506                01609 USBCtrlTrfTxServiceRomRam
000506 A2??           01610         btfss   usb_stat, ctrl_trf_mem  ; ROM or RAM?
000508 D???           01611         bra     USBCtrlTrfTxServiceRam  ; RAM
00050A C??? FFF6      01612         movff   pSrc, TBLPTRL           ; Move source pointer to TBLPTR
00050E C??? FFF7      01613         movff   pSrc + 1, TBLPTRH
000512 6AF8           01614         clrf    TBLPTRU
000514                01615 USBCtrlTrfTxServiceRomLoop
000514 0009           01616         tblrd   *+
000516 CFF5 FFDE      01617         movff   TABLAT, POSTINC2        ; Copy one buffer to the other
00051A 0009           01618         tblrd   *+                      ; Skip high location
00051C 06??           01619         decf    usb_temp, F             ; Count down number of bytes
00051E E1??           01620         bnz     USBCtrlTrfTxServiceRomLoop
000520 06??           01621         decf    usb_temp + 1, F
000522 E2??           01622         bc      USBCtrlTrfTxServiceRomLoop
000524 CFF6 F???      01623         movff   TBLPTRL, pSrc           ; Update source pointer
000528 CFF7 F???      01624         movff   TBLPTRH, pSrc + 1
00052C D???           01625   bra   USBCtrlTrfTxServiceFinishUp
00052E                01626 USBCtrlTrfTxServiceRam
00052E C??? FFE1      01627         movff   pSrc, FSR1L             ; Move source pointer to FSR1
000532 C??? FFE2      01628         movff   pSrc + 1, FSR1H
000536                01629 USBCtrlTrfTxServiceRamLoop
000536 CFE6 FFDE      01630         movff   POSTINC1, POSTINC2      ; Copy one buffer to the other
00053A 06??           01631         decf    usb_temp, F             ; Count down number of bytes
00053C E1??           01632         bnz     USBCtrlTrfTxServiceRamLoop
00053E 06??           01633         decf    usb_temp + 1, F
000540 E2??           01634         bc      USBCtrlTrfTxServiceRamLoop
000542 CFE1 F???      01635         movff   FSR1L, pSrc             ; Update source pointer
000546 CFE2 F???      01636         movff   FSR1H, pSrc + 1
00054A                01637 USBCtrlTrfTxServiceFinishUp
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 43


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01638 
                      01639 
00054A                01640 USBCtrlTrfTxServiceExit
00054A 0012           01641         return
                      01642 
                      01643 
                      01644 ; From usbctrltrf.c line 330
                      01645 ;/******************************************************************************
                      01646 ; * Function:        void USBCtrlTrfRxService(void)
                      01647 ; *
                      01648 ; * PreCondition:    pDst and wCount are setup properly.
                      01649 ; *                  pSrc is always &CtrlTrfData
                      01650 ; *                  usb_stat.ctrl_trf_mem is always _RAM.
                      01651 ; *                  wCount should be set to 0 at the start of each control
                      01652 ; *                  transfer.
                      01653 ; *
                      01654 ; * Input:           None
                      01655 ; *
                      01656 ; * Output:          None
                      01657 ; *
                      01658 ; * Side Effects:    None
                      01659 ; *
                      01660 ; * Overview:        Transfers bytes received, at EP0 OUT buffer CtrlTrfData,
                      01661 ; *                  to user's buffer pointed by pDst.
                      01662 ; *                  This routine only knows how to handle raw byte data.
                      01663 ; *                  HIDmaker handles transferring and unpacking by a callback
                      01664 ; *                  function in the generated main program, called from here.
                      01665 ; *
                      01666 ; *
                      01667 ; * Note:            None
                      01668 ; *****************************************************************************/
00054C                01669 USBCtrlTrfRxService
                      01670 ;       movlb   high 0x400              ; Point to proper bank
                      01671 #ifdef  HID_SUPPORT_GET_SET_REPORT
                      01672 ; Added for HIDmaker: Handle each OUT packet of a SET_REPORT request
                      01673   movf  SetRptInProgress, W
                      01674   bz    NoSetRpt
                      01675 TryFeatureOut:
                      01676   movlw   HID_FEATURE_REPORT
                      01677   cpfseq  SetupPkt + bReportType
                      01678   bra     TryCtlOutRpt
                      01679   movlb 0              ; The Basic code needs bank 0
                      01680   call  RcvFeatureRpt    ; Transfer Feature Report data from EP0 buffer & unpack it
                      01681   bra   SetRptCommon
                      01682 TryCtlOutRpt
                      01683   movlw   HID_OUTPUT_REPORT
                      01684   cpfseq  SetupPkt + bReportType
                      01685   bra     SetRptBailout
                      01686   movlb 0              ; The Basic code needs bank 0
                      01687   call  RcvOutRpt        ; Transfer Output Report data from EP0 buffer & unpack it
                      01688 SetRptCommon
                      01689   movlb high 0x400               ; Point to our proper bank again
                      01690 ;
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 44


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01691 ; Because RcvFeatureRpt calls UnPacket which toggles DTS, and the caller 
                      01692 ; of this routine, USBCtrlTrfOutHandler, also toggles DTS, these would cancel.  
                      01693 ; We need to toggle DTS one more time here, to make things come out right.
                      01694         movlw   _USIE|_DAT1|_DTSEN
                      01695         btfsc   ep0Bo + Stat, DTS
                      01696         movlw   _USIE|_DAT0|_DTSEN
                      01697         movwf   ep0Bo + Stat
                      01698 ;  
                      01699   movf SetRptInProgress, W
                      01700   btfss  STATUS, Z
                      01701   return              ; If SET_REPORT is still in progress, wait for next OUT packet request
                      01702 ; Otherwise, need to clear ctrl_trf_state here: SET_REPORT operation is done
                      01703         movlw   WAIT_SETUP
                      01704         movwf   ctrl_trf_state
                      01705 SetRptBailout
                      01706   return
                      01707 NoSetRpt
                      01708 
                      01709 #endif
00054C 50??           01710         movf    ep0Bo + Cnt, W          ; Get low number of bytes to read
00054E 6E??           01711         movwf   usb_temp                ; usb_temp & usb_temp + 1 are bytes to read
000550 26??           01712         addwf   wCount, F               ; Accumulate total number of bytes read
000552 50??           01713         movf    ep0Bo + Stat, W         ; Get high bits to read
000554 0B03           01714         andlw   0x03                    ; Mask to the count
000556 6E??           01715         movwf   usb_temp + 1            ; Save to high byte of bytes to read
000558 22??           01716         addwfc  wCount + 1, F           ; Add overflow from low byte (C) and high byte to total number
00055A EE?? F0??      01717         lfsr    1, CtrlTrfData          ; Point FSR1 to source
00055E C??? FFD9      01718         movff   pDst, FSR2L             ; Move destination pointer to FSR2
000562 C??? FFDA      01719         movff   pDst + 1, FSR2H
000566 50??           01720         movf    usb_temp + 1, W         ; Check high byte for 0
000568 E1??           01721         bnz     USBCtrlTrfRxServiceLoop ; High byte not 0, must have something to do
00056A 50??           01722         movf    usb_temp, W             ; Check low byte for 0
00056C E0??           01723         bz      USBCtrlTrfRxServiceExit ; If both 0 then nothing to send this time
00056E                01724 USBCtrlTrfRxServiceLoop
00056E CFE6 FFDE      01725         movff   POSTINC1, POSTINC2      ; Copy one buffer to the other
000572 06??           01726         decf    usb_temp, F             ; Count down number of bytes
000574 E1??           01727         bnz     USBCtrlTrfRxServiceLoop
000576 06??           01728         decf    usb_temp + 1, F
000578 E2??           01729         bc      USBCtrlTrfRxServiceLoop
00057A CFD9 F???      01730         movff   FSR2L, pDst             ; Update destination pointer
00057E CFDA F???      01731         movff   FSR2H, pDst + 1
000582                01732 USBCtrlTrfRxServiceExit
000582 0012           01733         return
                      01734 
                      01735 
                      01736 ; From usbctrltrf.c line 382
                      01737 ;/******************************************************************************
                      01738 ; * Function:        void USBCtrlEPServiceComplete(void)
                      01739 ; *
                      01740 ; * PreCondition:    None
                      01741 ; *
                      01742 ; * Input:           None
                      01743 ; *
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 45


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01744 ; * Output:          None
                      01745 ; *
                      01746 ; * Side Effects:    None
                      01747 ; *
                      01748 ; * Overview:        This routine wrap up the ramaining tasks in servicing
                      01749 ; *                  a Setup Request. Its main task is to set the endpoint
                      01750 ; *                  controls appropriately for a given situation. See code
                      01751 ; *                  below.
                      01752 ; *                  There are three main scenarios:
                      01753 ; *                  a) There was no handler for the Request, in this case
                      01754 ; *                     a STALL should be sent out.
                      01755 ; *                  b) The host has requested a read control transfer,
                      01756 ; *                     endpoints are required to be setup in a specific way.
                      01757 ; *                  c) The host has requested a write control transfer, or
                      01758 ; *                     a control data stage is not required, endpoints are
                      01759 ; *                     required to be setup in a specific way.
                      01760 ; *
                      01761 ; *                  Packet processing is resumed by clearing PKTDIS bit.
                      01762 ; *
                      01763 ; * Note:            None
                      01764 ; *****************************************************************************/
000584                01765 USBCtrlEPServiceComplete
                      01766 ;       movlb   high 0x400              ; Point to proper bank
000584 0E00           01767         movlw   MUID_NULL
000586 62??           01768         cpfseq  ctrl_trf_session_owner
000588 D???           01769         bra     USBCtrlEPServiceComplete1
                      01770 ;
                      01771 ; No handlers claimed ownership of this Setup packet.
                      01772 ; If no one knows how to service this request then stall.
                      01773 ; Must also prepare EP0 to receive the next SETUP transaction.
00058A 0E08           01774         movlw   EP0_BUFF_SIZE
00058C 6E??           01775         movwf   ep0Bo + Cnt
00058E 0E??           01776         movlw   low SetupPkt
000590 6E??           01777         movwf   ep0Bo + ADRL
000592 0E??           01778         movlw   high SetupPkt
000594 6E??           01779         movwf   ep0Bo + ADRH
000596 0E84           01780         movlw   _USIE|_BSTALL
000598 6E??           01781         movwf   ep0Bo + Stat
00059A 6E??           01782         movwf   ep0Bi + Stat
00059C D???           01783         bra     USBCtrlEPServiceCompleteExit
                      01784 ;
                      01785 ; A module has claimed ownership of the control transfer session.
00059E                01786 USBCtrlEPServiceComplete1
00059E AE??           01787         btfss   SetupPkt, DataDir
0005A0 D???           01788         bra     USBCtrlEPServiceComplete2
0005A2 50??           01789         movf    wCount + 1, W           ; Make sure count does not exceed max length requested by Host
0005A4 5C??           01790         subwf   SetupPkt + wLengthHi, W
0005A6 E3??           01791         bnc     USBCtrlEPServiceCompleteCopy
0005A8 E1??           01792         bnz     USBCtrlEPServiceComplete11
0005AA 50??           01793         movf    wCount, W
0005AC 5C??           01794         subwf   SetupPkt + wLength, W
0005AE E2??           01795         bc      USBCtrlEPServiceComplete11
0005B0                01796 USBCtrlEPServiceCompleteCopy
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 46


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0005B0 C??? F???      01797         movff   SetupPkt + wLength, wCount      ; Set count to maximum
0005B4 C??? F???      01798         movff   SetupPkt + wLengthHi, wCount + 1
                      01799 ;
                      01800 ; Setup packet's data direction is "Device to Host"
0005B8                01801 USBCtrlEPServiceComplete11
0005B8 D???           01802         rcall   USBCtrlTrfTxService    ; Actually copy the data to EP0 IN buffer
0005BA 0E01           01803         movlw   CTRL_TRF_TX
0005BC 6E??           01804         movwf   ctrl_trf_state
                      01805 ; Control Read:
                      01806 ; <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
                      01807 ; 1. Prepare OUT EP to respond to early termination
                      01808 ;
                      01809 ; NOTE:
                      01810 ; If something went wrong during the control transfer,
                      01811 ; the last status stage may not be sent by the host.
                      01812 ; When this happens, two different things could happen
                      01813 ; depending on the host.
                      01814 ; a) The host could send out a RESET.
                      01815 ; b) The host could send out a new SETUP transaction
                      01816 ;    without sending a RESET first.
                      01817 ; To properly handle case (b), the OUT EP must be setup
                      01818 ; to receive either a zero length OUT transaction, or a
                      01819 ; new SETUP transaction.
                      01820 ;
                      01821 ; Since the SETUP transaction requires the DTS bit to be
                      01822 ; DAT0 while the zero length OUT status requires the DTS
                      01823 ; bit to be DAT1, the DTS bit check by the hardware should
                      01824 ; be disabled. This way the SIE could accept either of
                      01825 ; the two transactions.
                      01826 ;
                      01827 ; Furthermore, the Cnt byte should be set to prepare for
                      01828 ; the SETUP data (8-byte or more), and the buffer address
                      01829 ; should be pointed to SetupPkt.
0005BE 0E08           01830         movlw   EP0_BUFF_SIZE
0005C0 6E??           01831         movwf   ep0Bo + Cnt
0005C2 0E??           01832         movlw   low SetupPkt
0005C4 6E??           01833         movwf   ep0Bo + ADRL
0005C6 0E??           01834         movlw   high SetupPkt
0005C8 6E??           01835         movwf   ep0Bo + ADRH
0005CA 0E80           01836         movlw   _USIE                   ; Note: DTSEN is 0!
0005CC 6E??           01837         movwf   ep0Bo + Stat
                      01838 ; 2. Prepare IN EP to transfer data, Cnt should have
                      01839 ;    been initialized by responsible request owner.
0005CE 0E??           01840         movlw   low CtrlTrfData
0005D0 6E??           01841         movwf   ep0Bi + ADRL
0005D2 0E??           01842         movlw   high CtrlTrfData
0005D4 6E??           01843         movwf   ep0Bi + ADRH
0005D6 0EC8           01844         movlw   _USIE|_DAT1|_DTSEN
0005D8 6E??           01845         movwf   ep0Bi + Stat
0005DA D???           01846         bra     USBCtrlEPServiceCompleteExit
                      01847 ;
                      01848 ; Setup packet's data direction is "Host to Device"
0005DC                01849 USBCtrlEPServiceComplete2
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 47


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0005DC 0E02           01850         movlw   CTRL_TRF_RX
0005DE 6E??           01851         movwf   ctrl_trf_state
                      01852 ; Control Write:
                      01853 ; <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
                      01854 ;
                      01855 ; 1. Prepare IN EP to respond to early termination
                      01856 ;
                      01857 ;    This is the same as a Zero Length Packet Response
                      01858 ;    for control transfer without a data stage
0005E0 6A??           01859         clrf    ep0Bi + Cnt
0005E2 0EC8           01860         movlw   _USIE|_DAT1|_DTSEN
0005E4 6E??           01861         movwf   ep0Bi + Stat
                      01862 ; 2. Prepare OUT EP to receive data.
0005E6 0E08           01863         movlw   EP0_BUFF_SIZE
0005E8 6E??           01864         movwf   ep0Bo + Cnt
0005EA 0E??           01865         movlw   low CtrlTrfData
0005EC 6E??           01866         movwf   ep0Bo + ADRL
0005EE 0E??           01867         movlw   high CtrlTrfData
0005F0 6E??           01868         movwf   ep0Bo + ADRH
0005F2 0EC8           01869         movlw   _USIE|_DAT1|_DTSEN
0005F4 6E??           01870         movwf   ep0Bo + Stat
                      01871 ;
0005F6                01872 USBCtrlEPServiceCompleteExit
                      01873 ; PKTDIS bit is set when a Setup Transaction is received.
                      01874 ; Clear to resume packet processing.
0005F6 986D           01875         bcf     UCON, PKTDIS
0005F8 0012           01876         return
                      01877 
                      01878 
                      01879 ; From usbctrltrf.c line 490
                      01880 ;/******************************************************************************
                      01881 ; * Function:        void USBPrepareForNextSetupTrf(void)
                      01882 ; *
                      01883 ; * PreCondition:    None
                      01884 ; *
                      01885 ; * Input:           None
                      01886 ; *
                      01887 ; * Output:          None
                      01888 ; *
                      01889 ; * Side Effects:    None
                      01890 ; *
                      01891 ; * Overview:        The routine forces EP0 OUT to be ready for a new Setup
                      01892 ; *                  transaction, and forces EP0 IN to be owned by CPU.
                      01893 ; *
                      01894 ; * Note:            None
                      01895 ; *****************************************************************************/
0005FA                01896 USBPrepareForNextSetupTrf
                      01897 ;       movlb   high 0x400              ; Point to proper bank
0005FA 0E00           01898         movlw   WAIT_SETUP
0005FC 6E??           01899         movwf   ctrl_trf_state
0005FE 0E08           01900         movlw   EP0_BUFF_SIZE
000600 6E??           01901         movwf   ep0Bo + Cnt
000602 0E??           01902         movlw   low SetupPkt
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 48


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000604 6E??           01903         movwf   ep0Bo + ADRL
000606 0E??           01904         movlw   high SetupPkt
000608 6E??           01905         movwf   ep0Bo + ADRH
00060A 0E88           01906         movlw   _USIE|_DAT0|_DTSEN      ; EP0 buff dsc init
00060C 6E??           01907         movwf   ep0Bo + Stat
00060E 0E00           01908         movlw   _UCPU                   ; EP0 IN buffer initialization
000610 6E??           01909         movwf   ep0Bi + Stat
000612 0012           01910         return
                      01911 
                      01912 
                      01913 
                      01914 ; From usbdrv.c line ???
                      01915 ;/******************************************************************************
                      01916 ; * Function:        void InitializeUSBDriver(void)
                      01917 ; *
                      01918 ; * PreCondition:    None
                      01919 ; *
                      01920 ; * Input:           None
                      01921 ; *
                      01922 ; * Output:          None
                      01923 ; *
                      01924 ; * Side Effects:    None
                      01925 ; *
                      01926 ; * Overview:        This routine initializes variables used by the USB library
                      01927 ; *                  routines.
                      01928 ; *
                      01929 ; * Note:            None
                      01930 ; *****************************************************************************/
000614                01931 InitializeUSBDriver
000614 0104           01932         movlb   high 0x400              ; Point to proper bank
000616 0E08           01933         movlw   EP0_BUFF_SIZE
000618 6E??           01934         movwf   SetupPktLen
00061A 6E??           01935         movwf   CtrlTrfDataLen
00061C 6A??           01936         clrf  (CtrlTrfDataStorage + 4)
00061E 0E14           01937         movlw   UCFG_VAL
000620 6E6F           01938         movwf   UCFG
000622 0E00           01939         movlw   DETACHED_STATE
000624 6E??           01940         movwf   usb_device_state
000626 6A??           01941         clrf    usb_stat
000628 6A??           01942         clrf    usb_active_cfg
                      01943 ;#ifdef USB_USE_CDC
                      01944 ;       rcall   CDCInitEP
                      01945 ;#endif
                      01946 
                      01947 #ifdef USB_WATCH
                      01948 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01949 ; Add USBwatch activity reporting over hardware serial port
                      01950 ; (1)  'L'
                      01951     movlw   USBW_POWERED_STATE
                      01952     movwf         USBWstate
                      01953     call   UsbwSendState
                      01954 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      01955 #endif
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 49


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01956 
00062A 0012           01957         return
                      01958 
                      01959 
                      01960 ; From usbdrv.c line 76
                      01961 ;/******************************************************************************
                      01962 ; * Function:        void USBCheckBusStatus(void)
                      01963 ; *
                      01964 ; * PreCondition:    None
                      01965 ; *
                      01966 ; * Input:           None
                      01967 ; *
                      01968 ; * Output:          None
                      01969 ; *
                      01970 ; * Side Effects:    None
                      01971 ; *
                      01972 ; * Overview:        This routine enables/disables the USB module by monitoring
                      01973 ; *                  the USB power signal.
                      01974 ; *
                      01975 ; * Note:            None
                      01976 ; *****************************************************************************/
00062C                01977 USBCheckBusStatus
00062C 0104           01978         movlb   high 0x400              ; Point to proper bank
                      01979 ; Bus Attachment & Detachment Detection
                      01980 ; usb_bus_sense is an i/o pin defined in io_cfg.h
                      01981 #ifdef USE_USB_BUS_SENSE_IO
                      01982         btfss   usb_bus_sense           ; Is USB bus attached?
                      01983         bra     USBCheckBusStatusDetached       ; No
                      01984 #endif
00062E A66D           01985         btfss   UCON, USBEN             ; Is the module off?
000630 D???           01986         rcall   USBModuleEnable         ; Is off, enable it
                      01987 #ifdef USE_USB_BUS_SENSE_IO
                      01988         bra     USBCheckBusStatus1
                      01989 USBCheckBusStatusDetached
                      01990         btfsc   UCON, USBEN             ; Is the module on?
                      01991         rcall   USBModuleDisable        ; Is on, disable it
                      01992 #endif
                      01993 ;
                      01994 ; After enabling the USB module, it takes some time for the voltage
                      01995 ; on the D+ or D- line to rise high enough to get out of the SE0 condition.
                      01996 ; The USB Reset interrupt should not be unmasked until the SE0 condition is
                      01997 ; cleared. This helps preventing the firmware from misinterpreting this
                      01998 ; unique event as a USB bus reset from the USB host.
000632                01999 USBCheckBusStatus1
000632 0E01           02000         movlw   ATTACHED_STATE
000634 62??           02001         cpfseq  usb_device_state
000636 0012           02002         return
000638 BA6D           02003         btfsc   UCON, SE0
00063A 0012           02004         return
00063C 6A68           02005         clrf    UIR                     ; Clear all USB interrupts
00063E 6A69           02006         clrf    UIE                     ; Mask all USB interrupts
000640 8069           02007         bsf     UIE, URSTIE             ; Unmask RESET interrupt
000642 8869           02008         bsf     UIE, IDLEIE             ; Unmask IDLE interrupt
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 50


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000644 0E02           02009         movlw   POWERED_STATE
000646 6E??           02010         movwf   usb_device_state
000648 0012           02011         return
                      02012 
                      02013 
                      02014 ; From usbdrv.c line 135
00064A                02015 USBModuleEnable
                      02016 ;       movlb   high 0x400              ; Point to proper bank
00064A 6A6D           02017         clrf    UCON
00064C 6A69           02018         clrf    UIE                     ; Mask all USB interrupts
00064E 866D           02019         bsf     UCON, USBEN             ; Enable module & attach to bus
000650 0E01           02020         movlw   ATTACHED_STATE
000652 6E??           02021         movwf   usb_device_state
000654 0012           02022         return
                      02023 
                      02024 
                      02025 ; From usbdrv.c line 192
000656                02026 USBSoftDetach
  0000                02027   global USBSoftDetach
                      02028 ; From usbdrv.c line 161
000656                02029 USBModuleDisable
000656 0104           02030         movlb   high 0x400              ; Point to proper bank
000658 6A6D           02031         clrf    UCON                    ; Disable module & detach from bus
00065A 6A69           02032         clrf    UIE                     ; Mask all USB interrupts
00065C 0E00           02033         movlw   DETACHED_STATE
00065E 6E??           02034         movwf   usb_device_state
000660 0012           02035         return
                      02036 
                      02037 
                      02038 ; From usbdrv.c line 215
                      02039 ;/******************************************************************************
                      02040 ; * Function:        void USBDriverService(void)
                      02041 ; *
                      02042 ; * PreCondition:    None
                      02043 ; *
                      02044 ; * Input:           None
                      02045 ; *
                      02046 ; * Output:          None
                      02047 ; *
                      02048 ; * Side Effects:    None
                      02049 ; *
                      02050 ; * Overview:        This routine is the heart of this firmware. It manages
                      02051 ; *                  all USB interrupts.
                      02052 ; *
                      02053 ; * Note:            Device state transitions through the following stages:
                      02054 ; *                  DETACHED -> ATTACHED -> POWERED -> DEFAULT ->
                      02055 ; *                  ADDRESS_PENDING -> ADDRESSED -> CONFIGURED -> READY
                      02056 ; *****************************************************************************/
000662                02057 USBDriverService
000662 0104           02058         movlb   high 0x400              ; Point to proper bank
000664 0E00           02059         movlw   DETACHED_STATE
000666 5C??           02060         subwf   usb_device_state, W
000668 E0??           02061         bz      USBDriverServiceExit    ; Pointless to continue servicing
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 51


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02062                                         ; if USB cable is not even attached.
                      02063 ;
                      02064 ; Task A: Service USB Activity Interrupt
00066A A468           02065         btfss   UIR, ACTVIF
00066C D???           02066         bra     USBDriverService1
00066E B469           02067         btfsc   UIE, ACTVIE
000670 D???           02068         rcall   USBWakeFromSuspend
                      02069 ;
000672                02070 USBDriverService1
000672 B26D           02071         btfsc   UCON, SUSPND            ; Are we suspended?
000674 0012           02072         return                          ; Pointless to continue servicing if the device is in suspend mo
                            de.
                      02073 ;
                      02074 ; Task B: Service USB Bus Reset Interrupt.
                      02075 ; When bus reset is received during suspend, ACTVIF will be set first,
                      02076 ; once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
                      02077 ; This is why URSTIF is checked after ACTVIF.
                      02078 ;
                      02079 ; The USB reset flag is masked when the USB state is in
                      02080 ; DETACHED_STATE or ATTACHED_STATE, and therefore cannot
                      02081 ; cause a USB reset event during these two states.
000676 A068           02082         btfss   UIR, URSTIF        ; USB Bus Reset Interrupt?
000678 D???           02083         bra     USBDriverService2
00067A B069           02084         btfsc   UIE, URSTIE
00067C D???           02085         rcall   USBProtocolResetHandler
                      02086 ;
                      02087 ; Task C: Check & service other USB interrupts
00067E                02088 USBDriverService2
00067E A868           02089         btfss   UIR, IDLEIF
000680 D???           02090         bra     USBDriverService3
000682 B869           02091         btfsc   UIE, IDLEIE
000684 D???           02092         rcall   USBSuspend
000686                02093 USBDriverService3
000686 AC68           02094         btfss   UIR, SOFIF
000688 D???           02095         bra     USBDriverService4
00068A BC69           02096         btfsc   UIE, SOFIE
00068C D???           02097         rcall   USB_SOF_Handler
00068E                02098 USBDriverService4
00068E AA68           02099         btfss   UIR, STALLIF
000690 D???           02100         bra     USBDriverService5
000692 BA69           02101         btfsc   UIE, STALLIE
000694 D???           02102         rcall   USBStallHandler
000696                02103 USBDriverService5
000696 A268           02104         btfss   UIR, UERRIF
000698 D???           02105         bra     USBDriverService6
00069A B269           02106         btfsc   UIE, UERRIE
00069C D???           02107         rcall   USBErrorHandler
                      02108 ;
                      02109 ; Pointless to continue servicing if the host has not sent a bus reset.
                      02110 ; Once bus reset is received, the device transitions into the DEFAULT
                      02111 ;     * state and is ready for communication.
00069E                02112 USBDriverService6
00069E 0E03           02113         movlw   DEFAULT_STATE
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 52


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0006A0 5C??           02114         subwf   usb_device_state, W
0006A2 E3??           02115         bnc     USBDriverServiceExit
                      02116 ;
                      02117 ; Task D: Servicing USB Transaction Complete Interrupt
0006A4 A668           02118         btfss   UIR, TRNIF
0006A6 D???           02119         bra     USBDriverServiceExit
0006A8 A669           02120         btfss   UIE, TRNIE
0006AA D???           02121         bra     USBDriverServiceExit
                      02122 
                      02123 #ifdef USB_WATCH
                      02124 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      02125 ; Add USBwatch activity reporting over hardware serial port
                      02126 
                      02127 ;  If here, a new USB transaction has occurred, so report on it
                      02128   rcall  UsbwNewTransaction
                      02129 
                      02130 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      02131 #endif
                      02132 
                      02133 ;
                      02134 ; USBCtrlEPService only services transactions over EP0.
                      02135 ; It ignores all other EP transactions.
0006AC D???           02136         rcall   USBCtrlEPService
                      02137 ; Other EPs can be serviced later by responsible device class firmware.
                      02138 ; Each device driver knows when an OUT or IN transaction is ready by
                      02139 ; checking the buffer ownership bit.
                      02140 ; An OUT EP should always be owned by SIE until the data is ready.
                      02141 ; An IN EP should always be owned by CPU until the data is ready.
                      02142 ;
                      02143 ; Because of this logic, it is not necessary to save the USTAT value
                      02144 ; of non-EP0 transactions.
0006AE 9668           02145         bcf     UIR, TRNIF
0006B0                02146 USBDriverServiceExit
0006B0 0012           02147         return
                      02148 
                      02149 
                      02150 ; From usbdrv.c line 301
                      02151 ;/******************************************************************************
                      02152 ; * Function:        void USBSuspend(void)
                      02153 ; *
                      02154 ; * PreCondition:    None
                      02155 ; *
                      02156 ; * Input:           None
                      02157 ; *
                      02158 ; * Output:          None
                      02159 ; *
                      02160 ; * Side Effects:    None
                      02161 ; *
                      02162 ; * Overview:
                      02163 ; *
                      02164 ; * Note:            None
                      02165 ; *****************************************************************************/
0006B2                02166 USBSuspend
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 53


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02167 ; NOTE: Do not clear UIRbits.ACTVIF here!
                      02168 ; Reason:
                      02169 ; ACTVIF is only generated once an IDLEIF has been generated.
                      02170 ; This is a 1:1 ratio interrupt generation.
                      02171 ; For every IDLEIF, there will be only one ACTVIF regardless of
                      02172 ; the number of subsequent bus transitions.
                      02173 ;
                      02174 ; If the ACTIF is cleared here, a problem could occur when:
                      02175 ; [       IDLE       ][bus activity ->
                      02176 ; <--- 3 ms ----->     ^
                      02177 ;                ^     ACTVIF=1
                      02178 ;                IDLEIF=1
                      02179 ;  #           #           #           #   (#=Program polling flags)
                      02180 ;                          ^
                      02181 ;                          This polling loop will see both
                      02182 ;                          IDLEIF=1 and ACTVIF=1.
                      02183 ;                          However, the program services IDLEIF first
                      02184 ;                          because ACTIVIE=0.
                      02185 ;                          If this routine clears the only ACTIVIF,
                      02186 ;                          then it can never get out of the suspend
                      02187 ;                          mode.
0006B2 8469           02188         bsf     UIE, ACTVIE             ; Enable bus activity interrupt
0006B4 9868           02189         bcf     UIR, IDLEIF
0006B6 826D           02190         bsf     UCON, SUSPND            ; Put USB module in power conserve
                      02191 ; At this point the PIC can go into sleep,idle, or
                      02192 ; switch to a slower clock, etc.
0006B8 0012           02193         return
                      02194 
                      02195 
                      02196 ; From usbdrv.c line 353
                      02197 ;/******************************************************************************
                      02198 ; * Function:        void USBWakeFromSuspend(void)
                      02199 ; *
                      02200 ; * PreCondition:    None
                      02201 ; *
                      02202 ; * Input:           None
                      02203 ; *
                      02204 ; * Output:          None
                      02205 ; *
                      02206 ; * Side Effects:    None
                      02207 ; *
                      02208 ; * Overview:
                      02209 ; *
                      02210 ; * Note:            None
                      02211 ; *****************************************************************************/
0006BA                02212 USBWakeFromSuspend
                      02213 ; If using clock switching, this is the place to restore the
                      02214 ; original clock frequency.
0006BA 926D           02215         bcf     UCON, SUSPND
0006BC 9469           02216         bcf     UIE, ACTVIE
0006BE 9468           02217         bcf     UIR, ACTVIF
0006C0 0012           02218         return
                      02219 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 54


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02220 
                      02221 ; From usbdrv.c line 402
                      02222 ;/******************************************************************************
                      02223 ; * Function:        void USBRemoteWakeup(void)
                      02224 ; *
                      02225 ; * PreCondition:    None
                      02226 ; *
                      02227 ; * Input:           None
                      02228 ; *
                      02229 ; * Output:          None
                      02230 ; *
                      02231 ; * Side Effects:    None
                      02232 ; *
                      02233 ; * Overview:        This function should be called by user when the device
                      02234 ; *                  is waken up by an external stimulus other than ACTIVIF.
                      02235 ; *                  Please read the note below to understand the limitations.
                      02236 ; *
                      02237 ; * Note:            The modifiable section in this routine should be changed
                      02238 ; *                  to meet the application needs. Current implementation
                      02239 ; *                  temporary blocks other functions from executing for a
                      02240 ; *                  period of 1-13 ms depending on the core frequency.
                      02241 ; *
                      02242 ; *                  According to USB 2.0 specification section 7.1.7.7,
                      02243 ; *                  "The remote wakeup device must hold the resume signaling
                      02244 ; *                  for at lest 1 ms but for no more than 15 ms."
                      02245 ; *                  The idea here is to use a delay counter loop, using a
                      02246 ; *                  common value that would work over a wide range of core
                      02247 ; *                  frequencies.
                      02248 ; *                  That value selected is 1800. See table below:
                      02249 ; *                  ==========================================================
                      02250 ; *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
                      02251 ; *                  ==========================================================
                      02252 ; *                      48              12          1.05
                      02253 ; *                       4              1           12.6
                      02254 ; *                  ==========================================================
                      02255 ; *                  * These timing could be incorrect when using code
                      02256 ; *                    optimization or extended instruction mode,
                      02257 ; *                    or when having other interrupts enabled.
                      02258 ; *                    Make sure to verify using the MPLAB SIM's Stopwatch
                      02259 ; *****************************************************************************/
0006C2                02260 USBRemoteWakeup
0006C2 0104           02261         movlb   high 0x400              ; Point to proper bank
0006C4 A0??           02262         btfss   usb_stat, RemoteWakeup  ; Check if RemoteWakeup function has been enabled by the host.
0006C6 0012           02263         return                          ; No
0006C8 D???           02264         rcall   USBWakeFromSuspend      ; Unsuspend USB modue
0006CA 846D           02265         bsf     UCON, RESUME            ; Start RESUME signaling
0006CC 0E10           02266         movlw   0x10                    ; Set RESUME line for 1-13 ms
0006CE 6EDA           02267         movwf   FSR2H                   ; Using FSR2 as temp
0006D0 6AD9           02268         clrf    FSR2L
0006D2                02269 USBRemoteWakeupLoop
0006D2 2ED9           02270         decfsz  FSR2L, F
0006D4 D???           02271         bra     USBRemoteWakeupLoop
0006D6 2EDA           02272         decfsz  FSR2H, F
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 55


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0006D8 D???           02273         bra     USBRemoteWakeupLoop
0006DA 946D           02274         bcf     UCON, RESUME
0006DC 0012           02275         return
                      02276 
                      02277 
                      02278 ; From usbdrv.c line 443
                      02279 ;/******************************************************************************
                      02280 ; * Function:        void USB_SOF_Handler(void)
                      02281 ; *
                      02282 ; * PreCondition:    None
                      02283 ; *
                      02284 ; * Input:           None
                      02285 ; *
                      02286 ; * Output:          None
                      02287 ; *
                      02288 ; * Side Effects:    None
                      02289 ; *
                      02290 ; * Overview:        The USB host sends out a SOF packet to full-speed devices
                      02291 ; *                  every 1 ms. This interrupt may be useful for isochronous
                      02292 ; *                  pipes. End designers should implement callback routine
                      02293 ; *                  as necessary.
                      02294 ; *
                      02295 ; * Note:            None
                      02296 ; *****************************************************************************/
0006DE                02297 USB_SOF_Handler
                      02298 ; Callback routine here
0006DE 9C68           02299         bcf UIR, SOFIF
0006E0 0012           02300         return
                      02301 
                      02302 
                      02303 ; From usbdrv.c line 486
                      02304 ;/******************************************************************************
                      02305 ; * Function:        void USBStallHandler(void)
                      02306 ; *
                      02307 ; * PreCondition:    A STALL packet is sent to the host by the SIE.
                      02308 ; *
                      02309 ; * Input:           None
                      02310 ; *
                      02311 ; * Output:          None
                      02312 ; *
                      02313 ; * Side Effects:    None
                      02314 ; *
                      02315 ; * Overview:        The STALLIF is set anytime the SIE sends out a STALL
                      02316 ; *                  packet regardless of which endpoint causes it.
                      02317 ; *                  A Setup transaction overrides the STALL function. A stalled
                      02318 ; *                  endpoint stops stalling once it receives a setup packet.
                      02319 ; *                  In this case, the SIE will accepts the Setup packet and
                      02320 ; *                  set the TRNIF flag to notify the firmware. STALL function
                      02321 ; *                  for that particular endpoint pipe will be automatically
                      02322 ; *                  disabled (direction specific).
                      02323 ; *
                      02324 ; *                  There are a few reasons for an endpoint to be stalled.
                      02325 ; *                  1. When a non-supported USB request is received.
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 56


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02326 ; *                     Example: GET_DESCRIPTOR(DEVICE_QUALIFIER)
                      02327 ; *                  2. When an endpoint is currently halted.
                      02328 ; *                  3. When the device class specifies that an endpoint must
                      02329 ; *                     stall in response to a specific event.
                      02330 ; *                     Example: Mass Storage Device Class
                      02331 ; *                              If the CBW is not valid, the device shall
                      02332 ; *                              STALL the Bulk-In pipe.
                      02333 ; *                              See USB Mass Storage Class Bulk-only Transport
                      02334 ; *                              Specification for more details.
                      02335 ; *
                      02336 ; * Note:            UEPn.EPSTALL can be scanned to see which endpoint causes
                      02337 ; *                  the stall event.
                      02338 ; *                  If
                      02339 ; *****************************************************************************/
0006E2                02340 USBStallHandler
                      02341 ; Does not really have to do anything here,
                      02342 ; even for the control endpoint.
                      02343 ; All BDs of Endpoint 0 are owned by SIE right now,
                      02344 ; but once a Setup Transaction is received, the ownership
                      02345 ; for EP0_OUT will be returned to CPU.
                      02346 ; When the Setup Transaction is serviced, the ownership
                      02347 ; for EP0_IN will then be forced back to CPU by firmware.
                      02348 ;
                      02349 ; NOTE: Above description is not quite true at this point.
                      02350 ;       It seems the SIE never returns the UOWN bit to CPU,
                      02351 ;       and a TRNIF is never generated upon successful
                      02352 ;       reception of a SETUP transaction.
                      02353 ;       Firmware work-around is implemented below.
                      02354 ;
0006E2 B070           02355         btfsc   UEP0, EPSTALL
0006E4 D???           02356         rcall   USBPrepareForNextSetupTrf       ; Firmware Work-Around
0006E6 9070           02357         bcf     UEP0, EPSTALL
0006E8 9A68           02358         bcf     UIR, STALLIF
0006EA 0012           02359         return
                      02360 
                      02361 ; From usbdrv.c line 528
                      02362 ;/******************************************************************************
                      02363 ; * Function:        void USBErrorHandler(void)
                      02364 ; *
                      02365 ; * PreCondition:    None
                      02366 ; *
                      02367 ; * Input:           None
                      02368 ; *
                      02369 ; * Output:          None
                      02370 ; *
                      02371 ; * Side Effects:    None
                      02372 ; *
                      02373 ; * Overview:        The purpose of this interrupt is mainly for debugging
                      02374 ; *                  during development. Check UEIR to see which error causes
                      02375 ; *                  the interrupt.
                      02376 ; *
                      02377 ; * Note:            None
                      02378 ; *****************************************************************************/
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 57


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0006EC                02379 USBErrorHandler
0006EC 9268           02380         bcf     UIR, UERRIF
0006EE 0012           02381         return
                      02382 
                      02383 
                      02384 ; From usbdrv.c line 555
                      02385 ;/******************************************************************************
                      02386 ; * Function:        void USBProtocolResetHandler(void)
                      02387 ; *
                      02388 ; * PreCondition:    A USB bus reset is received from the host.
                      02389 ; *
                      02390 ; * Input:           None
                      02391 ; *
                      02392 ; * Output:          None
                      02393 ; *
                      02394 ; * Side Effects:    Currently, this routine flushes any pending USB
                      02395 ; *                  transactions. It empties out the USTAT FIFO. This action
                      02396 ; *                  might not be desirable in some applications.
                      02397 ; *
                      02398 ; * Overview:        Once a USB bus reset is received from the host, this
                      02399 ; *                  routine should be called. It resets the device address to
                      02400 ; *                  zero, disables all non-EP0 endpoints, initializes EP0 to
                      02401 ; *                  be ready for default communication, clears all USB
                      02402 ; *                  interrupt flags, unmasks applicable USB interrupts, and
                      02403 ; *                  reinitializes internal state-machine variables.
                      02404 ; *
                      02405 ; * Note:            None
                      02406 ; *****************************************************************************/
0006F0                02407 USBProtocolResetHandler
                      02408 ;       movlb   high 0x400              ; Point to proper bank
0006F0 6A6A           02409         clrf    UEIR                    ; Clear all USB error flags
0006F2 6A68           02410         clrf    UIR                     ; Clears all USB interrupts
0006F4 0E9F           02411         movlw   0x9f                    ; Unmask all USB error interrupts
0006F6 6E6B           02412         movwf   UEIE
0006F8 0E7B           02413         movlw   0x7b                    ; Enable all interrupts except ACTVIE
0006FA 6E69           02414         movwf   UIE
0006FC 6A6E           02415         clrf    UADDR                   ; Reset to default address
0006FE EE2F F071      02416         lfsr    2, UEP1                 ; Reset all non-EP0 UEPn registers
000702 0E0F           02417         movlw   15
000704                02418 USBProtocolResetHandlerClearLoop
000704 6ADE           02419         clrf    POSTINC2
000706 2EE8           02420         decfsz  WREG, F
000708 D???           02421         bra     USBProtocolResetHandlerClearLoop
00070A 0E16           02422         movlw   EP_CTRL|HSHK_EN         ; Init EP0 as a Ctrl EP
00070C 6E70           02423         movwf   UEP0
00070E B668           02424         btfsc   UIR, TRNIF              ; Flush any pending transactions
000710                02425 USBProtocolResetHandlerFlushLoop
000710 9668           02426         bcf     UIR, TRNIF
000712 B668           02427         btfsc   UIR, TRNIF
000714 D???           02428         bra     USBProtocolResetHandlerFlushLoop
000716 986D           02429         bcf     UCON, PKTDIS            ; Make sure packet processing is enabled
000718 D???           02430         rcall   USBPrepareForNextSetupTrf
00071A 90??           02431         bcf     usb_stat, RemoteWakeup  ; Default status flag to disable
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 58


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00071C 6A??           02432         clrf    usb_active_cfg          ; Clear active configuration
00071E 0E03           02433         movlw   DEFAULT_STATE
000720 6E??           02434   movwf usb_device_state
                      02435 
                      02436 #ifdef USB_WATCH
                      02437 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      02438 ; Add USBwatch activity reporting over hardware serial port
                      02439 ; (3)
                      02440     movlw   USBW_DEFAULT_STATE
                      02441     movwf         USBWstate
                      02442     call   UsbwSendState
                      02443 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      02444 #endif
                      02445 
000722 0012           02446         return
                      02447 
                      02448 
                      02449 
                      02450 #ifdef USB_USE_HID
                      02451 
                      02452 ; From hid.c  line 72
                      02453 ;/******************************************************************************
                      02454 ; * Function:        void USBCheckHIDRequest(void)
                      02455 ; *
                      02456 ; * PreCondition:    None
                      02457 ; *
                      02458 ; * Input:           None
                      02459 ; *
                      02460 ; * Output:          None
                      02461 ; *
                      02462 ; * Side Effects:    None
                      02463 ; *
                      02464 ; * Overview:        This routine checks the setup data packet to see if it
                      02465 ; *                  knows how to handle it
                      02466 ; *
                      02467 ; * Note:            HIDmaker version, enhanced to be able to handle multiple
                      02468 ; *                  Report Descriptors by reading tables in generated file
                      02469 ; *                  Descript.asm
                      02470 ; *****************************************************************************/
000724                02471 USBCheckHIDRequest
000724 0104           02472         movlb   high 0x400              ; Point to proper bank
000726 50??           02473         movf    SetupPkt, W             ; Recipient = RCPT_INTF?
000728 0B1F           02474         andlw   0x1f                    ; Mask to lower 5 bits
00072A 0801           02475         sublw   RCPT_INTF
00072C E0??           02476         bz      USBCheckHIDRequest01    ; Yes
00072E                02477 USBCheckHIDRequestExit
00072E 0012           02478         return                          ; No: exit without setting session owner,
                      02479                                         ; which causes peripheral to STALL, signalling
                      02480                                         ; that this request is not supported
                      02481 
000730                02482 USBCheckHIDRequest01
                      02483 ;
                      02484 ; There are two standard requests that hid.c may support.
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 59


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02485 ; 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
                      02486 ; 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
                      02487 ;
000730 0E06           02488         movlw   GET_DSC                 ; Request = GET_DSC?
000732 62??           02489         cpfseq  SetupPkt + bRequest
000734 D???           02490         bra     USBCheckHIDRequestClass ; No
000736 0E21           02491         movlw   DSC_HID                 ; DscType = DSC_HID?
000738 62??           02492         cpfseq  SetupPkt + bDscType
00073A D???           02493         bra     USBCheckHIDRequest1     ; No
                      02494         mSetSourcePointer HID0
00073C 0E??               M         movlw   low (HID0)
00073E 6E??               M         movwf   pSrc
000740 0E??               M         movlw   high (HID0)
000742 6E??               M         movwf   pSrc + 1
                      02495         mGetRomTableCount               ; Set wCount
000744 C??? FFF6          M         movff   pSrc, TBLPTRL           ; Set source address
000748 C??? FFF7          M         movff   pSrc + 1, TBLPTRH
00074C 6AF8               M         clrf    TBLPTRU
00074E 0008               M         tblrd   *                       ; Read count
000750 CFF5 F???          M         movff   TABLAT, wCount
000754 6A??               M         clrf    wCount + 1
000756 82??           02496         bsf     usb_stat, ctrl_trf_mem  ; Indicate ROM
000758 D???           02497         bra     USBHIDSetSessionOwner
00075A                02498 USBCheckHIDRequest1
00075A 0E22           02499         movlw   DSC_RPT                 ; DscType = DSC_RPT?
00075C 62??           02500         cpfseq  SetupPkt + bDscType
00075E D???           02501         bra     USBCheckHIDRequest2     ; No
                      02502 ; Set up to return the requested Report Descriptor
                      02503 ;
                      02504 ; New code: table driven
                      02505 ; First, choose correct table based on which Configuration we are in
                      02506 ; See which Configuration we have to initialize: some projects may have 2 Configurations
000760 6A??           02507         clrf    usb_temp                ; Start with RD table entry no. 0
000762 0E02           02508   movlw   2                       ; Config no. 2?
000764 62??           02509   cpfseq  usb_active_cfg
000766 D???           02510   bra     SetC1_RDTable              ; No
                      02511 ; Set up for Config 2
000768 0E??           02512         movlw   low C2_RD_Table ; Point to C2_RDTable in DESCRIPT.ASM
00076A 6EF6           02513         movwf   TBLPTRL
00076C 0E??           02514         movlw   high C2_RD_Table
00076E D???           02515         bra     CheckRDT_NumEntries
000770                02516 SetC1_RDTable
000770 0E??           02517         movlw   low C1_RD_Table ; Point to C1RDTable in DESCRIPT.ASM
000772 6EF6           02518         movwf   TBLPTRL
000774 0E??           02519         movlw   high C1_RD_Table
000776                02520 CheckRDT_NumEntries
000776 6EF7           02521         movwf   TBLPTRH
000778 6AF8           02522         clrf    TBLPTRU
00077A 0009           02523         tblrd   *+                      ; Read number of entries
00077C CFF5 F???      02524         movff   TABLAT, usb_temp + 1    ; Save it somewhere
000780 0009           02525         tblrd   *+                      ; Skip next location
000782 50??           02526   movf     usb_temp + 1, W            ; Does this Config even HAVE any entries?
000784 B4D8           02527   btfsc    STATUS, Z
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 60


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000786 D???           02528   bra     USBCheckHIDRequestExit  ; No, exit and send a STALL
000788                02529 FindRDEntryLoop
000788 0009           02530         tblrd   *+                      ; Read Interface number of this entry
00078A 50F5           02531   movf    TABLAT, W
                      02532 ;  subwf   SetupPkt + bIntfID      ; Is it the Interface we are after?
00078C 5C??           02533   subwf   (SetupPkt + bIntfID),W      ; Is it the Interface we are after?
00078E E0??           02534   bz      FoundRightIntfEntry     ; Yes, process it
                      02535 ; No, bump table pointer to next entry, if there is one
000790 4E??           02536   dcfsnz  usb_temp + 1
000792 D???           02537   bra     USBCheckHIDRequestExit  ; Entry not found, so exit and send a STALL
000794 0009           02538         tblrd   *+                      ; Advance past RETLW opcode
000796 0009           02539         tblrd   *+                      ; Skip next location: low RD_size
000798 0009           02540         tblrd   *+                      ; Skip next location: RETLW opcode
00079A 0009           02541         tblrd   *+                      ; Skip next location: high RD_size
00079C 0009           02542         tblrd   *+                      ; Skip next location: RETLW opcode
00079E 0009           02543         tblrd   *+                      ; Skip next location: low RD_Address
0007A0 0009           02544         tblrd   *+                      ; Skip next location: RETLW opcode
0007A2 0009           02545         tblrd   *+                      ; Skip next location: low RD_Address
0007A4 0009           02546         tblrd   *+                      ; Skip next location: RETLW opcode
0007A6 D???           02547         bra     FindRDEntryLoop
0007A8                02548 FoundRightIntfEntry
0007A8 0009           02549         tblrd   *+                      ; Advance past RETLW opcode
0007AA 0009           02550         tblrd   *+                      ; Read low RD_size
0007AC CFF5 F???      02551         movff   TABLAT, wCount
0007B0 0009           02552         tblrd   *+                      ; Skip RETLW opcode
0007B2 0009           02553         tblrd   *+                      ; Read high RD_size
0007B4 CFF5 F???      02554         movff   TABLAT, wCount + 1
0007B8 0009           02555         tblrd   *+                      ; Skip RETLW opcode
0007BA 0009           02556         tblrd   *+                      ; Read low RD_Address
0007BC CFF5 F???      02557         movff   TABLAT, pSrc
0007C0 0009           02558         tblrd   *+                      ; Skip RETLW opcode
0007C2 0009           02559         tblrd   *+                      ; Read high RD_Address
0007C4 CFF5 F???      02560         movff   TABLAT, pSrc + 1
0007C8 82??           02561         bsf     usb_stat, ctrl_trf_mem  ; Indicate ROM
0007CA D???           02562         bra     USBHIDSetSessionOwner   ; Go here to indicate the USB request has succeeded
                      02563 
                      02564 
0007CC                02565 USBCheckHIDRequest2
                      02566 ;       movlw   DSC_PHY                 ; DscType = DSC_PHY?
                      02567 ;       cpfseq  SetupPkt + bDscType
                      02568 ;       return                          ; No
0007CC                02569 USBCheckHIDRequestClass
0007CC 50??           02570         movf    SetupPkt, W             ; RequestType = CLASS?
0007CE 0B60           02571         andlw   0x60                    ; Mask to proper bits
0007D0 0820           02572         sublw   (CLASS) << 5
0007D2 E1??           02573         bnz     USBCheckHIDRequestExit  ; No
                      02574 
                      02575 #ifdef  HID_SUPPORT_GET_SET_REPORT
                      02576 ; Added for HIDmaker
                      02577         movlw   SET_REPORT              ; Request = SET_REPORT?
                      02578         subwf   SetupPkt + bRequest, W
                      02579         bz      HIDSetReportHandler     ; Yes
                      02580         movlw   GET_REPORT              ; Request = GET_REPORT?
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 61


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02581         subwf   SetupPkt + bRequest, W
                      02582         bz      HIDGetReportHandler     ; Yes
                      02583 #endif
                      02584 
0007D4 0E02           02585         movlw   GET_IDLE                ; Request = GET_IDLE?
0007D6 62??           02586         cpfseq  SetupPkt + bRequest
0007D8 D???           02587         bra     USBCheckHIDRequestClass1        ; No
                      02588         mSetSourcePointer HLL_IdleRate
0007DA 0E??               M         movlw   low (HLL_IdleRate)
0007DC 6E??               M         movwf   pSrc
0007DE 0E??               M         movlw   high (HLL_IdleRate)
0007E0 6E??               M         movwf   pSrc + 1
0007E2 0E01           02589         movlw   1
0007E4 6E??           02590         movwf   wCount
0007E6 6A??           02591         clrf    wCount + 1
0007E8 92??           02592         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
0007EA D???           02593         bra     USBHIDSetSessionOwner
0007EC                02594 USBCheckHIDRequestClass1
0007EC 0E0A           02595         movlw   SET_IDLE                ; Request = SET_IDLE?
0007EE 62??           02596         cpfseq  SetupPkt + bRequest
0007F0 D???           02597         bra     USBCheckHIDRequestClass2        ; No
0007F2 C??? F???      02598         movff   SetupPkt + wValueHi, HLL_IdleRate   ; Copy to vars in PBP prog
0007F6 D???           02599         bra     USBHIDSetSessionOwner
0007F8                02600 USBCheckHIDRequestClass2
0007F8 0E03           02601         movlw   GET_PROTOCOL            ; Request = GET_PROTOCOL?
0007FA 62??           02602         cpfseq  SetupPkt + bRequest
0007FC D???           02603         bra     USBCheckHIDRequestClass3        ; No
                      02604         mSetSourcePointer HLL_ActiveProtocol
0007FE 0E??               M         movlw   low (HLL_ActiveProtocol)
000800 6E??               M         movwf   pSrc
000802 0E??               M         movlw   high (HLL_ActiveProtocol)
000804 6E??               M         movwf   pSrc + 1
000806 0E01           02605         movlw   1
000808 6E??           02606         movwf   wCount
00080A 6A??           02607         clrf    wCount + 1
00080C 92??           02608         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
00080E D???           02609         bra     USBHIDSetSessionOwner
000810                02610 USBCheckHIDRequestClass3
000810 0E0B           02611         movlw   SET_PROTOCOL            ; Request = SET_PROTOCOL?
000812 62??           02612         cpfseq  SetupPkt + bRequest
000814 0012           02613         return                          ; No
000816 C??? F???      02614         movff   SetupPkt + wValue, HLL_ActiveProtocol   ; Copy to vars in PBP prog
00081A                02615 USBHIDSetSessionOwner
00081A 0E02           02616         movlw   MUID_HID
00081C 6E??           02617         movwf   ctrl_trf_session_owner
00081E 0012           02618         return
                      02619 
                      02620 #ifdef  HID_SUPPORT_GET_SET_REPORT
                      02621 
                      02622 ; Handle a SET_REPORT request by setting some variables, that will be used
                      02623 ; at the next OUT transaction.
                      02624 HIDSetReportHandler
                      02625         setf    SetRptInProgress
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 62


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02626         setf    FirstPacket
                      02627         movff   SetupPkt + bReportID, RptID
                      02628         movff   SetupPkt + bReportType, RptType
                      02629         movff   SetupPkt + bIntfID, RptInterfaceNum
                      02630         movff   usb_active_cfg, RptConfigNum
                      02631 ; We may need to do something here, to enable the OUT transaction. Not sure...
                      02632         bra     USBHIDSetSessionOwner
                      02633 
                      02634 ; Handle a GET_REPORT request by setting some variables, and then calling
                      02635 ; a PBP routine to pack the first packet of data
                      02636 HIDGetReportHandler
                      02637         movff   SetupPkt + bReportID, RptID
                      02638         movff   SetupPkt + bReportType, RptType
                      02639         movff   SetupPkt + bIntfID, RptInterfaceNum
                      02640         movff   usb_active_cfg, RptConfigNum
                      02641         setf    GetRptInProgress
                      02642         setf    FirstPacket
                      02643 ;
                      02644         bra     USBHIDSetSessionOwner
                      02645 
                      02646 #endif
                      02647 
                      02648 
                      02649 #endif  ; USB_USE_HID
                      02650 
                      02651 
                      02652 
                      02653 #ifdef USB_USE_CDC
                      02654 
                      02655 ;/******************************************************************************
                      02656 ; * Function:        void USBCheckCDCRequest(void)
                      02657 ; *
                      02658 ; * PreCondition:    None
                      02659 ; *
                      02660 ; * Input:           None
                      02661 ; *
                      02662 ; * Output:          None
                      02663 ; *
                      02664 ; * Side Effects:    None
                      02665 ; *
                      02666 ; * Overview:        This routine checks the setup data packet to see if it
                      02667 ; *                  knows how to handle it
                      02668 ; *
                      02669 ; * Note:            None
                      02670 ; *****************************************************************************/
                      02671 USBCheckCDCRequest
                      02672 ;    /*
                      02673 ;     * If request recipient is not an interface then return
                      02674 ;     */
                      02675         movlb   high 0x400              ; Point to proper bank
                      02676         movf    SetupPkt, W             ; Recipient = RCPT_INTF?
                      02677         andlw   0x1f                    ; Mask to lower 5 bits
                      02678         sublw   RCPT_INTF
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 63


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02679         bnz     USBCheckCDCRequestExit  ; No
                      02680 
                      02681 ;    /*
                      02682 ;     * If request type is not class-specific then return
                      02683 ;     */
                      02684         movf    SetupPkt, W             ; RequestType = CLASS?
                      02685         andlw   0x60                    ; Mask to proper bits
                      02686         sublw   (CLASS) << 5
                      02687         bnz     USBCheckCDCRequestExit  ; No
                      02688 
                      02689 ;    /*
                      02690 ;     * Interface ID must match interface numbers associated with
                      02691 ;     * CDC class, else return
                      02692 ;     */
                      02693         movlw   CDC_COMM_INTF_ID        ; IntfID = CDC_COMM_INTF_ID?
                      02694         subwf   SetupPkt + bIntfID, W
                      02695         bz      USBCheckCDCRequest1     ; Yes
                      02696         movlw   CDC_DATA_INTF_ID        ; IntfID = CDC_DATA_INTF_ID?
                      02697         cpfseq  SetupPkt + bIntfID
                      02698 USBCheckCDCRequestExit
                      02699         return                          ; No
                      02700 
                      02701 USBCheckCDCRequest1
                      02702         movlw   SEND_ENCAPSULATED_COMMAND       ; Request = SEND_ENCAPSULATED_COMMAND?
                      02703         cpfseq  SetupPkt + bRequest
                      02704         bra     USBCheckCDCRequest2     ; No
                      02705         mSetSourcePointer dummy_encapsulated_cmd_response
                      02706         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
                      02707         movlw   dummy_length
                      02708         movwf   wCount
                      02709         clrf    wCount + 1
                      02710         bra     USBCDCSetSessionOwner
                      02711 USBCheckCDCRequest2
                      02712         movlw   GET_ENCAPSULATED_RESPONSE       ; Request = GET_ENCAPSULATED_RESPONSE?
                      02713         cpfseq  SetupPkt + bRequest
                      02714         bra     USBCheckCDCRequest3     ; No
                      02715 ;       // Populate dummy_encapsulated_cmd_response first.
                      02716         mSetDestinationPointer dummy_encapsulated_cmd_response
                      02717         bra     USBCDCSetSessionOwner
                      02718 USBCheckCDCRequest3
                      02719         movlw   SET_COMM_FEATURE        ; Request = SET_COMM_FEATURE?
                      02720         cpfseq  SetupPkt + bRequest
                      02721         bra     USBCheckCDCRequest4     ; No
                      02722         return                          ; Optional
                      02723 USBCheckCDCRequest4
                      02724         movlw   GET_COMM_FEATURE        ; Request = GET_COMM_FEATURE?
                      02725         cpfseq  SetupPkt + bRequest
                      02726         bra     USBCheckCDCRequest5     ; No
                      02727         return                          ; Optional
                      02728 USBCheckCDCRequest5
                      02729         movlw   CLEAR_COMM_FEATURE      ; Request = CLEAR_COMM_FEATURE?
                      02730         cpfseq  SetupPkt + bRequest
                      02731         bra     USBCheckCDCRequest6     ; No
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 64


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02732         return                          ; Optional
                      02733 USBCheckCDCRequest6
                      02734         movlw   SET_LINE_CODING         ; Request = SET_LINE_CODING?
                      02735         cpfseq  SetupPkt + bRequest
                      02736         bra     USBCheckCDCRequest7     ; No
                      02737         mSetDestinationPointer line_coding
                      02738         bra     USBCDCSetSessionOwner
                      02739 USBCheckCDCRequest7
                      02740         movlw   GET_LINE_CODING         ; Request = GET_LINE_CODING?
                      02741         cpfseq  SetupPkt + bRequest
                      02742         bra     USBCheckCDCRequest8     ; No
                      02743         ; Abstract line coding information
                      02744         movlw   low 115200              ; baud rate
                      02745         movwf   line_coding + dwDTERate
                      02746         movlw   high 115200
                      02747         movwf   line_coding + dwDTERate + 1
                      02748         movlw   upper 115200
                      02749         movwf   line_coding + dwDTERate + 2
                      02750         clrf    line_coding + dwDTERate + 3
                      02751         clrf    line_coding + bCharFormat       ; 1 stop bit
                      02752         clrf    line_coding + bParityType       ; None
                      02753         movlw   8
                      02754         movwf   line_coding + bDataBits ; 5,6,7,8, or 16
                      02755         mSetSourcePointer line_coding
                      02756         bcf     usb_stat, ctrl_trf_mem  ; Indicate RAM
                      02757         movlw   LINE_CODING_LENGTH
                      02758         movwf   wCount
                      02759         clrf    wCount + 1
                      02760         bra     USBCDCSetSessionOwner
                      02761 USBCheckCDCRequest8
                      02762         movlw   SET_CONTROL_LINE_STATE  ; Request = SET_CONTROL_LINE_STATE?
                      02763         cpfseq  SetupPkt + bRequest
                      02764         bra     USBCheckCDCRequest9     ; No
                      02765         movff   SetupPkt + wValue, control_signal_bitmap
                      02766         bra     USBCDCSetSessionOwner
                      02767 USBCheckCDCRequest9
                      02768         movlw   SEND_BREAK              ; Request = SEND_BREAK?
                      02769         cpfseq  SetupPkt + bRequest
                      02770         bra     USBCheckCDCRequest10    ; No
                      02771         return                          ; Optional
                      02772 USBCheckCDCRequest10
                      02773         return                          ; Default
                      02774 USBCDCSetSessionOwner
                      02775         movlw   MUID_CDC
                      02776         movwf   ctrl_trf_session_owner
                      02777         return
                      02778 
                      02779 
                      02780 ;/******************************************************************************
                      02781 ; * Function:        void CDCInitEP(void)
                      02782 ; *
                      02783 ; * PreCondition:    None
                      02784 ; *
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 65


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02785 ; * Input:           None
                      02786 ; *
                      02787 ; * Output:          None
                      02788 ; *
                      02789 ; * Side Effects:    None
                      02790 ; *
                      02791 ; * Overview:        CDCInitEP initializes CDC endpoints, buffer descriptors,
                      02792 ; *                  internal state-machine, and variables.
                      02793 ; *                  It should be called after the USB host has sent out a
                      02794 ; *                  SET_CONFIGURATION request.
                      02795 ; *                  See USBStdSetCfgHandler() in usb9.c for examples.
                      02796 ; *
                      02797 ; * Note:            None
                      02798 ; *****************************************************************************/
                      02799 ;CDCInitEP
                      02800 ;       movlw   2                       ; Endpoint 2 In
                      02801 ;       movwf   FSR0L
                      02802 ;       lfsr    1, cdc_notice           ; FSR1 = endpoint buffer address
                      02803 ;       movlw   CDC_INT_EP_SIZE         ; W = endpoint size
                      02804 ;       rcall   InitEPIn                ; Inititalize the endpoint
                      02805 
                      02806 ;       movlw   3                       ; Endpoint 3
                      02807 ;       movwf   FSR0L
                      02808 ;       lfsr    1, cdc_data_rx          ; FSR1 = endpoint buffer address
                      02809 ;       movlw   CDC_BULK_OUT_EP_SIZE    ; W = endpoint size
                      02810 ;       rcall   InitEPOut               ; Inititalize the endpoint
                      02811 
                      02812 ;       movlw   3                       ; Endpoint 3 In
                      02813 ;       movwf   FSR0L
                      02814 ;       lfsr    1, cdc_data_tx          ; FSR1 = endpoint buffer address
                      02815 ;       movlw   CDC_BULK_IN_EP_SIZE     ; W = endpoint size
                      02816 ;       bra     InitEPIn                ; Inititalize the endpoint
                      02817 
                      02818 #endif  ; USB_USE_CDC
                      02819 
                      02820 
                      02821 ; Generic code for use by all the classes
                      02822 
                      02823 ; InitEPIn
                      02824 ;  Generic initialize In endpoint
                      02825 ; Input:
                      02826 ;  FSR0L is endpoint number
                      02827 ;  FSR1 is endpoint buffer address
                      02828 ;  W is endpoint buffer size
                      02829 ; Returns:
                      02830 ;  Nada
                      02831 ; Uses
                      02832 ;  FSR0 is BDT pointer
                      02833 ;  FSR1 is endpoint buffer pointer
                      02834 ;  FSR2 is endpoint table pointer
                      02835 
000820                02836 InitEPIn
                      02837 ; Save maximum count at front of endpoint buffer and move buffer pointer up (no need to put in Cnt for I
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 66


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            n)
000820 6EE6           02838         movwf   POSTINC1                ; Store maximum count at front of endpoint buffer and move up po
                            inter
                      02839 
                      02840 ; Need to zero the in-process flag at buffer address + MaxCount + 4
000822 0F04           02841   addlw 4
000824 6AE3           02842   clrf  PLUSW1
                      02843 
                      02844 ; Point FSR2 to endpoint table
000826 EE2F F070      02845         lfsr    2, UEP0
00082A 50E9           02846         movf    FSR0L, W                ; Add in endpoint number
00082C 26D9           02847         addwf   FSR2L, F
                      02848 
                      02849 ; Enable In endpoint
00082E 0E1A           02850         movlw   EP_IN|HSHK_EN           ; Enable In pipe
000830 12DF           02851         iorwf   INDF2, F
                      02852 
                      02853 ; Point FSR0 to endpoint BDT
000832 44E9           02854         rlncf   FSR0L, W                ; Endpoint number * 8
000834 46E8           02855         rlncf   WREG, F
000836 46E8           02856         rlncf   WREG, F
000838 EE?? F0??      02857         lfsr    0, ep0Bi                ; Point FSR0 to beginning of BDT area
00083C 26E9           02858         addwf   FSR0L, F                ; Add endpoint offset to FSR0 (can't overflow to FSR0H)
                      02859 
                      02860 ; Set endpoint buffer address from FSR1
00083E 0E02           02861         movlw   ADRL                    ; Point to ADRL
000840 CFE1 FFEB      02862         movff   FSR1L, PLUSW0
000844 0E03           02863         movlw   ADRH                    ; Point to ADRH
000846 CFE2 FFEB      02864         movff   FSR1H, PLUSW0
                      02865 
                      02866 ; Set endpoint status
00084A 0E40           02867         movlw   _UCPU|_DAT1             ; Set transmit status
00084C 6EEF           02868         movwf   INDF0                   ; Set Stat
00084E 0012           02869         return
                      02870 
                      02871 
                      02872 ; InitEPOut
                      02873 ;  Generic initialize Out endpoint
                      02874 ; Input:
                      02875 ;  FSR0L is endpoint number
                      02876 ;  FSR1 is endpoint buffer address
                      02877 ;  W is endpoint buffer size
                      02878 ; Returns:
                      02879 ;  Nada
                      02880 ; Uses
                      02881 ;  FSR0 is BDT pointer
                      02882 ;  FSR1 is endpoint buffer pointer
                      02883 ;  FSR2 is endpoint table pointer
                      02884 
000850                02885 InitEPOut
                      02886 ; Save maximum count at front of endpoint buffer and move buffer pointer up
000850 6EE6           02887         movwf   POSTINC1                ; Store maximum count at front of endpoint buffer and move up po
                            inter
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 67


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02888 
                      02889 ; Need to zero the in-process flag at buffer address + MaxCount + 4
000852 0F04           02890   addlw 4
000854 6AE3           02891   clrf  PLUSW1
                      02892 
                      02893 ; Point FSR2 to endpoint table
000856 EE2F F070      02894         lfsr    2, UEP0
00085A 50E9           02895         movf    FSR0L, W                ; Add in endpoint number
00085C 26D9           02896         addwf   FSR2L, F
                      02897 
                      02898 ; Enable Out endpoint
00085E 0E1C           02899         movlw   EP_OUT|HSHK_EN          ; Enable Out pipe
000860 12DF           02900         iorwf   INDF2, F
                      02901 
                      02902 ; Point FSR0 to endpoint BDT
000862 44E9           02903         rlncf   FSR0L, W                ; Endpoint number * 8
000864 46E8           02904         rlncf   WREG, F
000866 46E8           02905         rlncf   WREG, F
000868 EE?? F0??      02906         lfsr    0, ep0Bo                ; Point FSR0 to beginning of BDT area
00086C 26E9           02907         addwf   FSR0L, F                ; Add endpoint offset to FSR0 (can't overflow to FSR0H)
                      02908 
                      02909 ; Set endpoint buffer address from FSR1 + 1
00086E 0E02           02910         movlw   ADRL                    ; Point to ADRL
000870 CFE1 FFEB      02911         movff   FSR1L, PLUSW0
000874 0E03           02912         movlw   ADRH                    ; Point to ADRH
000876 CFE2 FFEB      02913         movff   FSR1H, PLUSW0
                      02914 
                      02915 ; Set Cnt to maximum count
00087A 50E5           02916         movf    POSTDEC1, W             ; Back up endpoint buffer pointer (no PREDEC1!)
00087C 2AE9           02917         incf    FSR0L, F                ; Point to Cnt
00087E CFE7 FFED      02918         movff   INDF1, POSTDEC0         ; Set maximum count and point back to Stat
                      02919 
                      02920 ; Set endpoint status
000882 0E88           02921         movlw   _USIE|_DAT0|_DTSEN      ; Set receive status
000884 6EEF           02922         movwf   INDF0                   ; Set Stat
000886 0012           02923         return
                      02924 
                      02925 
                      02926 ;/******************************************************************************
                      02927 ; * Function:        PutUSB
                      02928 ; *
                      02929 ; * PreCondition:    None
                      02930 ; *
                      02931 ; * Input:           FSR0L is endpoint number
                      02932 ; *                  FSR1 is source buffer pointer
                      02933 ; *                  W is count
                      02934 ; *
                      02935 ; * Output:          FSR1 is updated source buffer pointer
                      02936 ; *                  W returns number sent
                      02937 ; *                  Carry is clear for buffer not available
                      02938 ; *
                      02939 ; * Uses:            FSR0 is BDT pointer
                      02940 ; *                  FSR1 is source buffer pointer
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 68


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02941 ; *                  FSR2 is endpoint buffer pointer
                      02942 ; *                  R0 in BANKA is temporary length storage
                      02943 ; *
                      02944 ; * Side Effects:    
                      02945 ; *
                      02946 ; * Overview:        Generic fill In endpoint for TX
                      02947 ; *
                      02948 ; * Note:            None
                      02949 ; *****************************************************************************/
                      02950 ; PutUSB
                      02951 ;  Generic fill In endpoint for TX
                      02952 ; Input:
                      02953 ;  FSR0L is endpoint number
                      02954 ;  FSR1 is source buffer pointer
                      02955 ;  W is count
                      02956 ; Returns:
                      02957 ;  FSR1 is updated source buffer pointer
                      02958 ;  W returns number sent
                      02959 ;  Carry is clear for buffer not available
                      02960 ; Uses:
                      02961 ;  FSR0 is BDT pointer
                      02962 ;  FSR1 is source buffer pointer
                      02963 ;  FSR2 is endpoint buffer pointer
                      02964 ;  R0 in BANKA is temporary length storage
                      02965 
000888                02966 PutUSB
000888 6E??           02967         movwf   R0                      ; Save count
                      02968 
                      02969 ; Check to see if we're configured
00088A 0104           02970         movlb   high 0x400              ; Point to proper bank
00088C 0E06           02971         movlw   CONFIGURED_STATE        ; We might not be configured yet
00088E 5C??           02972         subwf   usb_device_state, W
000890 0E00           02973         movlw   0                       ; 0 characters sent, so far
000892 90D8           02974         bcf     STATUS, C               ; Clear Carry for possible error return
000894 E1??           02975         bnz     PutUSBNotReady          ; We're not configured
                      02976 
                      02977 ; Point FSR0 to requested endpoint In BDT
000896 44E9           02978         rlncf   FSR0L, W                ; Endpoint number * 8
000898 46E8           02979         rlncf   WREG, F
00089A 46E8           02980         rlncf   WREG, F
00089C EE?? F0??      02981         lfsr    0, ep0Bi                ; Point FSR0 to beginning of BDT area
0008A0 26E9           02982         addwf   FSR0L, F                ; Add endpoint offset to FSR0 (can't overflow to FSR0H)
                      02983 
0008A2 6AE8           02984         clrf    WREG                    ; 0 characters sent, so far
0008A4 90D8           02985         bcf     STATUS, C               ; Clear Carry for possible error return
0008A6 BEEF           02986         btfsc   INDF0, UOWN             ; Who owns the buffer (Stat, UOWN)?
0008A8                02987 PutUSBNotReady
0008A8 0012           02988         return                          ; Busy (we don't)
                      02989 
                      02990 ; Get endpoint buffer address to FSR2
0008AA 0E02           02991         movlw   ADRL                    ; Point to ADRL
0008AC CFEB FFD9      02992         movff   PLUSW0, FSR2L
0008B0 0E03           02993         movlw   ADRH                    ; Point to ADRH
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 69


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0008B2 CFEB FFDA      02994         movff   PLUSW0, FSR2H
                      02995 
0008B6 0EFF           02996         movlw   -1
0008B8 50DB           02997         movf    PLUSW2, W               ; Get maximum length from in front of endpoint buffer
                      02998 
0008BA 60??           02999         cpfslt  R0                      ; Find number of bytes to send this time
0008BC 6E??           03000         movwf   R0                      ; Too big - send maximum allowed length
                      03001 
0008BE 2AE9           03002         incf    FSR0L, F                ; Point to Cnt
0008C0 50??           03003         movf    R0, W                   ; Get number to send
0008C2 6EED           03004         movwf   POSTDEC0                ; Put length into Cnt and point back to Stat
0008C4 E0??           03005         bz      PutUSBZero              ; Zero to send
                      03006 
0008C6                03007 PutUSBRamLoop
0008C6 CFE6 FFDE      03008         movff   POSTINC1, POSTINC2      ; Copy source buffer to endpoint buffer
0008CA 2EE8           03009         decfsz  WREG, F                 ; Count down number of bytes to transfer
0008CC D???           03010         bra     PutUSBRamLoop
                      03011 
0008CE                03012 PutUSBZero
0008CE 0E40           03013         movlw   _DTSMASK                ; Save only DTS bit
0008D0 16EF           03014         andwf   INDF0, F
0008D2 7CEF           03015         btg     INDF0, DTS              ; Toggle DTS bit
0008D4 0E88           03016         movlw   _USIE|_DTSEN            ; Turn ownership to SIE
0008D6 12EF           03017         iorwf   INDF0, F
0008D8 50??           03018         movf    R0, W                   ; Return number of bytes sent
0008DA 80D8           03019         bsf     STATUS, C               ; Set Carry for non-error return
0008DC 0012           03020         return
                      03021 
                      03022 
                      03023 ;/******************************************************************************
                      03024 ; * Function:        GetUSB
                      03025 ; *
                      03026 ; * PreCondition:    None
                      03027 ; *
                      03028 ; * Input:           FSR0L is endpoint number
                      03029 ; *                  FSR1 is destination buffer pointer
                      03030 ; *                  W is max buffer length
                      03031 ; *
                      03032 ; * Output:          FSR1 is updated destination buffer pointer
                      03033 ; *                  W returns number received
                      03034 ; *                  Carry is clear for buffer not available
                      03035 ; *
                      03036 ; * Uses:            FSR0 is BDT pointer
                      03037 ; *                  FSR1 is destination buffer pointer
                      03038 ; *                  FSR2 is endpoint buffer pointer
                      03039 ; *                  R0 in BANKA is temporary length storage
                      03040 ; *
                      03041 ; * Side Effects:    
                      03042 ; *
                      03043 ; * Overview:        Generic get from Out endpoint for RX
                      03044 ; *
                      03045 ; * Note:            None
                      03046 ; *****************************************************************************/
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 70


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03047 ; GetUSB
                      03048 ;  Generic get from Out endpoint for RX
                      03049 ; Input:
                      03050 ;  FSR0L is endpoint number
                      03051 ;  FSR1 is destination buffer pointer
                      03052 ;  W is max buffer length
                      03053 ; Returns:
                      03054 ;  FSR1 is updated destination buffer pointer
                      03055 ;  W returns number received
                      03056 ;  Carry is clear for buffer not available
                      03057 ; Uses
                      03058 ;  FSR0 is BDT pointer
                      03059 ;  FSR1 is destination buffer pointer
                      03060 ;  FSR2 is endpoint buffer pointer
                      03061 ;  R0 in BANKA is temporary length storage
                      03062 
0008DE                03063 GetUSB
0008DE 6E??           03064         movwf   R0                      ; Save max buffer length
                      03065 
                      03066 ; Check to see if we're configured
0008E0 0104           03067         movlb   high 0x400              ; Point to proper bank
0008E2 0E06           03068         movlw   CONFIGURED_STATE        ; We might not be configured yet
0008E4 5C??           03069         subwf   usb_device_state, W
0008E6 0E00           03070         movlw   0                       ; 0 characters sent, so far
0008E8 90D8           03071         bcf     STATUS, C               ; Clear Carry for possible error return
0008EA E1??           03072         bnz     GetUSBNotReady          ; We're not configured
                      03073 
                      03074 ; Point FSR0 to requested endpoint Out BDT
0008EC 44E9           03075         rlncf   FSR0L, W                ; Endpoint number * 8
0008EE 46E8           03076         rlncf   WREG, F
0008F0 46E8           03077         rlncf   WREG, F
0008F2 EE?? F0??      03078         lfsr    0, ep0Bo                ; Point FSR0 to beginning of BDT area
0008F6 26E9           03079         addwf   FSR0L, F                ; Add endpoint offset to FSR0 (can't overflow to FSR0H)
                      03080 
0008F8 6AE8           03081         clrf    WREG                    ; 0 characters received, so far
0008FA 90D8           03082         bcf     STATUS, C               ; Clear Carry for possible error return
0008FC BEEF           03083         btfsc   INDF0, UOWN             ; Who owns the buffer (Stat, UOWN)?
0008FE                03084 GetUSBNotReady
0008FE 0012           03085         return                          ; Busy (we don't)
                      03086 
                      03087 ; Get endpoint buffer address to FSR2
000900 0E02           03088         movlw   ADRL                    ; Point to ADRL
000902 CFEB FFD9      03089         movff   PLUSW0, FSR2L
000906 0E03           03090         movlw   ADRH                    ; Point to ADRH
000908 CFEB FFDA      03091         movff   PLUSW0, FSR2H
                      03092 
00090C 50EC           03093         movf    PREINC0, W              ; Get Cnt
00090E 60??           03094         cpfslt  R0                      ; Make sure it's not longer than the buffer
000910 6E??           03095         movwf   R0                      ; It's OK, save returned length
                      03096 
000912 0EFF           03097         movlw   -1
000914 50DB           03098         movf    PLUSW2, W               ; Get maximum length from in front of endpoint buffer
000916 6EED           03099         movwf   POSTDEC0                ; Reset max length and point back to Stat
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 71


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03100 
000918 50??           03101         movf    R0, W                   ; Get count to W
00091A E0??           03102         bz      GetUSBZero              ; Nothing received
                      03103 
00091C                03104 GetUSBRamLoop
00091C CFDE FFE6      03105         movff   POSTINC2, POSTINC1      ; Copy endpoint buffer to destination buffer
000920 2EE8           03106         decfsz  WREG, F                 ; Count down number of bytes
000922 D???           03107         bra     GetUSBRamLoop
                      03108 
000924                03109 GetUSBZero
000924 0E40           03110         movlw   _DTSMASK                ; Save only DTS bit
000926 16EF           03111         andwf   INDF0, F
000928 7CEF           03112         btg     INDF0, DTS              ; Toggle DTS bit
00092A 0E88           03113         movlw   _USIE|_DTSEN            ; Turn ownership to SIE
00092C 12EF           03114         iorwf   INDF0, F
00092E 50??           03115         movf    R0, W                   ; Return number of bytes received
000930 80D8           03116         bsf     STATUS, C               ; Set Carry for non-error return
000932 0012           03117         return
                      03118 
                      03119 
                      03120 ;/******************************************************************************
                      03121 ; * Function:        PackandShipPacket
                      03122 ; *
                      03123 ; * PreCondition:    In-process flag, located at EPnbuffer + <buffer size> + 5,
                      03124 ; *                  must be initialized to 0
                      03125 ; *
                      03126 ; * Input:           W contains EndPoint number
                      03127 ; *                  TBLPTRH/L is VarTable address
                      03128 ; *
                      03129 ; * Output:          Returns W = 0 when Report is all packed,
                      03130 ; *                              0x02 when EP is busy, and
                      03131 ; *                              0xFF if there are still more packets to go
                      03132 ; *
                      03133 ; * Side Effects:    None
                      03134 ; *
                      03135 ; * Overview:        Pack packet with data from VarTable and send to EndPoint
                      03136 ; *
                      03137 ; * Note:            Jeff's fifth version, 2/28/2005
                      03138 ; *****************************************************************************/
                      03139 ; Pack packet with data from VarTable and send to EndPoint
                      03140 ; W contains EndPoint number and TBLPTRH/L is VarTable address
000934                03141 PackandShipPacket
000934 0104           03142         movlb   high 0x400      ; Point to proper bank
000936 6E??           03143         movwf   TempByte        ; Save EndPoint number for the moment
                      03144 
                      03145 ; Check to see if we're configured
000938 0E06           03146         movlw   CONFIGURED_STATE
00093A 5C??           03147         subwf   usb_device_state, W
00093C 0E01           03148         movlw   0x01            ; We might not be configured yet
00093E E1??           03149         bnz     NotReady        ; We're not
                      03150 
                      03151 ; Point FSR0 to requested endpoint In BDT
000940 44??           03152         rlncf   TempByte, W     ; Endpoint number * 8
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 72


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000942 44E8           03153         rlncf   WREG, W
000944 44E8           03154         rlncf   WREG, W
000946 EE?? F0??      03155         lfsr    0, ep0Bi        ; Point FSR0 to beginning of BDT area
00094A 26E9           03156         addwf   FSR0L, F        ; Add endpoint offset to FSR0 (can't overflow to FSR0H)
                      03157 
                      03158 ; Check for EndPoint busy
00094C 0E02           03159         movlw   0x02            ; We might be busy
00094E BEEF           03160         btfsc   INDF0, UOWN     ; Who owns the buffer (Stat, UOWN)?
000950                03161 NotReady
000950 0012           03162         return                  ; Busy (we don't)
                      03163 
                      03164 ; Get a few things ready for packing
000952 6A??           03165         clrf    PacketByteIndex
000954 6A??           03166         clrf    PacketBitIndex
000956 6AF8           03167         clrf    TBLPTRU         ; Probably unnecessary
                      03168 
                      03169 ; Get packet size (need for PointToStorage, among other things)
000958 6AE8           03170         clrf    WREG            ; Point FSR2 to beginning of packet
00095A D???           03171         rcall   PointToPacket
00095C 50DD           03172         movf    POSTDEC2, W     ; Back up to right before packet
00095E CFDE F???      03173         movff   POSTINC2, MaxPacketSize ; Get packet size
                      03174 
                      03175 ; Check for first packet or in-process
000962 D???           03176         rcall   PointToStorage
000964 50DE           03177         movf    POSTINC2, W     ; Get last state
000966 E0??           03178         bz      VarLoop         ; If zero then first packet
                      03179 ; Check for ZLP???
                      03180 
                      03181 ; Packet in-process - recover last info
000968 CFDE FFF6      03182         movff   POSTINC2, TBLPTRL       ; Get pointer to VarTable
00096C CFDE FFF7      03183         movff   POSTINC2, TBLPTRH
000970 CFDE F???      03184         movff   POSTINC2, PacketByteIndex       ; Get next byte pointer
000974 CFDE F???      03185         movff   POSTINC2, PacketBitIndex        ; Get next bit pointer
                      03186 
000978 50??           03187         movf    MaxPacketSize, W        ; Get packet size for end of packet buffer address
00097A D???           03188         rcall   PointToPacket   ; Point to first old byte in packet
00097C CFD9 FFE1      03189         movff   FSR2L, FSR1L    ; Move source address to FSR1
000980 CFDA FFE2      03190         movff   FSR2H, FSR1H
000984 6AE8           03191         clrf    WREG            ; Point FSR2 to beginning of packet
000986 D???           03192         rcall   PointToPacket
                      03193 
000988 50??           03194         movf    MaxPacketSize, W        ; Find how many to move
00098A 5C??           03195         subwf   PacketByteIndex, W
00098C 6E??           03196         movwf   PacketByteIndex ; Save as new index while we're here
                      03197 ; Check for bad data???
00098E                03198 InProcessLoop
00098E CFE6 FFDE      03199         movff   POSTINC1, POSTINC2      ; Move a byte
000992 06E8           03200         decf    WREG, F         ; Count through 0
000994 E2??           03201         bc      InProcessLoop
                      03202 
                      03203 
                      03204 ; Get variable size and address
000996                03205 VarLoop
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 73


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000996 0009           03206         tblrd*+                 ; Read VarTable
000998 50F5           03207         movf    TABLAT, W
00099A E0??           03208         bz      TheEnd          ; At end of VarTable, send last packet
00099C 6E??           03209         movwf   VarSign         ; Save for sign and single bit indicator
00099E 0B3F           03210         andlw   0x3f            ; Mask to size
0009A0 6E??           03211         movwf   VarSize         ; Save size in total bits
0009A2 0B07           03212         andlw   0x07            ; Mask to number of bits only
0009A4 6E??           03213         movwf   VarBits
0009A6 40??           03214         rrncf   VarSize, W      ; Shift down to bytes
0009A8 40E8           03215         rrncf   WREG, W
0009AA 40E8           03216         rrncf   WREG, W
0009AC 0B07           03217         andlw   0x07            ; Mask to number of bytes only
0009AE 6E??           03218         movwf   VarBytes
0009B0 66??           03219         tstfsz  VarBits
0009B2 2A??           03220         incf    VarBytes, F     ; Adjust to actual bytes
0009B4 0009           03221         tblrd*+                 ; Read VarTable
0009B6 50F5           03222         movf    TABLAT, W
0009B8 6EE1           03223         movwf   FSR1L           ; Get address of variable to FSR1
0009BA 0009           03224         tblrd*+                 ; Read VarTable
0009BC 50F5           03225         movf    TABLAT, W
0009BE 6EE2           03226         movwf   FSR1H
                      03227 
0009C0 BC??           03228         btfsc   VarSign, 6      ; Is it a single bit?
0009C2 D???           03229         bra     OneBit          ; Yes
                      03230 
                      03231 ; Copy variable to packet
0009C4 50??           03232         movf    PacketByteIndex, W      ; Get current byte position
0009C6 66??           03233         tstfsz  PacketBitIndex
0009C8 28E8           03234         incf    WREG, W         ; Bump to next location if bits not 0
0009CA D???           03235         rcall   PointToPacket   ; Set destination address
                      03236 
0009CC 50??           03237         movf    VarBytes, W     ; How many to copy
0009CE                03238 copyvarloop
0009CE CFE6 FFDE      03239         movff   POSTINC1, POSTINC2      ; Do the copy
0009D2 2EE8           03240         decfsz  WREG, F
0009D4 D???           03241         bra     copyvarloop
                      03242 
                      03243 ; Shift bits to the right to fill in any holes
0009D6 50??           03244         movf    PacketBitIndex, W
0009D8 E0??           03245         bz      CalcNewIndexes  ; No shift necessary
0009DA 0808           03246         sublw   8               ; Calculate number of shifts necessary
0009DC 6E??           03247         movwf   TempCount
                      03248 
                      03249 ; Point to beginning of shift area in packet
0009DE 50??           03250         movf    PacketByteIndex, W
0009E0 D???           03251         rcall   PointToPacket
                      03252 
                      03253 ; Clear any extra junk from current byte in packet
0009E2 50??           03254         movf    PacketBitIndex, W       ; Find top bit number + 1
0009E4 D???           03255         rcall   GetMask         ; Get mask to W (wrecks TempByte)
0009E6 14DF           03256         andwf   INDF2, W        ; Mask off any extra bits and get to W
0009E8 6E??           03257         movwf   TempByte        ; Save it for or later
                      03258 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 74


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0009EA 6ADF           03259         clrf    INDF2           ; Start with nothing in byte 0
0009EC                03260 shiftloop
0009EC 50??           03261         movf    VarBytes, W     ; W = number of bytes to shift and byte pointer
0009EE                03262 shiftloop1
0009EE 32DB           03263         rrcf    PLUSW2, F       ; Shift a byte one bit to the right
0009F0 2CE8           03264         decfsz  WREG, W
0009F2 D???           03265         bra     shiftloop1      ; Shift all the bytes
0009F4 32DB           03266         rrcf    PLUSW2, F       ; Shift the 0th byte too
0009F6 2E??           03267         decfsz  TempCount, F
0009F8 D???           03268         bra     shiftloop       ; Shift all the bits
                      03269 
                      03270 ; Or original first byte into packet
0009FA 50??           03271         movf    TempByte, W     ; Get first byte
0009FC 12DF           03272         iorwf   INDF2, F        ; Or it into packet
                      03273 
                      03274 ; Calculate new indexes
0009FE                03275 CalcNewIndexes
0009FE 50??           03276         movf    VarSize, W      ; Get total bits in this variable
000A00 26??           03277         addwf   PacketBitIndex, F       ; Update bits
000A02                03278 CalcNewIndexesOneBit
000A02 30??           03279         rrcf    PacketBitIndex, W       ; Shift to get to bytes
000A04 30E8           03280         rrcf    WREG, W
000A06 30E8           03281         rrcf    WREG, W
000A08 0B07           03282         andlw   0x07            ; Mask to bytes
000A0A 26??           03283         addwf   PacketByteIndex, F
000A0C 0E07           03284         movlw   0x07            ; Mask to bits
000A0E 16??           03285         andwf   PacketBitIndex, F
                      03286 
                      03287 ; Does it fit in packet?  If not, we're done with this packet
000A10 50??           03288         movf    MaxPacketSize, W
000A12 5C??           03289         subwf   PacketByteIndex, W
000A14 E3??           03290         bnc     VarLoop         ; Go get next variable
000A16 E1??           03291         bnz     PacketFull
000A18 50??           03292         movf    PacketBitIndex, W       ; If Bit and Byte are zero, we want to get one more variable in 
                            here
000A1A E1??           03293     bnz PacketFull
000A1C D???           03294     bra VarLoop 
                      03295 
                      03296 ; Packet full - with more to come
000A1E                03297 PacketFull
000A1E D???           03298         rcall   SendPacket      ; Make it gone
000A20 D???           03299         rcall   PointToStorage
000A22 68E8           03300         setf    WREG            ; More packets to come
000A24 6EDE           03301         movwf   POSTINC2        ; Save marker
000A26 CFF6 FFDE      03302         movff   TBLPTRL, POSTINC2       ; Save pointer to VarTable
000A2A CFF7 FFDE      03303         movff   TBLPTRH, POSTINC2
000A2E C??? FFDE      03304         movff   PacketByteIndex, POSTINC2       ; Save next byte pointer
000A32 C??? FFDE      03305         movff   PacketBitIndex, POSTINC2        ; Save next bit pointer
000A36 0012           03306         return                  ; W still set to 0xff
                      03307 
                      03308 
                      03309 ; Data is a single bit - handle special case
000A38                03310 OneBit
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 75


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000A38 C??? F???      03311         movff   VarBits, TempByte       ; Get bit position in source
000A3C D???           03312         rcall   ConvertBit      ; Convert it to a single bit mask
000A3E 14E7           03313         andwf   INDF1, W        ; Mask to our bit
000A40 6E??           03314         movwf   VarBytes        ; Save the result (don't need VarBytes for bits)
                      03315 
000A42 50??           03316         movf    PacketByteIndex, W      ; Get destination address to FSR2
000A44 D???           03317         rcall   PointToPacket
000A46 C??? F???      03318         movff   PacketBitIndex, TempByte        ; Get bit position in destination
000A4A D???           03319         rcall   ConvertBit      ; Convert it to a single bit mask
000A4C 12DF           03320         iorwf   INDF2, F        ; Put bit into destination
000A4E 0AFF           03321         xorlw   0xff            ; Flip mask just in case
000A50 52??           03322         movf    VarBytes, F     ; Check source result
000A52 B4D8           03323         btfsc   STATUS, Z       ; Do we need to take it back out?
000A54 16DF           03324         andwf   INDF2, F        ; Take bit out of destination
                      03325 
000A56 2A??           03326         incf    PacketBitIndex, F       ; Add one to bits
000A58 D???           03327         bra     CalcNewIndexesOneBit    ; Finish updating indexes
                      03328 
                      03329 
                      03330 ; All variables packed
000A5A                03331 TheEnd
000A5A D???           03332         rcall   SendPacket      ; Make it gone
000A5C D???           03333         rcall   PointToStorage
                      03334 ; Send ZLP if last byte???
000A5E 6AE8           03335         clrf    WREG            ; This is the last packet
000A60 6EDE           03336         movwf   POSTINC2        ; Save marker
000A62 0012           03337         return
                      03338 
                      03339 
                      03340 ; Send the finished packet
000A64                03341 SendPacket
000A64 50??           03342         movf    PacketByteIndex, W      ; Set count
000A66 66??           03343         tstfsz  PacketBitIndex  ; Are we on the first bit?
000A68 28E8           03344         incf    WREG, W         ; No - bump count
000A6A 64??           03345         cpfsgt  MaxPacketSize   ; Bigger than max?
000A6C 50??           03346         movf    MaxPacketSize, W        ; Yes - set to max
000A6E 2AE9           03347         incf    FSR0L, F        ; Point to Cnt
000A70 6EED           03348         movwf   POSTDEC0        ; Put length into Cnt and point back to Stat
                      03349 ; Fall through to ReleaseBuffer
                      03350 
                      03351 
                      03352 ; Common Pack / Unpack subroutines below
                      03353 ;=======================================
                      03354 
                      03355 ; Set IN or OUT EP buffer loose
000A72                03356 ReleaseBuffer
000A72 0E40           03357         movlw   _DTSMASK        ; Save only DTS bit
000A74 16EF           03358         andwf   INDF0, F
000A76 7CEF           03359         btg     INDF0, DTS      ; Toggle DTS bit
000A78 0E88           03360         movlw   _USIE|_DTSEN    ; Turn ownership to SIE
000A7A 12EF           03361         iorwf   INDF0, F
000A7C 0012           03362         return
                      03363 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 76


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03364 
                      03365 ; Point FSR2 to storage at end of Packet
000A7E                03366 PointToStorage
000A7E 50??           03367         movf    MaxPacketSize, W        ; Get to end
000A80 0F04           03368         addlw   4               ; Move past shift area
                      03369 ; Fall through to PointToPacket
                      03370 
                      03371 ; Point FSR2 to byte W in Packet
000A82                03372 PointToPacket
000A82 6E??           03373         movwf   TempByte        ; Save offset for a moment
                      03374 ; Get endpoint buffer address to FSR2
000A84 0E02           03375         movlw   ADRL            ; Point to ADRL
000A86 CFEB FFD9      03376         movff   PLUSW0, FSR2L
000A8A 0E03           03377         movlw   ADRH            ; Point to ADRH
000A8C CFEB FFDA      03378         movff   PLUSW0, FSR2H
000A90 50??           03379         movf    TempByte, W     ; Retrieve offset
000A92 26D9           03380         addwf   FSR2L, F        ; Add offset
000A94 0E00           03381         movlw   0
000A96 22DA           03382         addwfc  FSR2H, F
000A98 0012           03383         return
                      03384 
                      03385 
                      03386 ; Create bit mask - W = top bit position + 1
000A9A                03387 GetMask
000A9A 6A??           03388         clrf    TempByte        ; Start with all 0s
000A9C                03389 GetMaskLoop
000A9C 80D8           03390         bsf     STATUS, C       ; Shift in 1s
000A9E 36??           03391         rlcf    TempByte, F
000AA0 2EE8           03392         decfsz  WREG, F
000AA2 D???           03393         bra     GetMaskLoop
000AA4 50??           03394         movf    TempByte, W
000AA6 0012           03395         return
                      03396 
                      03397 
                      03398 ; Convert a bit number in TempByte to a single bit mask in W
000AA8 0E01           03399 ConvertBit movlw 1              ; Start with 1 for 0
000AAA B0??           03400         btfsc   TempByte, 0
000AAC 46E8           03401         rlncf   WREG, F         ; Times 2 for 1 or 3
000AAE B2??           03402         btfsc   TempByte, 1
000AB0 46E8           03403         rlncf   WREG, F         ; Times 4 for 2 or 3
000AB2 B2??           03404         btfsc   TempByte, 1
000AB4 46E8           03405         rlncf   WREG, F
000AB6 B4??           03406         btfsc   TempByte, 2
000AB8 3AE8           03407         swapf   WREG, F         ; Swap to top if 4 to 7
000ABA 0012           03408         return
                      03409 
                      03410 
                      03411 ;/******************************************************************************
                      03412 ; * Function:        UnPacket
                      03413 ; *
                      03414 ; * PreCondition:    In-process flag, located at EPnbuffer + <buffer size> + 5,
                      03415 ; *                  must be initialized to 0
                      03416 ; *
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 77


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03417 ; * Input:           W contains EndPoint number
                      03418 ; *                  TBLPTRH/L is VarTable address
                      03419 ; *
                      03420 ; * Output:          Returns W = 0 when Report is all unpacked,
                      03421 ; *                              0x02 when EP is busy, and
                      03422 ; *                              0x04 when remainder of stuff to send has 0 length,
                      03423 ; *                              0xFF if there are still more packets to go
                      03424 ; *
                      03425 ; * Side Effects:    None
                      03426 ; *
                      03427 ; * Overview:        Unpack packet located in Endpoint buffer, using info from VarTable,
                      03428 ; *                  putting data into individual variables
                      03429 ; *
                      03430 ; * Note:
                      03431 ; *****************************************************************************/
                      03432 ; Unpack packet
                      03433 ; Unpack: W contains EndPoint number and TBLPTRH/L is VarTable address
000ABC                03434 UnPacket
000ABC 0104           03435         movlb   high 0x400      ; Point to proper bank
000ABE 6E??           03436         movwf   TempByte        ; Save EndPoint number for the moment
                      03437 
                      03438 ; Check to see if we're configured
000AC0 0E06           03439         movlw   CONFIGURED_STATE
000AC2 5C??           03440         subwf   usb_device_state, W
000AC4 0E01           03441         movlw   0x01            ; We might not be configured yet
000AC6 E1??           03442         bnz     UnPkNotReady    ; We're not
                      03443 
                      03444 ; Point FSR0 to requested endpoint Out BDT
000AC8 44??           03445         rlncf   TempByte, W     ; Endpoint number * 8
000ACA 44E8           03446         rlncf   WREG, W
000ACC 44E8           03447         rlncf   WREG, W
000ACE EE?? F0??      03448         lfsr    0, ep0Bo        ; Point FSR0 to beginning of BDT area
000AD2 26E9           03449         addwf   FSR0L, F        ; Add endpoint offset to FSR0 (can't overflow to FSR0H)
                      03450 
                      03451 ; Check for EndPoint busy
000AD4 0E02           03452         movlw   0x02            ; We might be busy
000AD6 BEEF           03453         btfsc   INDF0, UOWN     ; Who owns the buffer (Stat, UOWN)?
000AD8                03454 UnPkNotReady
000AD8 0012           03455         return                  ; Busy (we don't)
                      03456 
                      03457 ; Point to packet size
000ADA 6AE8           03458         clrf    WREG            ; Point FSR2 to beginning of packet
000ADC D???           03459         rcall   PointToPacket
000ADE 50DD           03460         movf    POSTDEC2, W     ; Back up to right before packet
                      03461 
                      03462 ; Get and reset Cnt
000AE0 2AE9           03463         incf    FSR0L, F        ; Point to Cnt in BDT (Can't overflow to H)
000AE2 CFEF F???      03464         movff   INDF0, TempByte ; Save Cnt
000AE6 50DF           03465         movf    INDF2, W        ; Get max packet size
000AE8 6E??           03466         movwf   MaxPacketSize   ; Save max for storage lookup
000AEA 6EED           03467         movwf   POSTDEC0        ; Set Cnt to max packet size (for next time) and point back to Stat
                      03468 
                      03469 ; Check for Zero Length Packet
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 78


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000AEC 66??           03470         tstfsz  TempByte        ; Is it ZLP?
000AEE D???           03471         bra     NotZLP          ; No
000AF0 D???           03472         rcall   ReleaseBuffer   ; ZLP
000AF2 0E04           03473         movlw   0x04            ; Tell caller to try again
000AF4 0012           03474         return                  ; Nothing there, try again later
                      03475 
                      03476 
                      03477 ; Get a few things ready for unpacking
000AF6                03478 NotZLP
000AF6 6A??           03479         clrf    PacketByteIndex
000AF8 6A??           03480         clrf    PacketBitIndex
000AFA 6AF8           03481         clrf    TBLPTRU         ; Probably unnecessary
                      03482 
                      03483 ; Check for first packet or in-process
000AFC D???           03484         rcall   PointToStorage
000AFE 50DE           03485         movf    POSTINC2, W     ; Check last state
000B00 6E??           03486         movwf   TempByte        ; Update in-process indicator
000B02 E0??           03487         bz      UnpackLoop      ; If zero then first packet
                      03488 
                      03489 
                      03490 ; Packet in-process - recover last info
000B04 CFDE FFF6      03491         movff   POSTINC2, TBLPTRL       ; Get pointer to VarTable
000B08 CFDE FFF7      03492         movff   POSTINC2, TBLPTRH
000B0C CFDE F???      03493         movff   POSTINC2, PacketByteIndex       ; Get next byte pointer
000B10 CFDE F???      03494         movff   POSTINC2, PacketBitIndex        ; Get next bit pointer
                      03495 
                      03496 
                      03497 ; Get variable size
000B14                03498 UnpackLoop
000B14 0009           03499         tblrd*+                 ; Read VarTable
000B16 50F5           03500         movf    TABLAT, W
000B18 E1??           03501         bnz UnpackLoop1
000B1A D???           03502         bra     TheUnEnd        ; At end of VarTable, we're done
000B1C                03503 UnpackLoop1
000B1C 6E??           03504         movwf   VarSign         ; Save for sign and single bit indicator
000B1E 0B3F           03505         andlw   0x3f            ; Mask to size
000B20 6E??           03506         movwf   VarSize         ; Save size in total bits
000B22 0B07           03507         andlw   0x07            ; Mask to excess bits = (total bits) mod 8
000B24 6E??           03508         movwf   VarBits
000B26 40??           03509         rrncf   VarSize, W      ; Shift down total bits to bytes
000B28 40E8           03510         rrncf   WREG, W
000B2A 40E8           03511         rrncf   WREG, W
000B2C 0B07           03512         andlw   0x07            ; Mask to number of whole bytes
000B2E 6E??           03513         movwf   VarBytes
000B30 66??           03514         tstfsz  VarBits
000B32 2A??           03515         incf    VarBytes, F     ; Adjust to actual bytes needed to contain item
                      03516 
000B34 50??           03517         movf    TempByte, W     ; Check for in-process
000B36 E0??           03518         bz      CheckSize       ; Not in-process, so continue with regular business
                      03519 
                      03520 ; In-Process here: a variable straddled a packet boundary, and we are resuming at next packet
                      03521 ; Now that we have the variable data, finish in-process tasks
000B38 50??           03522         movf    PacketByteIndex, W      ; Should be 1 or more for leftover data
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 79


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000B3A E0??           03523         bz      CheckSize       ; No leftover data from last packet (even packet)
000B3C 24??           03524         addwf   MaxPacketSize, W        ; Point to first new byte location at end of packet
000B3E D???           03525         rcall   PointToPacket
000B40 CFD9 FFE1      03526         movff   FSR2L, FSR1L    ; Move destination to FSR1
000B44 CFDA FFE2      03527         movff   FSR2H, FSR1H
000B48 6AE8           03528         clrf    WREG            ; Point FSR2 to beginning of packet
000B4A D???           03529         rcall   PointToPacket
                      03530 
000B4C 50??           03531         movf    PacketByteIndex, W
000B4E 5C??           03532         subwf   VarBytes, W
000B50                03533 UnProcessLoop
000B50 CFDE FFE6      03534         movff   POSTINC2, POSTINC1      ; Move a byte
000B54 06E8           03535         decf    WREG, F         ; Count through 0 to get 1 extra
000B56 E2??           03536         bc      UnProcessLoop
                      03537 
000B58 6C??           03538         negf    PacketByteIndex ; Negate current byte pointer so it will be correct for new index calcul
                            ation
                      03539 
000B5A 50??           03540         movf    MaxPacketSize, W        ; Point to shift or copy area
000B5C D???           03541         rcall   PointToPacket
                      03542 
000B5E 50??           03543         movf    PacketBitIndex, W       ; Are we on a byte boundary?
000B60 E0??           03544         bz      CopyToVar       ; Yes - No shift necessary
000B62 6E??           03545         movwf   TempCount       ; For shift later
000B64 D???           03546         bra     UnPkShiftLoop
                      03547 
                      03548 
                      03549 ; Is entire variable in packet?
000B66                03550 CheckSize
000B66 50??           03551         movf    PacketByteIndex, W
000B68 5C??           03552         subwf   MaxPacketSize, W        ; Result must be 1 or greater
000B6A E0??           03553         bz      SaveContext     ; We're past the end: save part of item & wait for next packet w/ rest
                      03554 
000B6C BC??           03555         btfsc   VarSign, 6      ; Is it a single bit?
000B6E D???           03556         bra     UnOneBit        ; Yes - it's got to fit so handle it
                      03557 
000B70 34E8           03558         rlcf    WREG, W         ; Shift up for bit calculation
000B72 34E8           03559         rlcf    WREG, W
000B74 E2??           03560         bc      PlentyORoom     ; If we rolled out a top bit there's plenty o' room
000B76 34E8           03561         rlcf    WREG, W
000B78 E2??           03562         bc      PlentyORoom     ; If we rolled out a top bit there's plenty o' room
000B7A 0BF8           03563         andlw   0xf8            ; Get rid of any junk that rolled in
000B7C 80D8           03564         bsf     STATUS, C
000B7E 54??           03565         subfwb  PacketBitIndex, W       ; W (remaining bytes * 3) - BitIndex - 0 (!C)
000B80 54??           03566         subfwb  VarSize, W      ; Is entire variable in packet? (C still set)
000B82 E3??           03567         bnc     SaveContext     ; No
                      03568 
                      03569 ; Yes, entire data item is in this packet.  See if it is byte aligned
000B84                03570 PlentyORoom
000B84 50??           03571         movf    PacketByteIndex, W      ; Get source address to FSR2
000B86 D???           03572         rcall   PointToPacket
000B88 50??           03573         movf    PacketBitIndex, W       ; Are we on a byte boundary?
000B8A E0??           03574         bz      CopyToVar       ; Yes - No shift necessary
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 80


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03575 
                      03576 ; If here, we will have to shift the data item. First, copy it to shift buffer.
000B8C 6E??           03577         movwf   TempCount       ; For shift later
                      03578 ; Move pointer to variable in packet to FSR1
000B8E CFD9 FFE1      03579         movff   FSR2L, FSR1L    ; FSR1 points to source
000B92 CFDA FFE2      03580         movff   FSR2H, FSR1H
                      03581 
                      03582 ; Point to first byte of shift area in packet
000B96 50??           03583         movf    MaxPacketSize, W        ; Shift area is at end of packet buffer
000B98 D???           03584         rcall   PointToPacket   ; FSR2 points to destination
                      03585 
000B9A 50??           03586         movf    VarBytes, W     ; Get number to copy + 1 extra
000B9C                03587 copyshiftloop
000B9C CFE3 FFDB      03588         movff   PLUSW1, PLUSW2  ; Do the copy
000BA0 06E8           03589         decf    WREG, F         ; Copy through 0 for 1 extra
000BA2 E2??           03590         bc      copyshiftloop
                      03591 
                      03592 
                      03593 ; Shift bits to the right to move to byte boundary
000BA4                03594 UnPkShiftLoop
000BA4 50??           03595         movf    VarBytes, W     ; W = number of bytes to shift and byte pointer
000BA6                03596 UnPkShiftLoop1
000BA6 32DB           03597         rrcf    PLUSW2, F       ; Shift a byte one bit to the right
000BA8 2CE8           03598         decfsz  WREG, W
000BAA D???           03599         bra     UnPkShiftLoop1  ; Shift all the bytes + 1 extra
000BAC 32DB           03600         rrcf    PLUSW2, F       ; Shift the 0th byte too
000BAE 2E??           03601         decfsz  TempCount, F
000BB0 D???           03602         bra     UnPkShiftLoop   ; Shift all the bits
                      03603 
                      03604 
                      03605 ; Now that item has been byte-aligned,
                      03606 ; Copy to variable
000BB2                03607 CopyToVar
000BB2 0009           03608         tblrd*+                 ; Read VarTable for low variable address
000BB4 50F5           03609         movf    TABLAT, W
000BB6 6EE1           03610         movwf   FSR1L           ; Get address of variable to FSR1
000BB8 0009           03611         tblrd*+                 ; Read VarTable for high variable address
000BBA 50F5           03612         movf    TABLAT, W
000BBC 6EE2           03613         movwf   FSR1H
                      03614 
000BBE 50??           03615         movf    VarBytes, W     ; Get number of bytes to copy
000BC0                03616 uncopyvarloop
000BC0 CFDE FFE6      03617         movff   POSTINC2, POSTINC1      ; Do the copy
000BC4 2EE8           03618         decfsz  WREG, F
000BC6 D???           03619         bra     uncopyvarloop
                      03620 
                      03621 ; Clear any extra junk from last (top) byte in variable
000BC8 52E5           03622         movf    POSTDEC1, F     ; Back up to last byte in variable
000BCA 50??           03623         movf    VarBits, W      ; Get top bit number + 1
000BCC E0??           03624         bz      CheckFor3       ; Full byte, nothing else to do
000BCE D???           03625         rcall   GetMask         ; Get mask to W and TempByte
000BD0 16E7           03626         andwf   INDF1, F        ; Mask off any extra bits
                      03627 
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 81


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03628 ; Sign extend, if required
000BD2 AE??           03629         btfss   VarSign, 7      ; Check for signed
                      03630 ;       bra     CheckFor3Unsigned       ; Unsigned
000BD4 D???           03631         bra     CheckFor3       ; Unsigned
000BD6 90D8           03632         bcf     STATUS, C       ; Clear carry
000BD8 30??           03633         rrcf    TempByte, W     ; Shift mask (still in TempByte) to create single bit mask
000BDA 18??           03634         xorwf   TempByte, W     ; W is now mask for sign bit
000BDC 14E7           03635         andwf   INDF1, W        ; Check for minus
000BDE E0??           03636         bz      CheckFor3       ; Sign bit is zero so all set
000BE0 0EFF           03637         movlw   0xff            ; Flip mask into sign extension
000BE2 18??           03638         xorwf   TempByte, W
000BE4 12E7           03639         iorwf   INDF1, F        ; Sign extend rest of byte
                      03640 
                      03641 
000BE6                03642 CheckFor3
                      03643 ; If we fit into 3 bytes, we need to fill out 4th byte of long (no short-longs)
                      03644     ifndef USE_SHORTLONGS
000BE6 0E03           03645         movlw   3               ; Check for 3 bytes
000BE8 62??           03646         cpfseq  VarBytes
000BEA D???           03647         bra     UnPkCalcNewIndexes      ; Not 3 bytes so go on
000BEC AE??           03648         btfss   VarSign, 7      ; Check for signed
000BEE D???           03649         bra     CheckFor3Unsigned       ; Unsigned
000BF0 68E8           03650         setf    WREG            ; Set for minus
000BF2 AEE7           03651         btfss   INDF1, 7        ; Test sign bit
000BF4                03652 CheckFor3Unsigned
000BF4 6AE8           03653         clrf    WREG            ; Set for plus or unsigned
000BF6 6EE4           03654         movwf   PREINC1         ; Fill in 4th byte
                      03655     endif
                      03656 
                      03657 
                      03658 ; Calculate new indexes
                      03659 ; I.e., bump indices to point to next item in packet, then loop back
000BF8                03660 UnPkCalcNewIndexes
000BF8 50??           03661         movf    VarSize, W      ; Get total bits in this variable
000BFA 26??           03662         addwf   PacketBitIndex, F       ; Update bits
000BFC                03663 UnPkCalcNewIndexesOneBit
000BFC 30??           03664         rrcf    PacketBitIndex, W       ; Shift to get to bytes
000BFE 30E8           03665         rrcf    WREG, W
000C00 30E8           03666         rrcf    WREG, W
000C02 0B07           03667         andlw   0x07            ; Mask to bytes
000C04 26??           03668         addwf   PacketByteIndex, F
000C06 0E07           03669         movlw   0x07            ; Mask to bits
000C08 16??           03670         andwf   PacketBitIndex, F
                      03671 
000C0A 6A??           03672         clrf    TempByte        ; Indicate we're not in-process any more
000C0C D???           03673         bra     UnpackLoop      ; Go do some more
                      03674 
                      03675 
                      03676 ; Data is a single bit - handle special case
000C0E                03677 UnOneBit
000C0E 0009           03678         tblrd*+                 ; Read VarTable for low variable address
000C10 50F5           03679         movf    TABLAT, W
000C12 6EE1           03680         movwf   FSR1L           ; Get address of variable to FSR1
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 82


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000C14 0009           03681         tblrd*+                 ; Read VarTable for high variable address
000C16 50F5           03682         movf    TABLAT, W
000C18 6EE2           03683         movwf   FSR1H
                      03684 
000C1A 50??           03685         movf    PacketByteIndex, W      ; Get source address to FSR2
000C1C D???           03686         rcall   PointToPacket
000C1E C??? F???      03687         movff   PacketBitIndex, TempByte        ; Get bit position in source
000C22 D???           03688         rcall   ConvertBit      ; Convert it to a single bit mask
000C24 14DF           03689         andwf   INDF2, W        ; Mask to our bit
000C26 6E??           03690         movwf   VarBytes        ; Save the result (don't need VarBytes for bits)
                      03691 
000C28 C??? F???      03692         movff   VarBits, TempByte       ; Get bit position in destination
000C2C D???           03693         rcall   ConvertBit      ; Convert it to a single bit mask
000C2E 12E7           03694         iorwf   INDF1, F        ; Put bit into destination
000C30 0AFF           03695         xorlw   0xff            ; Flip mask just in case
000C32 52??           03696         movf    VarBytes, F     ; Check source result
000C34 B4D8           03697         btfsc   STATUS, Z       ; Do we need to take it back out?
000C36 16E7           03698         andwf   INDF1, F        ; Take bit out of destination
                      03699 
000C38 2A??           03700         incf    PacketBitIndex, F       ; Add one to bits
000C3A D???           03701         bra     UnPkCalcNewIndexesOneBit        ; Finish updating indexes
                      03702 
                      03703 
                      03704 ; All variables in this Report have been unpacked
000C3C                03705 TheUnEnd
000C3C D???           03706         rcall   ReleaseBuffer   ; Set EP buffer free
000C3E D???           03707         rcall   PointToStorage
000C40 6AE8           03708         clrf    WREG            ; Signal that this is the last packet
000C42 6EDF           03709         movwf   INDF2           ; Save marker
000C44 0012           03710         return
                      03711 
                      03712 ; If here, this Report has not been completely received,
                      03713 ; so we will have more packets to unpack.
                      03714 ; Save context for more to come
000C46                03715 SaveContext
000C46 D???           03716         rcall   ReleaseBuffer   ; Set buffer free
                      03717 
000C48 50??           03718         movf    MaxPacketSize, W        ; Context save area is at end of packet buffer
000C4A D???           03719         rcall   PointToPacket
000C4C CFD9 FFE1      03720         movff   FSR2L, FSR1L    ; FSR1 points to destination
000C50 CFDA FFE2      03721         movff   FSR2H, FSR1H
                      03722 
000C54 50??           03723         movf    PacketByteIndex, W
000C56 D???           03724         rcall   PointToPacket   ; FSR2 points to source
                      03725 
000C58 50??           03726         movf    PacketByteIndex, W      ; Calculate number to copy
000C5A 5C??           03727         subwf   MaxPacketSize, W
000C5C 6E??           03728         movwf   PacketByteIndex ; Save as new index for next packet
000C5E E0??           03729         bz      SaveContextSave ; Nothing to copy so skip it
000C60                03730 SaveContextLoop
000C60 CFDE FFE6      03731         movff   POSTINC2, POSTINC1      ; Do the copy
000C64 2EE8           03732         decfsz  WREG, F
000C66 D???           03733         bra     SaveContextLoop
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 83


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000C68                03734 SaveContextSave
000C68 D???           03735         rcall   PointToStorage
000C6A 68E8           03736         setf    WREG            ; More packets to come
000C6C 6EDE           03737         movwf   POSTINC2        ; Save marker
000C6E 000A           03738         tblrd   *-              ; Back up VarTable pointer to beginning of in-process variable
000C70 CFF6 FFDE      03739         movff   TBLPTRL, POSTINC2       ; Save pointer to VarTable
000C74 CFF7 FFDE      03740         movff   TBLPTRH, POSTINC2
000C78 C??? FFDE      03741         movff   PacketByteIndex, POSTINC2       ; Save next byte pointer
000C7C C??? FFDE      03742         movff   PacketBitIndex, POSTINC2        ; Save next bit pointer
000C80 0012           03743         return                  ; W still set to 0xff
                      03744 
                      03745 
                      03746 
                      03747 
                      03748 #ifdef USB_WATCH
                      03749 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      03750 ; Add USBwatch activity reporting over hardware serial port
                      03751 ; (15)  Output routines
                      03752 
                      03753 ;*************************************************************************
                      03754 ; UsbwSendState
                      03755 ;
                      03756 ; Sends out the contents of USBWstate
                      03757 
                      03758 UsbwSendState
                      03759 ; Test if reporting is ON
                      03760         movf    USBW_On, W
                      03761         btfsc   STATUS, Z
                      03762         return
                      03763 ; Report equivalent of LED status: send contents of USBWstate
                      03764 UsbwSendState1
                      03765         movlw   'L'
                      03766         call    UsbwSendChar
                      03767         movf    USBWstate, W
                      03768 ; ...and just fall through to UsbwSendChar routine to send 2nd byte
                      03769 
                      03770 
                      03771 ;*************************************************************************
                      03772 ; UsbwSendChar
                      03773 ;
                      03774 ; Sends a single char in WREG
                      03775 
                      03776 UsbwSendChar
                      03777         btfss   PIR1, TXIF
                      03778         bra     UsbwSendChar
                      03779         movwf   TXREG
                      03780         return
                      03781 
                      03782 
                      03783 ;*************************************************************************
                      03784 ; UsbwSendUSR
                      03785 ;
                      03786 ; Sends a 'U' (User) message
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 84


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03787 ;
                      03788 ; From within PicBasic Pro code, use: HSEROUT ["U", <byte count>, <data>]
                      03789 ;
                      03790 ; Use this version for sending 'U' messages from assembler code in this file
                      03791 ; INPUTS: WREG = byte count
                      03792 ;         FSR0 : IRP point to buffer
                      03793 ;
                      03794 ; Example:
                      03795 ; ========
                      03796 ;  lfsr    0, UmsgBuf     ; Address of buffer that contains your message
                      03797 ;  movlw   <byte count>   ; Number of bytes you want to send
                      03798 ;  call    UsbwSendUSR
                      03799 
                      03800 
                      03801 UsbwSendUSR
                      03802         movwf   USBWtemp        ; First, save byte count in variable USBWtemp
                      03803 ; Test if USBwatch reporting is ON
                      03804         movf    USBW_On, W
                      03805         btfsc   STATUS, Z
                      03806         return
                      03807 ; Send out letter 'U' to indicate that this is a User message
                      03808         movlw   'U'
                      03809         rcall   UsbwSendChar
                      03810 ; Now we can just restore byte count to W...
                      03811         movf    USBWtemp, W
                      03812 ; ...and just fall through to UsbwSendBuf routine
                      03813 
                      03814 
                      03815 
                      03816 ;*************************************************************************
                      03817 ; UsbwSendBuf
                      03818 ;
                      03819 ; Sends a whole buffer
                      03820 ; INPUTS: WREG = byte count
                      03821 ;         FSR0 points to buffer
                      03822 
                      03823 UsbwSendBuf
                      03824         movwf   USBWtemp        ; but first, save it in variable USBWtemp
                      03825 ; Send out byte count
                      03826         rcall   UsbwSendChar
                      03827 
                      03828 ; Test for zero byte count, and exit if 0
                      03829 UsbwSendBuf_NBC
                      03830         movf    USBWtemp, W
                      03831         btfsc   STATUS, Z
                      03832         return
                      03833 
                      03834 Usbw_SB_Loop
                      03835         movf    POSTINC0, W     ; Get next byte
                      03836 ; Send out next byte of buffer
                      03837         rcall   UsbwSendChar
                      03838 ; See if we have to loop back for more
                      03839         decfsz  USBWtemp, F
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 85


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03840         bra     Usbw_SB_Loop
                      03841         return
                      03842 
                      03843 
                      03844 ;*************************************************************************
                      03845 ; UsbwNewTransaction
                      03846 ;
                      03847 ; Reports on occurance of a new USB transaction
                      03848 
                      03849 UsbwNewTransaction
                      03850 ; Test if reporting is ON
                      03851         movf    USBW_On, W
                      03852         btfsc   STATUS, Z
                      03853         return
                      03854 ; (4) 'L'
                      03855 ; First, toggle EP0..2 EP in USBwatch to denote any activity on these EPs
                      03856         rrncf   USTAT, W
                      03857         rrncf   WREG, W
                      03858         rrncf   WREG, W         ; Rotate EPnum bits to right
                      03859         andlw   0x0F            ; This is the EP number
                      03860         movwf   USBWtemp        ; Save EP number for later
                      03861         bz      UWEP0           ; EP0
                      03862         dcfsnz  WREG, W
                      03863         bra     UWEP1           ; EP1
                      03864         decfsz  WREG, W
                      03865         bra     UsbwNewTran1    ; EP > 2, skip this part
                      03866         btg     USBWstate, 7    ; Toggle bit 7 to show EP2 activity
                      03867         bra     UWmaskport
                      03868 UWEP1
                      03869         btg     USBWstate, 6    ; Toggle bit 6 to Show EP1 activity
                      03870         bra     UWmaskport
                      03871 UWEP0
                      03872         btg     USBWstate, 5    ; Toggle bit 5 to Show EP0 activity
                      03873 UWmaskport
                      03874         rcall   UsbwSendState1
                      03875 UsbwNewTran1
                      03876 ; (5) 'O' or (16) 'I'
                      03877 ; Next, report direction (IN or OUT), USTAT, and request
                      03878         movlw   'O'             ; Signal to USBwatch that we got an OUT or SETUP token
                      03879         btfsc   USTAT, 2
                      03880         movlw   'I'             ; Signal to USBwatch that we got an IN token
                      03881         rcall   UsbwSendChar
                      03882         movf    USTAT, W
                      03883         andlw   0x1C            ; Adjust for current version of USBwatch
                      03884         rcall   UsbwSendChar
                      03885         movf    SetupPkt + bRequest, W
                      03886         rcall   UsbwSendChar
                      03887 ; 'A' or 'B'
                      03888 ; Next, report specific EP number, count, and actual (IN or OUT) packet contents
                      03889         movlw   'A'             ; Signal to USBwatch that we got an OUT or SETUP token
                      03890         btfsc   USTAT, 2
                      03891         movlw   'B'             ; Signal to USBwatch that we got an IN token
                      03892         rcall   UsbwSendChar
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 86


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      03893         movf    USBWtemp, W     ; Endpoint number (0..15)
                      03894         rcall   UsbwSendChar
                      03895 ; Have to find the right BDT for this endpoint
                      03896         movf    USTAT, W
                      03897         andlw   0x1C            ; Mask to endpoint and direction (already properly placed)
                      03898         lfsr    1, ep0Bo + 1    ; Point FSR1 to BDTnCNT of first OUT endpoint BDT
                      03899         addwf   FSR1L, F        ; Add EP offset to FSR0L (can't overflow to FSR0H)
                      03900 ; Get Endpoint buffer address to FSR0
                      03901         movf    POSTINC1, W     ; Get byte count to W and point to ADRL
                      03902         movff   POSTINC1, FSR0L ; Copy low part of address and point to ADRH
                      03903         movff   INDF1, FSR0H    ; Copy high part of address
                      03904         bra     UsbwSendBuf     ; Now send out the buffer contents
                      03905 
                      03906 
                      03907 ; -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
                      03908 #endif
                      03909 
                      03910  end
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 87


SYMBOL TABLE
  LABEL                             VALUE 

A                                 00000000
ABDEN                             00000000
ABDOVF                            00000007
ABSTRACT_CONTROL_MODEL            0x02
ABSTRACT_STATE                    0x01
ACCESS                            00000000
ACKDT                             00000005
ACKEN                             00000004
ACKSTAT                           00000006
ACQT0                             00000003
ACQT1                             00000004
ACQT2                             00000005
ACTVIE                            00000002
ACTVIF                            00000002
ADCON0                            00000FC2
ADCON1                            00000FC1
ADCON2                            00000FC0
ADCS0                             00000000
ADCS1                             00000001
ADCS2                             00000002
ADDEN                             00000003
ADDR0                             00000000
ADDR1                             00000001
ADDR2                             00000002
ADDR3                             00000003
ADDR4                             00000004
ADDR5                             00000005
ADDR6                             00000006
ADDRESS_STATE                     5
ADEN                              00000003
ADFM                              00000007
ADIE                              00000006
ADIF                              00000006
ADIP                              00000006
ADON                              00000000
ADRES                             00000FC3
ADRESH                            00000FC4
ADRESL                            00000FC3
ADRH                              3
ADRL                              2
ADR_PENDING_STATE                 4
AN0                               00000000
AN1                               00000001
AN2                               00000002
AN3                               00000003
AN4                               00000005
ATTACHED_STATE                    1
BANKED                            00000001
BAUDCON                           00000FB8
BC8                               0
BC9                               1
BCLIE                             00000003
BCLIF                             00000003
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 88


SYMBOL TABLE
  LABEL                             VALUE 

BCLIP                             00000003
BF                                00000000
BGST                              00000005
BOOT_INTF_SUBCLASS                0x01
BOOT_PROTOCOL                     0x00
BOR                               00000000
BRG16                             00000003
BRGH                              00000002
BSR                               00000FE0
BSTALL                            2
BTOEE                             00000004
BTOEF                             00000004
BTSEE                             00000007
BTSEF                             00000007
C                                 00000000
C1INV                             00000004
C1OUT                             00000006
C1_InEpTable                      00000000
C1_MAX_EP_NUMBER                  1
C1_OutEpTable                     00000000
C1_RD_Table                       00000000
C2INV                             00000005
C2OUT                             00000007
C2_InEpTable                      00000000
C2_OutEpTable                     00000000
C2_RD_Table                       00000000
CARRIER_CONTROL                   1
CCP1                              00000002
CCP1AS                            00000FB6
CCP1CON                           00000FBD
CCP1DEL                           00000FB7
CCP1IE                            00000002
CCP1IF                            00000002
CCP1IP                            00000002
CCP1M0                            00000000
CCP1M1                            00000001
CCP1M2                            00000002
CCP1M3                            00000003
CCP2CON                           00000FBA
CCP2IE                            00000000
CCP2IF                            00000000
CCP2IP                            00000000
CCP2M0                            00000000
CCP2M1                            00000001
CCP2M2                            00000002
CCP2M3                            00000003
CCPR1                             00000FBE
CCPR1H                            00000FBF
CCPR1L                            00000FBE
CCPR2                             00000FBB
CCPR2H                            00000FBC
CCPR2L                            00000FBB
CDC_DEVICE                        0x02
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 89


SYMBOL TABLE
  LABEL                             VALUE 

CDC_TX_BUSY                       1
CDC_TX_BUSY_ZLP                   2
CDC_TX_COMPLETING                 3
CDC_TX_READY                      0
CFGS                              00000006
CHS0                              00000002
CHS1                              00000003
CHS2                              00000004
CHS3                              00000005
CIS                               00000003
CK                                00000006
CK1SPP                            00000000
CK2SPP                            00000001
CKE                               00000006
CKP                               00000004
CLASS                             0x01
CLEAR_COMM_FEATURE                0x04
CLK1EN                            00000004
CLKCFG0                           00000006
CLKCFG1                           00000007
CLR_FEATURE                       1
CM0                               00000000
CM1                               00000001
CM2                               00000002
CMCON                             00000FB4
CMIE                              00000006
CMIF                              00000006
CMIP                              00000006
COMM_INTF                         0x02
CONFIGURED_STATE                  6
COUNTRY_SETTING                   0x02
CRC16EE                           00000002
CRC16EF                           00000002
CRC5EE                            00000001
CRC5EF                            00000001
CREN                              00000004
CSEN                              00000005
CSRC                              00000007
CS_ENDPOINT                       0x25
CS_INTERFACE                      0x24
CTRL_TRF_RX                       2
CTRL_TRF_TX                       1
CVR0                              00000000
CVR1                              00000001
CVR2                              00000002
CVR3                              00000003
CVRCON                            00000FB5
CVREF                             00000004
CVREN                             00000007
CVROE                             00000006
CVRR                              00000005
CVRSS                             00000004
CalcNewIndexes                    000009FE
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 90


SYMBOL TABLE
  LABEL                             VALUE 

CalcNewIndexesOneBit              00000A02
CheckFor3                         00000BE6
CheckFor3Unsigned                 00000BF4
CheckRDT_NumEntries               00000776
CheckSize                         00000B66
Cnt                               1
Config1                           00000000
Config1Len                        00000000
Config2                           00000000
Config2Len                        00000000
ConvertBit                        00000AA8
CopyToVar                         00000BB2
CtlOutVarTable                    00000000
CtrlTrfData                       00000000
CtrlTrfDataLen                    00000000
CtrlTrfDataStorage                00000000
D                                 00000005
DATA_ADDRESS                      00000005
DATA_INTF                         0x0A
DC                                00000001
DC1B0                             00000004
DC1B1                             00000005
DC2B0                             00000004
DC2B1                             00000005
DDRA                              TRISA
DDRB                              TRISB
DDRC                              TRISC
DDRD                              TRISD
DDRE                              TRISE
DEFAULT_STATE                     3
DETACHED_STATE                    0
DEVICE_REMOTE_WAKEUP              0x01
DEV_TO_HOST                       1
DFN8EE                            00000003
DFN8EF                            00000003
DIR                               00000002
DONE                              00000001
DSC_CFG                           0x02
DSC_DEV                           0x01
DSC_EP                            0x05
DSC_FN_ACM                        0x02
DSC_FN_CALL_MGT                   0x01
DSC_FN_COUNTRY_SELECTION          0x07
DSC_FN_DLM                        0x03
DSC_FN_HEADER                     0x00
DSC_FN_RPT_CAPABILITIES           0x05
DSC_FN_TELEPHONE_RINGER           0x04
DSC_FN_TEL_OP_MODES               0x08
DSC_FN_UNION                      0x06
DSC_FN_USB_TERMINAL               0x09
DSC_HID                           0x21
DSC_INTF                          0x04
DSC_PHY                           0x23
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 91


SYMBOL TABLE
  LABEL                             VALUE 

DSC_RPT                           0x22
DSC_STR                           0x03
DTE_PRESENT                       0
DTS                               6
DTSEN                             3
D_A                               00000005
DataDir                           7
DeviceDescriptor                  00000000
ECCP1AS                           00000FB6
ECCP1CON                          00000FBD
ECCP1DEL                          00000FB7
ECCPAS0                           00000004
ECCPAS1                           00000005
ECCPAS2                           00000006
ECCPASE                           00000007
EEADR                             00000FA9
EECON1                            00000FA6
EECON2                            00000FA7
EEDATA                            00000FA8
EEIE                              00000004
EEIF                              00000004
EEIP                              00000004
EEPGD                             00000007
ENDP0                             00000003
ENDP1                             00000004
ENDP2                             00000005
ENDP3                             00000006
ENDPOINT_HALT                     0x00
EP00_IN                           (0x00<<3)|(IN<<2)
EP00_OUT                          (0x00<<3)|(OUT<<2)
EP01_IN                           (0x01<<3)|(IN<<2)
EP01_OUT                          (0x01<<3)|(OUT<<2)
EP02_IN                           (0x02<<3)|(IN<<2)
EP02_OUT                          (0x02<<3)|(OUT<<2)
EP03_IN                           (0x03<<3)|(IN<<2)
EP03_OUT                          (0x03<<3)|(OUT<<2)
EP04_IN                           (0x04<<3)|(IN<<2)
EP04_OUT                          (0x04<<3)|(OUT<<2)
EP05_IN                           (0x05<<3)|(IN<<2)
EP05_OUT                          (0x05<<3)|(OUT<<2)
EP06_IN                           (0x06<<3)|(IN<<2)
EP06_OUT                          (0x06<<3)|(OUT<<2)
EP07_IN                           (0x07<<3)|(IN<<2)
EP07_OUT                          (0x07<<3)|(OUT<<2)
EP08_IN                           (0x08<<3)|(IN<<2)
EP08_OUT                          (0x08<<3)|(OUT<<2)
EP09_IN                           (0x09<<3)|(IN<<2)
EP09_OUT                          (0x09<<3)|(OUT<<2)
EP0_BUFF_SIZE                     8
EP10_IN                           (0x0A<<3)|(IN<<2)
EP10_IN_BUFF_SIZE                 0
EP10_OUT                          (0x0A<<3)|(OUT<<2)
EP10_OUT_BUFF_SIZE                0
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 92


SYMBOL TABLE
  LABEL                             VALUE 

EP11_IN                           (0x0B<<3)|(IN<<2)
EP11_IN_BUFF_SIZE                 0
EP11_OUT                          (0x0B<<3)|(OUT<<2)
EP11_OUT_BUFF_SIZE                0
EP12_IN                           (0x0C<<3)|(IN<<2)
EP12_IN_BUFF_SIZE                 0
EP12_OUT                          (0x0C<<3)|(OUT<<2)
EP12_OUT_BUFF_SIZE                0
EP13_IN                           (0x0D<<3)|(IN<<2)
EP13_IN_BUFF_SIZE                 0
EP13_OUT                          (0x0D<<3)|(OUT<<2)
EP13_OUT_BUFF_SIZE                0
EP14_IN                           (0x0E<<3)|(IN<<2)
EP14_IN_BUFF_SIZE                 0
EP14_OUT                          (0x0E<<3)|(OUT<<2)
EP14_OUT_BUFF_SIZE                0
EP15_IN                           (0x0F<<3)|(IN<<2)
EP15_IN_BUFF_SIZE                 0
EP15_OUT                          (0x0F<<3)|(OUT<<2)
EP15_OUT_BUFF_SIZE                0
EP1_IN_BUFF_SIZE                  64
EP1_InBuffer                      00000000
EP1_OUT_BUFF_SIZE                 64
EP1_OutBuffer                     00000000
EP2_IN_BUFF_SIZE                  0
EP2_OUT_BUFF_SIZE                 0
EP3_IN_BUFF_SIZE                  0
EP3_OUT_BUFF_SIZE                 0
EP4_IN_BUFF_SIZE                  0
EP4_OUT_BUFF_SIZE                 0
EP5_IN_BUFF_SIZE                  0
EP5_OUT_BUFF_SIZE                 0
EP6_IN_BUFF_SIZE                  0
EP6_OUT_BUFF_SIZE                 0
EP7_IN_BUFF_SIZE                  0
EP7_OUT_BUFF_SIZE                 0
EP8_IN_BUFF_SIZE                  0
EP8_OUT_BUFF_SIZE                 0
EP9_IN_BUFF_SIZE                  0
EP9_OUT_BUFF_SIZE                 0
EPCONDIS                          00000003
EPDir                             7
EPHSHK                            00000004
EPINEN                            00000001
EPNum                             0
EPOUTEN                           00000002
EPSTALL                           00000000
EP_CTRL                           0x06
EP_IN                             0x0A
EP_OUT                            0x0C
EP_OUT_IN                         0x0E
Ep1RcvVarTable                    00000000
Ep1XmtVarTable                    00000000
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 93


SYMBOL TABLE
  LABEL                             VALUE 

Ep2RcvVarTable                    00000000
Ep2XmtVarTable                    00000000
FAST                              00000001
FERR                              00000002
FLTS                              00000002
FREE                              00000004
FRM0                              00000000
FRM1                              00000001
FRM10                             00000002
FRM2                              00000002
FRM3                              00000003
FRM4                              00000004
FRM5                              00000005
FRM6                              00000006
FRM7                              00000007
FRM8                              00000000
FRM9                              00000001
FSEN                              00000002
FSR0                              00000000
FSR0H                             00000FEA
FSR0L                             00000FE9
FSR1                              00000001
FSR1H                             00000FE2
FSR1L                             00000FE1
FSR2                              00000002
FSR2H                             00000FDA
FSR2L                             00000FD9
FeatureIn                         00000000
FeatureVarTable                   00000000
FindRDEntryLoop                   00000788
FoundRightIntfEntry               000007A8
GCEN                              00000007
GET_CFG                           8
GET_COMM_FEATURE                  0x03
GET_DSC                           6
GET_ENCAPSULATED_RESPONSE         0x01
GET_IDLE                          0x02
GET_INTF                          10
GET_LINE_CODING                   0x21
GET_PROTOCOL                      0x03
GET_REPORT                        0x01
GET_STATUS                        0
GIE                               00000007
GIEH                              00000007
GIEL                              00000006
GO                                00000001
GO_DONE                           00000001
GetMask                           00000A9A
GetMaskLoop                       00000A9C
GetUSB                            000008DE
GetUSBNotReady                    000008FE
GetUSBRamLoop                     0000091C
GetUSBZero                        00000924
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 94


SYMBOL TABLE
  LABEL                             VALUE 

HID0                              00000000
HID_FEATURE_REPORT                3
HID_INPUT_REPORT                  1
HID_INTF                          0x03
HID_OUTPUT_REPORT                 2
HID_PROTOCOL_KEYBOAD              0x01
HID_PROTOCOL_MOUSE                0x02
HID_PROTOCOL_NONE                 0x00
HLL_ActiveProtocol                00000000
HLL_IdleRate                      00000000
HLVDCON                           00000FD2
HLVDEN                            00000004
HLVDIE                            00000002
HLVDIF                            00000002
HLVDIN                            00000005
HLVDIP                            00000002
HLVDL0                            00000000
HLVDL1                            00000001
HLVDL2                            00000002
HLVDL3                            00000003
HOST_TO_DEV                       0
HSHK_EN                           0x10
I2C_DAT                           00000005
I2C_READ                          00000002
I2C_START                         00000003
I2C_STOP                          00000004
IDLEIE                            00000004
IDLEIF                            00000004
IDLEN                             00000007
IN                                1
INCDIS                            4
INDF0                             00000FEF
INDF1                             00000FE7
INDF2                             00000FDF
INT0                              00000000
INT0E                             00000004
INT0F                             00000001
INT0IE                            00000004
INT0IF                            00000001
INT1                              00000001
INT1E                             00000003
INT1F                             00000000
INT1IE                            00000003
INT1IF                            00000000
INT1IP                            00000006
INT1P                             00000006
INT2                              00000002
INT2E                             00000004
INT2F                             00000001
INT2IE                            00000004
INT2IF                            00000001
INT2IP                            00000007
INT2P                             00000007
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 95


SYMBOL TABLE
  LABEL                             VALUE 

INTCON                            00000FF2
INTCON2                           00000FF1
INTCON3                           00000FF0
INTEDG0                           00000006
INTEDG1                           00000005
INTEDG2                           00000004
INTSRC                            00000007
IN_TOKEN                          0x09
IOFS                              00000002
IPEN                              00000007
IPR1                              00000F9F
IPR2                              00000FA2
IRCF0                             00000004
IRCF1                             00000005
IRCF2                             00000006
IRVST                             00000005
IVRST                             00000005
InProcessLoop                     0000098E
InitC1_InEps                      00000340
InitC1_OutEps                     0000038C
InitEPIn                          00000820
InitEPOut                         00000850
Init_InEps                        00000346
Init_OutEps                       00000392
InitializeUSBDriver               00000614
KEN                               5
LATA                              00000F89
LATA0                             00000000
LATA1                             00000001
LATA2                             00000002
LATA3                             00000003
LATA4                             00000004
LATA5                             00000005
LATA6                             00000006
LATB                              00000F8A
LATB0                             00000000
LATB1                             00000001
LATB2                             00000002
LATB3                             00000003
LATB4                             00000004
LATB5                             00000005
LATB6                             00000006
LATB7                             00000007
LATC                              00000F8B
LATC0                             00000000
LATC1                             00000001
LATC2                             00000002
LATC6                             00000006
LATC7                             00000007
LATD                              00000F8C
LATD0                             00000000
LATD1                             00000001
LATD2                             00000002
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 96


SYMBOL TABLE
  LABEL                             VALUE 

LATD3                             00000003
LATD4                             00000004
LATD5                             00000005
LATD6                             00000006
LATD7                             00000007
LATE                              00000F8D
LATE0                             00000000
LATE1                             00000001
LATE2                             00000002
LINE_CODING_LENGTH                0x07
LVDCON                            00000FD2
LVDEN                             00000004
LVDIE                             00000002
LVDIF                             00000002
LVDIN                             00000005
LVDIP                             00000002
LVDL0                             00000000
LVDL1                             00000001
LVDL2                             00000002
LVDL3                             00000003
LVV0                              00000000
LVV1                              00000001
LVV2                              00000002
LVV3                              00000003
MAX_EP_NUMBER                     1
MAX_NUM_INT                       3
MODE_PP                           _PPBM0
MUID_CDC                          3
MUID_HID                          2
MUID_MSD                          4
MUID_NULL                         0
MUID_USB9                         1
MaxPacketSize                     00000000
N                                 00000004
NETWORK_CONNECTION                0x00
NOT_A                             00000005
NOT_ADDRESS                       00000005
NOT_BOR                           00000000
NOT_DONE                          00000001
NOT_IPEN                          00000007
NOT_PD                            00000002
NOT_POR                           00000001
NOT_RBPU                          00000007
NOT_RI                            00000004
NOT_T1SYNC                        00000002
NOT_T3SYNC                        00000002
NOT_TO                            00000003
NOT_W                             00000002
NOT_WRITE                         00000002
NO_PROTOCOL                       0x00
NUM_CONFIGURATIONS                1
NUM_INTERFACES                    1
NotReady                          00000950
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 97


SYMBOL TABLE
  LABEL                             VALUE 

NotZLP                            00000AF6
OERR                              00000001
OESPP                             00000002
OSC2                              00000006
OSCCON                            00000FD3
OSCFIE                            00000007
OSCFIF                            00000007
OSCFIP                            00000007
OSCTUNE                           00000F9B
OSTS                              00000003
OUT                               0
OUT_TOKEN                         0x01
OV                                00000003
OneBit                            00000A38
P                                 00000004
P1A                               00000002
P1M0                              00000006
P1M1                              00000007
PC                                00000FF9
PCFG0                             00000000
PCFG1                             00000001
PCFG2                             00000002
PCFG3                             00000003
PCL                               00000FF9
PCLATH                            00000FFA
PCLATU                            00000FFB
PD                                00000002
PDC0                              00000000
PDC1                              00000001
PDC2                              00000002
PDC3                              00000003
PDC4                              00000004
PDC5                              00000005
PDC6                              00000006
PEIE                              00000006
PEN                               00000002
PGC                               00000006
PGD                               00000007
PGM                               00000005
PIC_EP_DIR_MASK                   0b00000100
PIC_EP_NUM_MASK                   0b01111000
PID                               2
PIDEE                             00000000
PIDEF                             00000000
PIE1                              00000F9D
PIE2                              00000FA0
PIR1                              00000F9E
PIR2                              00000FA1
PKTDIS                            00000004
PLUSW0                            00000FEB
PLUSW1                            00000FE3
PLUSW2                            00000FDB
POR                               00000001
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 98


SYMBOL TABLE
  LABEL                             VALUE 

PORTA                             00000F80
PORTB                             00000F81
PORTC                             00000F82
PORTD                             00000F83
PORTE                             00000F84
POSTDEC0                          00000FED
POSTDEC1                          00000FE5
POSTDEC2                          00000FDD
POSTINC0                          00000FEE
POSTINC1                          00000FE6
POSTINC2                          00000FDE
POWERED_STATE                     2
PPB0                              00000000
PPB1                              00000001
PPBI                              00000001
PPBRST                            00000006
PR2                               00000FCB
PREINC0                           00000FEC
PREINC1                           00000FE4
PREINC2                           00000FDC
PROD                              00000FF3
PRODH                             00000FF4
PRODL                             00000FF3
PRSEN                             00000007
PSA                               00000003
PSSAC0                            00000002
PSSAC1                            00000003
PSSBD0                            00000000
PSSBD1                            00000001
PackAndSendOnePacket              0000003E
PackandShipPacket                 00000934
PacketBitIndex                    00000000
PacketByteIndex                   00000000
PacketFull                        00000A1E
PlentyORoom                       00000B84
PointToPacket                     00000A82
PointToStorage                    00000A7E
PutUSB                            00000888
PutUSBNotReady                    000008A8
PutUSBRamLoop                     000008C6
PutUSBZero                        000008CE
R                                 00000002
R0                                00000000
RA0                               00000000
RA1                               00000001
RA2                               00000002
RA3                               00000003
RA4                               00000004
RA5                               00000005
RA6                               00000006
RB0                               00000000
RB1                               00000001
RB2                               00000002
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 99


SYMBOL TABLE
  LABEL                             VALUE 

RB3                               00000003
RB4                               00000004
RB5                               00000005
RB6                               00000006
RB7                               00000007
RBIE                              00000003
RBIF                              00000000
RBIP                              00000000
RBPU                              00000007
RC0                               00000000
RC1                               00000001
RC2                               00000002
RC4                               00000004
RC5                               00000005
RC6                               00000006
RC7                               00000007
RCEN                              00000003
RCIDL                             00000006
RCIE                              00000005
RCIF                              00000005
RCIP                              00000005
RCMT                              00000006
RCON                              00000FD0
RCPT_DEV                          0
RCPT_EP                           2
RCPT_INTF                         1
RCPT_OTH                          3
RCREG                             00000FAE
RCSTA                             00000FAB
RD                                00000000
RD0                               00000000
RD1                               00000001
RD16                              00000007
RD2                               00000002
RD3                               00000003
RD4                               00000004
RD5                               00000005
RD6                               00000006
RD7                               00000007
RDPU                              00000007
RDSPP                             00000007
RE0                               00000000
RE1                               00000001
RE2                               00000002
RE3                               00000003
READ_WRITE                        00000002
RESPONSE_AVAILABLE                0x01
RESUME                            00000002
RI                                00000004
RPT_PROTOCOL                      0x01
RSEN                              00000001
RX                                00000007
RX9                               00000006
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 100


SYMBOL TABLE
  LABEL                             VALUE 

RX9D                              00000000
RXDTP                             00000005
R_W                               00000002
RcvFeatureRpt                     00000000
RcvOutRpt                         00000000
ReadAndUnpackOnePacket            00000012
Recipient                         0
ReleaseBuffer                     00000A72
RemoteWakeup                      0
RequestType                       5
RestoreFSRs                       000001BC
S                                 00000003
SBOREN                            00000006
SCKP                              00000004
SCS0                              00000000
SCS1                              00000001
SE0                               00000005
SEN                               00000000
SENDB                             00000003
SEND_BREAK                        0x23
SEND_ENCAPSULATED_COMMAND         0x00
SERIAL_STATE                      0x20
SETUP_TOKEN                       0x0d
SET_ADR                           5
SET_CFG                           9
SET_COMM_FEATURE                  0x02
SET_CONTROL_LINE_STATE            0x22
SET_DSC                           7
SET_FEATURE                       3
SET_IDLE                          0x0A
SET_INTF                          11
SET_LINE_CODING                   0x20
SET_PROTOCOL                      0x0B
SET_REPORT                        0x09
SMP                               00000007
SOFIE                             00000006
SOFIF                             00000006
SPBRG                             00000FAF
SPBRGH                            00000FB0
SPEN                              00000007
SPP0                              00000000
SPP1                              00000001
SPP2                              00000002
SPP3                              00000003
SPP4                              00000004
SPP5                              00000005
SPP6                              00000006
SPP7                              00000007
SPPBUSY                           00000004
SPPCFG                            00000F63
SPPCON                            00000F65
SPPDATA                           00000F62
SPPEN                             00000000
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 101


SYMBOL TABLE
  LABEL                             VALUE 

SPPEPS                            00000F64
SPPIE                             00000007
SPPIF                             00000007
SPPIP                             00000007
SPPOWN                            00000001
SREN                              00000005
SSPADD                            00000FC8
SSPBUF                            00000FC9
SSPCON1                           00000FC6
SSPCON2                           00000FC5
SSPEN                             00000005
SSPIE                             00000003
SSPIF                             00000003
SSPIP                             00000003
SSPM0                             00000000
SSPM1                             00000001
SSPM2                             00000002
SSPM3                             00000003
SSPOV                             00000006
SSPSTAT                           00000FC7
STALLIE                           00000005
STALLIF                           00000005
STANDARD                          0x00
STATUS                            00000FD8
STKFUL                            00000007
STKPTR                            00000FFC
STKPTR0                           00000000
STKPTR1                           00000001
STKPTR2                           00000002
STKPTR3                           00000003
STKPTR4                           00000004
STKUNF                            00000006
SUSPND                            00000001
SWDTE                             00000000
SWDTEN                            00000000
SYNC                              00000004
SYNCH_FRAME                       12
SaveContext                       00000C46
SaveContextLoop                   00000C60
SaveContextSave                   00000C68
SaveFSRs                          0000018A
SavedFSR0                         00000000
SavedFSR1                         00000000
SavedFSR2                         00000000
SendPacket                        00000A64
SetC1_RDTable                     00000770
SetupPkt                          00000000
SetupPktLen                       00000000
Stat                              0
T08BIT                            00000006
T0CKI                             00000004
T0CON                             00000FD5
T0CS                              00000005
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 102


SYMBOL TABLE
  LABEL                             VALUE 

T0IE                              00000005
T0IF                              00000002
T0IP                              00000002
T0PS0                             00000000
T0PS1                             00000001
T0PS2                             00000002
T0SE                              00000004
T13CKI                            00000000
T1CKPS0                           00000004
T1CKPS1                           00000005
T1CON                             00000FCD
T1OSCEN                           00000003
T1OSI                             00000001
T1OSO                             00000000
T1RUN                             00000006
T1SYNC                            00000002
T2CKPS0                           00000000
T2CKPS1                           00000001
T2CON                             00000FCA
T2OUTPS0                          00000003
T2OUTPS1                          00000004
T2OUTPS2                          00000005
T2OUTPS3                          00000006
T3CCP1                            00000003
T3CCP2                            00000006
T3CKPS0                           00000004
T3CKPS1                           00000005
T3CON                             00000FB1
T3NSYNC                           00000002
T3SYNC                            00000002
TABLAT                            00000FF5
TBLPTR                            00000FF6
TBLPTRH                           00000FF7
TBLPTRL                           00000FF6
TBLPTRU                           00000FF8
TMR0H                             00000FD7
TMR0IE                            00000005
TMR0IF                            00000002
TMR0IP                            00000002
TMR0L                             00000FD6
TMR0ON                            00000007
TMR1CS                            00000001
TMR1H                             00000FCF
TMR1IE                            00000000
TMR1IF                            00000000
TMR1IP                            00000000
TMR1L                             00000FCE
TMR1ON                            00000000
TMR2                              00000FCC
TMR2IE                            00000001
TMR2IF                            00000001
TMR2IP                            00000001
TMR2ON                            00000002
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 103


SYMBOL TABLE
  LABEL                             VALUE 

TMR3CS                            00000001
TMR3H                             00000FB3
TMR3IE                            00000001
TMR3IF                            00000001
TMR3IP                            00000001
TMR3L                             00000FB2
TMR3ON                            00000000
TO                                00000003
TOS                               00000FFD
TOSH                              00000FFE
TOSL                              00000FFD
TOSU                              00000FFF
TRISA                             00000F92
TRISA0                            00000000
TRISA1                            00000001
TRISA2                            00000002
TRISA3                            00000003
TRISA4                            00000004
TRISA5                            00000005
TRISA6                            00000006
TRISB                             00000F93
TRISB0                            00000000
TRISB1                            00000001
TRISB2                            00000002
TRISB3                            00000003
TRISB4                            00000004
TRISB5                            00000005
TRISB6                            00000006
TRISB7                            00000007
TRISC                             00000F94
TRISC0                            00000000
TRISC1                            00000001
TRISC2                            00000002
TRISC6                            00000006
TRISC7                            00000007
TRISD                             00000F95
TRISD0                            00000000
TRISD1                            00000001
TRISD2                            00000002
TRISD3                            00000003
TRISD4                            00000004
TRISD5                            00000005
TRISD6                            00000006
TRISD7                            00000007
TRISE                             00000F96
TRISE0                            00000000
TRISE1                            00000001
TRISE2                            00000002
TRMT                              00000001
TRNIE                             00000003
TRNIF                             00000003
TUN0                              00000000
TUN1                              00000001
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 104


SYMBOL TABLE
  LABEL                             VALUE 

TUN2                              00000002
TUN3                              00000003
TUN4                              00000004
TX                                00000006
TX9                               00000006
TX9D                              00000000
TXCKP                             00000004
TXEN                              00000005
TXIE                              00000004
TXIF                              00000004
TXIP                              00000004
TXREG                             00000FAD
TXSTA                             00000FAC
TempByte                          00000000
TempCount                         00000000
TheEnd                            00000A5A
TheUnEnd                          00000C3C
UA                                00000001
UADDR                             00000F6E
UCFG                              00000F6F
UCFG_VAL                          _PUEN|_TRINT|_FS|MODE_PP
UCON                              00000F6D
UEIE                              00000F6B
UEIR                              00000F6A
UEP0                              00000F70
UEP1                              00000F71
UEP10                             00000F7A
UEP11                             00000F7B
UEP12                             00000F7C
UEP13                             00000F7D
UEP14                             00000F7E
UEP15                             00000F7F
UEP2                              00000F72
UEP3                              00000F73
UEP4                              00000F74
UEP5                              00000F75
UEP6                              00000F76
UEP7                              00000F77
UEP8                              00000F78
UEP9                              00000F79
UERRIE                            00000001
UERRIF                            00000001
UFRM                              00000F66
UFRMH                             00000F67
UFRML                             00000F66
UIE                               00000F69
UIR                               00000F68
UOEMON                            00000006
UOWN                              7
UPUEN                             00000004
URSTIE                            00000000
URSTIF                            00000000
USBCalcEPAddress                  00000456
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 105


SYMBOL TABLE
  LABEL                             VALUE 

USBCheckBusStatus                 0000062C
USBCheckBusStatus1                00000632
USBCheckHIDRequest                00000724
USBCheckHIDRequest01              00000730
USBCheckHIDRequest1               0000075A
USBCheckHIDRequest2               000007CC
USBCheckHIDRequestClass           000007CC
USBCheckHIDRequestClass1          000007EC
USBCheckHIDRequestClass2          000007F8
USBCheckHIDRequestClass3          00000810
USBCheckHIDRequestExit            0000072E
USBCheckStdRequest                000001EE
USBCheckStdRequest1               00000204
USBCheckStdRequest2               0000020C
USBCheckStdRequest3               00000224
USBCheckStdRequest4               0000022C
USBCheckStdRequest5               00000234
USBCheckStdRequest6               0000023C
USBCheckStdRequest7               00000244
USBCheckStdRequest8               00000260
USBCheckStdRequestExit            00000274
USBCtrlEPService                  00000466
USBCtrlEPService1                 00000476
USBCtrlEPServiceComplete          00000584
USBCtrlEPServiceComplete1         0000059E
USBCtrlEPServiceComplete11        000005B8
USBCtrlEPServiceComplete2         000005DC
USBCtrlEPServiceCompleteCopy      000005B0
USBCtrlEPServiceCompleteExit      000005F6
USBCtrlTrfInHandler               000004A8
USBCtrlTrfInHandler1              000004BA
USBCtrlTrfOutHandler              00000496
USBCtrlTrfRxService               0000054C
USBCtrlTrfRxServiceExit           00000582
USBCtrlTrfRxServiceLoop           0000056E
USBCtrlTrfSetupHandler            0000047E
USBCtrlTrfTxService               000004CC
USBCtrlTrfTxServiceCopy           000004E0
USBCtrlTrfTxServiceExit           0000054A
USBCtrlTrfTxServiceFinishUp       0000054A
USBCtrlTrfTxServiceRam            0000052E
USBCtrlTrfTxServiceRamLoop        00000536
USBCtrlTrfTxServiceRomLoop        00000514
USBCtrlTrfTxServiceRomRam         00000506
USBCtrlTrfTxServiceSub            000004E8
USBDriverService                  00000662
USBDriverService1                 00000672
USBDriverService2                 0000067E
USBDriverService3                 00000686
USBDriverService4                 0000068E
USBDriverService5                 00000696
USBDriverService6                 0000069E
USBDriverServiceExit              000006B0
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 106


SYMBOL TABLE
  LABEL                             VALUE 

USBEN                             00000003
USBErrorHandler                   000006EC
USBHIDSetSessionOwner             0000081A
USBIE                             00000005
USBIF                             00000005
USBIP                             00000005
USBInit                           00000000
USBModuleDisable                  00000656
USBModuleEnable                   0000064A
USBPrepareForNextSetupTrf         000005FA
USBProtocolResetHandler           000006F0
USBProtocolResetHandlerClearLoop  00000704
USBProtocolResetHandlerFlushLoop  00000710
USBRemoteWakeup                   000006C2
USBRemoteWakeupLoop               000006D2
USBService                        00000008
USBSoftDetach                     00000656
USBStallHandler                   000006E2
USBStdFeatureReqHandler           00000412
USBStdFeatureReqHandler1          0000042A
USBStdFeatureReqHandler2          0000044C
USBStdFeatureReqHandlerExit       0000042E
USBStdGetDscHandler               00000276
USBStdGetDscHandler1              000002A0
USBStdGetDscHandler2              000002CA
USBStdGetStatusHandler            000003C8
USBStdGetStatusHandler1           000003DA
USBStdGetStatusHandler2           000003E4
USBStdGetStatusHandler3           000003FA
USBStdGetStatusSetSessionOwner    000003F6
USBStdSetCfgHandler               00000300
USBStdSetCfgHandler1              0000032A
USBStdSetCfgHandlerClearAltLoop   00000316
USBStdSetCfgHandlerClearEPLoop    0000030A
USBStdSetCfgHandlerExit           000003C6
USBStdSetCfgHandlerInLoop         00000356
USBStdSetCfgHandlerInitOuts       0000037A
USBStdSetCfgHandlerOutLoop        000003A2
USBStdSetSessionOwnerUSB9         00000270
USBSuspend                        000006B2
USBWakeFromSuspend                000006BA
USB_Curr_Config                   00000000
USB_Curr_Identity                 00000000
USB_SD_Ptr                        00000000
USB_SOF_Handler                   000006DE
USB_USE_HID                       
USTAT                             00000F6C
UTEYE                             00000007
UTRDIS                            00000003
UnOneBit                          00000C0E
UnPacket                          00000ABC
UnPkCalcNewIndexes                00000BF8
UnPkCalcNewIndexesOneBit          00000BFC
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 107


SYMBOL TABLE
  LABEL                             VALUE 

UnPkNotReady                      00000AD8
UnPkShiftLoop                     00000BA4
UnPkShiftLoop1                    00000BA6
UnProcessLoop                     00000B50
UnpackLoop                        00000B14
UnpackLoop1                       00000B1C
UsbGetPacket                      000000FA
UsbPutPacket                      0000006A
V25TER                            0x01
VCFG0                             00000004
VCFG1                             00000005
VDIRMAG                           00000007
VENDOR                            0x02
VREFM                             00000002
VREFP                             00000003
VarBits                           00000000
VarBytes                          00000000
VarLoop                           00000996
VarSign                           00000000
VarSize                           00000000
W                                 00000000
WAIT_SETUP                        0
WCOL                              00000007
WDTCON                            00000FD1
WR                                00000001
WREG                              00000FE8
WREN                              00000002
WRERR                             00000003
WRSPP                             00000006
WS0                               00000000
WS1                               00000001
WS2                               00000002
WS3                               00000003
WUE                               00000001
Z                                 00000002
_BORV_0_2L                        000000E7
_BORV_1_2L                        000000EF
_BORV_2_2L                        000000F7
_BORV_3_2L                        000000FF
_BOR_OFF_2L                       000000F9
_BOR_ON_2L                        000000FF
_BOR_ON_ACTIVE_2L                 000000FD
_BOR_SOFT_2L                      000000FB
_BSTALL                           0x04
_CCP2MX_OFF_3H                    000000FE
_CCP2MX_ON_3H                     000000FF
_CONFIG1H                         00300001
_CONFIG1L                         00300000
_CONFIG2H                         00300003
_CONFIG2L                         00300002
_CONFIG3H                         00300005
_CONFIG4L                         00300006
_CONFIG5H                         00300009
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 108


SYMBOL TABLE
  LABEL                             VALUE 

_CONFIG5L                         00300008
_CONFIG6H                         0030000B
_CONFIG6L                         0030000A
_CONFIG7H                         0030000D
_CONFIG7L                         0030000C
_CP0_OFF_5L                       000000FF
_CP0_ON_5L                        000000FE
_CP1_OFF_5L                       000000FF
_CP1_ON_5L                        000000FD
_CP2_OFF_5L                       000000FF
_CP2_ON_5L                        000000FB
_CP3_OFF_5L                       000000FF
_CP3_ON_5L                        000000F7
_CPB_OFF_5H                       000000FF
_CPB_ON_5H                        000000BF
_CPD_OFF_5H                       000000FF
_CPD_ON_5H                        0000007F
_CPUDIV_OSC1_PLL2_1L              000000E7
_CPUDIV_OSC2_PLL3_1L              000000EF
_CPUDIV_OSC3_PLL4_1L              000000F7
_CPUDIV_OSC4_PLL6_1L              000000FF
_DAT0                             0x00
_DAT1                             0x40
_DEBUG_OFF_4L                     000000FF
_DEBUG_ON_4L                      0000007F
_DEVID1                           003FFFFE
_DEVID2                           003FFFFF
_DTSEN                            0x08
_DTSMASK                          0x40
_EBTR0_OFF_7L                     000000FF
_EBTR0_ON_7L                      000000FE
_EBTR1_OFF_7L                     000000FF
_EBTR1_ON_7L                      000000FD
_EBTR2_OFF_7L                     000000FF
_EBTR2_ON_7L                      000000FB
_EBTR3_OFF_7L                     000000FF
_EBTR3_ON_7L                      000000F7
_EBTRB_OFF_7H                     000000FF
_EBTRB_ON_7H                      000000BF
_EP01_IN                          0x81
_EP01_OUT                         0x01
_EP02_IN                          0x82
_EP02_OUT                         0x02
_EP03_IN                          0x83
_EP03_OUT                         0x03
_EP04_IN                          0x84
_EP04_OUT                         0x04
_EP05_IN                          0x85
_EP05_OUT                         0x05
_EP06_IN                          0x86
_EP06_OUT                         0x06
_EP07_IN                          0x87
_EP07_OUT                         0x07
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 109


SYMBOL TABLE
  LABEL                             VALUE 

_EP08_IN                          0x88
_EP08_OUT                         0x08
_EP09_IN                          0x89
_EP09_OUT                         0x09
_EP10_IN                          0x8A
_EP10_OUT                         0x0A
_EP11_IN                          0x8B
_EP11_OUT                         0x0B
_EP12_IN                          0x8C
_EP12_OUT                         0x0C
_EP13_IN                          0x8D
_EP13_OUT                         0x0D
_EP14_IN                          0x8E
_EP14_OUT                         0x0E
_EP15_IN                          0x8F
_EP15_OUT                         0x0F
_FCMEN_OFF_1H                     000000BF
_FCMEN_ON_1H                      000000FF
_FOSC_ECIO_EC_1H                  000000F4
_FOSC_ECPLLIO_EC_1H               000000F6
_FOSC_ECPLL_EC_1H                 000000F7
_FOSC_EC_EC_1H                    000000F5
_FOSC_HSPLL_HS_1H                 000000FE
_FOSC_HS_1H                       000000FC
_FOSC_INTOSCIO_EC_1H              000000F8
_FOSC_INTOSC_EC_1H                000000F9
_FOSC_INTOSC_HS_1H                000000FB
_FOSC_INTOSC_XT_1H                000000FA
_FOSC_XTPLL_XT_1H                 000000F2
_FOSC_XT_XT_1H                    000000F0
_FS                               0x04
_ICPRT_OFF_4L                     000000DF
_ICPRT_ON_4L                      000000FF
_IDLOC0                           00200000
_IDLOC1                           00200001
_IDLOC2                           00200002
_IDLOC3                           00200003
_IDLOC4                           00200004
_IDLOC5                           00200005
_IDLOC6                           00200006
_IDLOC7                           00200007
_IESO_OFF_1H                      0000007F
_IESO_ON_1H                       000000FF
_INCDIS                           0x10
_KEN                              0x20
_LPT1OSC_OFF_3H                   000000FB
_LPT1OSC_ON_3H                    000000FF
_LS                               0x00
_LVP_OFF_4L                       000000FB
_LVP_ON_4L                        000000FF
_MCLRE_OFF_3H                     0000007F
_MCLRE_ON_3H                      000000FF
_OEMON                            0x40
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 110


SYMBOL TABLE
  LABEL                             VALUE 

_PBADEN_OFF_3H                    000000FD
_PBADEN_ON_3H                     000000FF
_PLLDIV_10_1L                     000000FE
_PLLDIV_12_1L                     000000FF
_PLLDIV_1_1L                      000000F8
_PLLDIV_2_1L                      000000F9
_PLLDIV_3_1L                      000000FA
_PLLDIV_4_1L                      000000FB
_PLLDIV_5_1L                      000000FC
_PLLDIV_6_1L                      000000FD
_PPBM0                            0x00
_PPBM1                            0x01
_PPBM2                            0x02
_PUEN                             0x10
_PWRT_OFF_2L                      000000FF
_PWRT_ON_2L                       000000FE
_STVREN_OFF_4L                    000000FE
_STVREN_ON_4L                     000000FF
_TREXT                            0x08
_TRINT                            0x00
_UCPU                             0x00
_USBDIV_1_1L                      000000DF
_USBDIV_2_1L                      000000FF
_USIE                             0x80
_UTEYE                            0x80
_VREGEN_OFF_2L                    000000DF
_VREGEN_ON_2L                     000000FF
_WDTPS_1024_2H                    000000F5
_WDTPS_128_2H                     000000EF
_WDTPS_16384_2H                   000000FD
_WDTPS_16_2H                      000000E9
_WDTPS_1_2H                       000000E1
_WDTPS_2048_2H                    000000F7
_WDTPS_256_2H                     000000F1
_WDTPS_2_2H                       000000E3
_WDTPS_32768_2H                   000000FF
_WDTPS_32_2H                      000000EB
_WDTPS_4096_2H                    000000F9
_WDTPS_4_2H                       000000E5
_WDTPS_512_2H                     000000F3
_WDTPS_64_2H                      000000ED
_WDTPS_8192_2H                    000000FB
_WDTPS_8_2H                       000000E7
_WDT_OFF_2H                       000000FE
_WDT_ON_2H                        000000FF
_WRT0_OFF_6L                      000000FF
_WRT0_ON_6L                       000000FE
_WRT1_OFF_6L                      000000FF
_WRT1_ON_6L                       000000FD
_WRT2_OFF_6L                      000000FF
_WRT2_ON_6L                       000000FB
_WRT3_OFF_6L                      000000FF
_WRT3_ON_6L                       000000F7
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 111


SYMBOL TABLE
  LABEL                             VALUE 

_WRTB_OFF_6H                      000000FF
_WRTB_ON_6H                       000000BF
_WRTC_OFF_6H                      000000FF
_WRTC_ON_6H                       000000DF
_WRTD_OFF_6H                      000000FF
_WRTD_ON_6H                       0000007F
_XINST_OFF_4L                     000000BF
_XINST_ON_4L                      000000FF
__18F4550                         00000001
__DEBUG                           1
bAltID                            2
bAltID_H                          3
bCfgRSD                           3
bCfgValue                         2
bCharFormat                       4
bDataBits                         6
bDevADR                           2
bDevADRH                          3
bDscIndex                         2
bDscType                          3
bEPID                             4
bEPID_H                           5
bFeature                          2
bIntfID                           4
bIntfID_H                         5
bParityType                       5
bReportID                         2
bReportType                       3
bRequest                          1
bmRequestType                     0
cdc_mem_type                      2
copyshiftloop                     00000B9C
copyvarloop                       000009CE
ctrl_trf_mem                      1
ctrl_trf_session_owner            00000000
ctrl_trf_state                    00000000
dummy_length                      0x08
dwDTERate                         0
ep0Bi                             00000000
ep0Bo                             00000000
ep1Bi                             00000000
ep1Bo                             00000000
mGetRomTableCount                 
mSetDestinationPointer            
mSetSourcePointer                 
pDst                              00000000
pSrc                              00000000
shiftloop                         000009EC
shiftloop1                        000009EE
uncopyvarloop                     00000BC0
usb_active_cfg                    00000000
usb_alt_intf                      00000000
usb_device_state                  00000000
MPASM  5.30.01                         USB18.ASM   5-25-2013  0:55:58         PAGE 112


SYMBOL TABLE
  LABEL                             VALUE 

usb_stat                          00000000
usb_temp                          00000000
wCount                            00000000
wIndex                            4
wIndexHi                          5
wLangID                           4
wLength                           6
wLengthHi                         7
wValue                            2
wValueHi                          3

Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

