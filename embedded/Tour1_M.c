/*
=============================================================
FILE:      Tour1_M.c
; PROJECT:   Tour1.hpr
; Project Created 31/12/2009 14:45:43 by HIDmaker
; Copyright (c) 2005 by Trace Systems, Inc.  

This file generated 15/01/2010 17:45:38

 Product Name/Project Description: Dip Coater
 Mfr. Name: Construmaq


 Filename: Tour1_M.c

 Generated by HIDmaker FS ver. 1.5.0.1 [Copyright (c) 2005 by Trace Systems, Inc.]

=============================================================
*/

// Header or Include files:

#include "Tour1_M.h"
#include "USBwatch.inc"

// To use the PIC18F4550 Processor Family:
// Enable only ONE of the following lines, to compile for one of the processors of this family
#include <p18f4550.h>
//#include <p18f4455.h>
//#include <p18f2550.h>
//#include <p18f2455.h>
// If you use one of the above devices, also activate the following line:
#include "CfgBits.h"
#include "xlcd.h"

// OR, To use the PIC18F4450 Processor Family:
// Enable only ONE of the following lines, to compile for one of the processors of this family
//#include <p18f4450.h>
//#include <p18f2450.h>
// If you use one of the above devices, also activate the following line:
//#include "CfgBitsX450.h"

// Microchip C18 files needed for "Real I/O" on a PicProto USB board:
// Enable these lines when necessary
//#include "adc.h"
// Delays needed for various purposes
#include "delays.h"

  extern unsigned char const  Ep1RcvVarTable;
  extern unsigned char const  Ep1XmtVarTable;
  extern unsigned char const  Ep2RcvVarTable;
  extern unsigned char const  Ep2XmtVarTable;
  extern unsigned char const  FeatureVarTable;
  extern unsigned char const  CtlOutVarTable;
// Compiler directives:
  
  extern void USBInit(void);
  extern void USBService(void);
  extern void USBSoftDetach(void);
  extern unsigned char ReadAndUnpackOnePacket( unsigned char EpNum, rom unsigned char const * VarTable);
  extern unsigned char PackAndSendOnePacket( unsigned char EpNum, rom unsigned char const * VarTable);
  
  extern unsigned char UsbPutPacket( unsigned char EpNum, unsigned char * * pBuffPtr, unsigned char * pCount);
  extern unsigned char UsbGetPacket( unsigned char EpNum, unsigned char * * pBuffPtr, unsigned char * pCount);


// Private function prototypes here:

// To use use USBWatch feature, you must enable the line
// that #defines the constant USB_WATCH  in file "USBwatch.inc"


#ifdef USB_WATCH
// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------

// Use these functions to send USBwatch "User-defined" messages from your C code:

// Use this one for data in RAM.
// E.g., call like so: "  UsbwSendU(3, MsgBuf);"
extern void UsbwSendU(unsigned char ByteCount, const unsigned char * Buf);

// Use this one for data in Program ROM, like string literals.
// E.g., call like so: "  UsbwSendU_R(3, "Hi!");":
extern void UsbwSendU_R(unsigned char ByteCount, const rom unsigned char * Buf);

// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
#endif  //  USB_WATCH



// Constants:

#define TRUE  0xFF
#define FALSE  0

// Defines for stepper motor 
#define stepperMotorDirection PORTBbits.RB1 // v1.1 swapped END and DIRECTION to use interrupt routine on END reached
// #define stepperMotorDirection PORTBbits.RB3
#define startReached PORTBbits.RB2
#define endReached PORTBbits.RB3 // v1.1 swapped END and DIRECTION to use interrupt routine on END reached
// #define endReached PORTBbits.RB1
// #define redLed PORTBbits.RB5
// #define greenLed PORTBbits.RB7
#define manualMode PORTBbits.RB5
// #define redLed PORTCbits.RC0


// Test values for Endpoint 1 IN Variables:
// ======================================= 
#define TEST_INVARDIRECTION  31
#define TEST_INVARLSBCOUNTER  39
#define TEST_INVARMSBCOUNTER  39

// Test values for Endpoint 1 OUT Variables:
// ======================================== 
#define TEST_OUTVARSPEED  39
#define TEST_OUTVARDIRECTION  39

// ************************************************************************
// Variable Declarations:
// ************************************************************************

unsigned char  bLSB;
unsigned char  bMSB;
int temp;
int iCount;

unsigned char bStartReached;
unsigned char bEndReached;

#pragma udata access UsbAccess

// Access bank variables used by both the USB library and the main program
near unsigned char HLL_IdleRate;
near unsigned char HLL_ActiveProtocol;
near unsigned char USB_Curr_Config;
near unsigned char USB_Curr_Identity;
near unsigned char USB_Enum_Complete;

#ifdef USB_WATCH
// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------

// Variables needed by USBwatch
// ============================
// USB Advisor:  You can set variable USBW_On to 0 to turn off
// USBwatch reporting in your code. Set it to a non-zero value to
// turn USBwatch reporting back on.  Use this feature to get USBwatch
// debug info in selected sections of your code.

near unsigned char USBW_On;    // Set this to a non-zero value to send USBwatch reports

// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
#endif  //  USB_WATCH

#pragma udata



// ************************************************************************
// Declare other global variables you will need HERE:
// ************************************************************************

// USB Advisor:  This would be a good place to define app-specific variables
// for your particular device. For example:

// Defines for "Real I/O" on a Pic Proto USB board
//#define realLED1  PORTBbits.RB0
//#define realLED2  PORTBbits.RB1
//#define realButton1  PORTBbits.RB4
//#define realButton2  PORTBbits.RB5

// Enable the next line to declare a buffer for USBwatch user defined messages:
//static unsigned char MsgBuf[6] = {0,0,0,0,0,0};



// ************************************************************************
// Report Variables, which you defined in HIDmaker's Visual Data Designer,
// to be sent to/from PC via USB:
// ************************************************************************
//
// For your convenience, multi-bit data items are declared as byte or word
// size variables, even if only a few bits are needed.  Single-bit data items,
// while not natively supported by Microchip C18, are packed into holding bytes.
// Subroutines are provided by HIDmaker and called by this program to pack this
// data into the small packets needed for USB transmission.


union AsByte
{
  unsigned char AsChar;
  struct As_Bits
  {
    unsigned b0 : 1;
    unsigned b1 : 1;
    unsigned b2 : 1;
    unsigned b3 : 1;
    unsigned b4 : 1;
    unsigned b5 : 1;
    unsigned b6 : 1;
    unsigned b7 : 1;
  } bits;
};

// Declare the actual storage for the Report variables 

// Endpoint 1 IN variables: 
// ======================== 
unsigned char  InVarDirection;
unsigned char  InVarLSBCounter;
unsigned char  InVarMSBCounter;

// Endpoint 1 OUT variables: 
// ========================= 
unsigned char  OutVarSpeed;
unsigned char  OutVarDirection;


// function headers
void InterruptHandlerHigh (void);

// ************************************************************************
// Subroutines:
// ************************************************************************

#pragma code


// ************************************************************************
// InitUSBVars:
// Initializes all data items that will be transferred over USB.  This is
// especially important for Feature items, that can be read and written
// by the PC.
//
// HIDmaker will automatically initialize certain variables here, if needed.
// You may add other initialization code here if you choose.
// ************************************************************************

void InitUSBVars(void)
{
  USB_Enum_Complete = 0;
}

// ************************************************************************
// Main program, including USB Init Code:
// ************************************************************************

void main()
{
  unsigned char ReportInProgress;   // Set to true if more data needs to be sent or received
  unsigned char EP1XmtDataReady;   // Set to true if data needs to be sent again
  unsigned char EP2XmtDataReady;   // Set to true if data needs to be sent again
  unsigned char HandleEp1Rcv;      // We need to handle the data received from EP1Out
  unsigned char HandleEp2Rcv;      // We need to handle the data received from EP2Out


	// initialise stepper motor direction
	stepperMotorDirection = 1; // down by default

	// initialise counter
	iCount = 0;
	
	TRISD = 0b00000000; // PORTD to all outputs

	// TRISB = 0b00101101; // PORTB 3 in, 7 out
	TRISBbits.TRISB0 = 1; 
	TRISBbits.TRISB1 = 0;
	TRISBbits.TRISB2 = 1;
	TRISBbits.TRISB3 = 1;

	TRISBbits.TRISB5 = 1; // make input, if +5V is applied to this pin, we're in manual mode, otherwise, USB mode

	if(manualMode == (unsigned char)1)
	{
		// set speed to 0 for good measure
		PORTD = 0x00;
		// initialise LCD
		XLCDInit();
		
		while(1)
		{
			check_pins();

			stepperMotorDirection = get_direction();
			
			bStartReached = startReached;
			bEndReached = endReached;
			
			PORTD = get_speed(bStartReached, bEndReached);

			// TEST CASES

			/*
			1. Active/Standby test, setting speed to 00,51 cm/min 
				1.1 Bit pattern should be 11111001 on BIT0 through BIT7 when ON - OK
				1.2 Bit pattern should be 00000000 on BIT0 through BIT7 when OFF - OK
			2. Start and end reached test, setting speed to 00,51 cm/min 
				1.1 Bit pattern should be 00000000 on BIT0 through BIT7 when ARROW DOWN and END reached (pin 36 goes high) - OK
				1.2 Bit pattern should be 11111001 on BIT0 through BIT7 when ARROW UP and END reached - OK
				1.3 Bit pattern should be 00000000 on BIT0 through BIT7 when ARROW UP and START reached (pin 35 goes high) - OK
				1.4 Bit pattern should be 11111001 on BIT0 through BIT7 when ARROW DOWN and START reached - OK
			3. Switch direction test
				1.1 Direction pin (34) should go HIGH when ARROW DOWN - OK
				1.2 Direction pin (34) should go LOW when ARROW UP - OK
			*/

		}
	}
	
  InitUSBVars();

// USB Advisor: You may wish to initialize some things here, before the
// USB initialization happens.  Initialization code placed here is sure
// to run, even if the USB initialization fails (perhaps because the
// device was never connected to a USB cable).
// For example:

// The following lines initialize real I/O on a Pic Proto USB board
//  INTCON2bits.NOT_RBPU = 0;  // Enable PortB Pullups
//  TRISB = 0b11111100;  // PORTB to all inputs except LED1 and LED2
//  TRISA = 0b11111111;  // PORTA to all inputs, esp POT1 and POT2
//  ADCON0 = 0;
//  ADCON1 = 0b00001101; // Only A/D channels 0 and 1 are enabled
//  ADCON2 = 0b00100101; // Left justified, 8TAD, FOSC/16 

#ifdef USB_WATCH
// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------

// Enable the next line to use USBWatch feature (uses h/w serial port)
  TRISC = 0xC0;             // Set PORTC pins to enable h/w serial port

// BAUD RATE CONSTANTS for USBwatch
// ================================
// IMPORTANT NOTE: the following values are *only* valid for a 20 MHz MCU clock,
// which will be met if your device uses a 20 MHz crystal and the default
// oscillator settings in the Configuration Bits. (See file "CfgBits.inc")
//
// Enable only ONE of the next 3 lines to use USBWatch feature
//  SPBRG =  10;             // 115K Baud
  SPBRG =  21;             // 56K Baud   (Default baud rate)
//  SPBRG = 129;             // 9600 Baud

// Enable BOTH of the following lines to use USBWatch feature
  TXSTA = 0x24;             // TX enabled, High speed range
  RCSTA = 0x90;             // Serial port enabled, continuous receive

// USB Advisor:  Here are some examples of using and controlling
// USBwatch in your code:
//
// Turn on USBwatch reporting
// You MUST enable the next line to be able to see any USBwatch data!
  USBW_On = 1;

// User-defined USBwatch message examples:
// Ex. 1) Sending a literal string (10 bytes or less, unless you increase 
//    the size of UmsgBuf in file "USB18MEM.ASM")
//    Send a 3-byte literal string:
//  UsbwSendU_R(3, "Hi!");
//
// Ex. 2) Sending data stored in a buffer in data RAM
//  MsgBuf[0] = 0x22;   // Just put some numbers into the buffer
//  MsgBuf[1] = 0x33;
//  MsgBuf[2] = 0x44;
//  MsgBuf[3] = 0x55;
//  UsbwSendU(4, MsgBuf);

// How to turn off USBwatch reporting
//  USBW_On = 0;

// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
#endif

  // Turn on the USB module and start the enumeration process
  // If the manual controller is plugged in, do not initilise USB
  // if(PORT A == 0)

 	USBInit();

// Initialise PORTD

PORTD = 0x00;

// USB Advisor: On the other hand, you may prefer to initialize some things HERE,
// AFTER the USB initialization. Note that if USB enumeration process is not
// successful, perhaps because the device was never connected to a USB cable,
// the program will never reach this point. You could use that fact to initialize
// or do some things here that only make sense after a USB connection to a PC
// has been established.


// ************************************************************************
// Main loop:
// This code is structured so that it looks for data to receive, or send,
// without getting stuck on any one of the endpoints until a report
// from or to the PC has been started.  Once a report HAS been started,
// we stay with that endpoint until the entire report has been completed.
// ************************************************************************

// initialise direction and limits information to be sent to host
InVarDirection = 0x00;

// for good measure, initialise variable that holds data sent from host
OutVarDirection = 0x00;

// Main Loop:
while (1)
  {
MainLoop:

		if(((unsigned char)OutVarDirection & (unsigned char)0x10) == (unsigned char)0x10) // acknowledgement flag ~ 0bxxx1xxxx, host has received information, reinitialise variable
			InVarDirection = 0x00;
	
		// v1.1 Step motor reversing now handled by interrupts
		if(endReached == (unsigned char)1) // if RB3 pin is high, end has been reached, set RB1 (direction pin) to low (reverse), set RB6 (red led) to high
		{	stepperMotorDirection = 0;
			// InVarDirection bit pattern 0b00000001 // BIT 0 set, a limit has been reached, BIT 1 not set, lower end reached
			InVarDirection = 0x01;
			//redLed = 1;
			//greenLed = 0;
		}
		if(startReached == (unsigned char)1) // if RB2 pin is high, start has been reached, set RB1 (direction pin) to high (forward), set RB7 (green led) to high
		{	stepperMotorDirection = 1;
			// InVarDirection bit pattern 0b00000011 // BIT 0 set, a limit has been reached, BIT 1 set, upper end reached
			InVarDirection = 0x03;
			//redLed = 0;
			//greenLed = 1;
			iCount = 0;
		}
	
	    USBService();      // Service USB functions periodically
	
	    // This is a NORMAL or "simple" device. It has a single
	    // USB	 Configuration, which contains a single USB Interface.
	
	
	    // If a Report is coming to us via Endpoint 1 Out, get it all...
	    //
	    HandleEp1Rcv = 0;
	    ReportInProgress = 0;
	
	    do
	      {
	        USBService();  // Must service USB regularly
	        ReportInProgress = ReadAndUnpackOnePacket(1, (rom unsigned char const *)&Ep1RcvVarTable);
	
	        if ( (ReportInProgress == (unsigned char)0xFF) || (ReportInProgress == (unsigned char)0) )
	          {
	            HandleEp1Rcv = TRUE;
	          }
	
	      } while (ReportInProgress == 0xFF);
	
	
	    if (HandleEp1Rcv)
	      {
	        // --------------- ADD USER "EP1 RCV" CODE HERE: ------------------
	
	        // Add code here to handle the newly-received data from Endpoint 1 Out
	        // C1 I0
	
			// speed	
			PORTD = OutVarSpeed;
			
			// direction look at BIT 1
			if(((unsigned char)OutVarDirection & (unsigned char)0x01) == (unsigned char)0x01) // 0b00000001, BIT 1 = 0, UP
			{	stepperMotorDirection = 0;
				InVarDirection |= 0x04; // 0b000001xx, let host know
			}	
			if(((unsigned char)OutVarDirection & (unsigned char)0x03) == (unsigned char)0x03) // 0b00000011, BIT 1 = 1, DOWN
			{	stepperMotorDirection = 1;
				InVarDirection |= 0x0C; // 0b000011xx, let host know
			}
	
	        // --------------- END USER "EP1 RCV" CODE -----------------
	
	        HandleEp1Rcv = 0;    // Indicate that received EP1 data has been handled now
	        
	      }  //  if (HandleEp1Rcv)
	
		// count steps
	
	    // --------------- ADD USER "EP1 XMT" CODE HERE: ------------------
	
	    //  C1 I0
	
	    // Add code here to generate data to transmit to PC via Endpoint 1 In
	    // This code should:
	    //   set flag EP1XmtDataReady = 1 if there is new data to send, or
	    //   set flag EP1XmtDataReady = 0 if data has NOT changed yet
	
	    // Test values for EP1 In (In to PC host):
	
	
		temp = iCount;
		InVarLSBCounter = (unsigned char)temp & 0xFF; // LSB ~ first eight bits
		temp = temp & 0xFF00;
		temp = temp >> 8; // MSB ~ last 8 bits
		InVarMSBCounter = (unsigned char)temp;
	
	    EP1XmtDataReady = 1;
	
	    // --------------- END USER "EP1 XMT" CODE ------------------
	
	    if (EP1XmtDataReady)
	      {
	        do
	          {
	            // Now keep constructing and sending packets until the data is all sent
	            USBService();   // Must service USB regularly
	
	            ReportInProgress = PackAndSendOnePacket(1, (rom unsigned char const *)&Ep1XmtVarTable);
	
	          } while (ReportInProgress);
	      } // if (EP1XmtDataReady)
  }   // Bottom of main loop
}  // end of main()

// ************************************************************************
// Interrupt handler
// ************************************************************************

//----------------------------------------------------------------------------
// High priority interrupt vector
/*
#pragma code InterruptVectorHigh = 0x08
void
InterruptVectorHigh (void)
{
  _asm
    goto InterruptHandlerHigh //jump to interrupt routine
  _endasm
}


#pragma code
#pragma interrupt InterruptHandlerHigh

void
InterruptHandlerHigh ()
{
	if(INTCON3bits.INT1IF) // END has been reached, reverse stepper motor
	{
		// clear flag
		INTCON3bits.INT1IF = 0;
		// reverse stepper motor, direction = end to start
		stepperMotorDirection = 0;
		// let host application know
		InVarDirection |= 0x01;
	}
	if(INTCON3bits.INT2IF) // START has been reached, reverse stepper motor
	{
		// clear flag
		INTCON3bits.INT2IF = 0;
		// reverse stepper motor, direction = start to end
		stepperMotorDirection = 1;
		// let host application know
		InVarDirection |= 0x03;
		// let host know Count is being reset (unimplemented);
		// iCount = 0;		
	}
}
*/


// void interrupt_handler_end_reached
/*
1. clear the flat
2. if stepper motor is going in contrary motion, invert the motion
*/

// void interrupt_handler_start_reached
/*
1. clear the flag
2. if stepper motor is going in contrary motion, invert the motion
*/

// ************************************************************************
// Callback function to transmit one packet of a Feature IN report, if any
// ************************************************************************

void FeatureIn(void)
{
  // This device does not transmit any FEATURE reports
}

// ************************************************************************
// Callback function to receive one packet of a Feature Report, if any
// ************************************************************************

void RcvFeatureRpt(void)
{
  // This device does not receive any FEATURE reports
}

// ************************************************************************
// Callback function to receive one packet of an OUT report by Control transfers, if any
// ************************************************************************

void RcvOutRpt(void)
{
  // This device does not use Control transfers to receive any OUT reports
}


