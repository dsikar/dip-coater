/*
=============================================================
FILE:      Tour1_M.c
; PROJECT:   Tour1.hpr
; Project Created 31/12/2009 14:45:43 by HIDmaker
; Copyright (c) 2005 by Trace Systems, Inc.  

This file generated 31/12/2009 14:48:49

 Product Name/Project Description: Dip Coater
 Mfr. Name: Construmaq


 Filename: Tour1_M.c

 Generated by HIDmaker FS ver. 1.5.0.1 [Copyright (c) 2005 by Trace Systems, Inc.]

=============================================================
*/


// Header or Include files:

#include "Tour1_M.h"
#include "USBwatch.inc"

// To use the PIC18F4550 Processor Family:
// Enable only ONE of the following lines, to compile for one of the processors of this family
#include <p18f4550.h>
//#include <p18f4455.h>
//#include <p18f2550.h>
//#include <p18f2455.h>
// If you use one of the above devices, also activate the following line:
#include "CfgBits.h"

// OR, To use the PIC18F4450 Processor Family:
// Enable only ONE of the following lines, to compile for one of the processors of this family
//#include <p18f4450.h>
//#include <p18f2450.h>
// If you use one of the above devices, also activate the following line:
//#include "CfgBitsX450.h"

// Microchip C18 files needed for "Real I/O" on a PicProto USB board:
// Enable these lines when necessary
//#include "adc.h"
// Delays needed for various purposes
#include "delays.h"
// AD library
#include "adc.h"

  extern unsigned char const  Ep1RcvVarTable;
  extern unsigned char const  Ep1XmtVarTable;
  extern unsigned char const  Ep2RcvVarTable;
  extern unsigned char const  Ep2XmtVarTable;
  extern unsigned char const  FeatureVarTable;
  extern unsigned char const  CtlOutVarTable;
// Compiler directives:
  
  extern void USBInit(void);
  extern void USBService(void);
  extern void USBSoftDetach(void);
  extern unsigned char ReadAndUnpackOnePacket( unsigned char EpNum, rom unsigned char const * VarTable);
  extern unsigned char PackAndSendOnePacket( unsigned char EpNum, rom unsigned char const * VarTable);
  
  extern unsigned char UsbPutPacket( unsigned char EpNum, unsigned char * * pBuffPtr, unsigned char * pCount);
  extern unsigned char UsbGetPacket( unsigned char EpNum, unsigned char * * pBuffPtr, unsigned char * pCount);


// Private function prototypes here:

// To use use USBWatch feature, you must enable the line
// that #defines the constant USB_WATCH  in file "USBwatch.inc"


#ifdef USB_WATCH
// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------

// Use these functions to send USBwatch "User-defined" messages from your C code:

// Use this one for data in RAM.
// E.g., call like so: "  UsbwSendU(3, MsgBuf);"
extern void UsbwSendU(unsigned char ByteCount, const unsigned char * Buf);

// Use this one for data in Program ROM, like string literals.
// E.g., call like so: "  UsbwSendU_R(3, "Hi!");":
extern void UsbwSendU_R(unsigned char ByteCount, const rom unsigned char * Buf);

// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
#endif  //  USB_WATCH

// Constants:

#define TRUE  0xFF
#define FALSE  0

// Defines for stepper motor
#define stepperMotorDirection PORTBbits.RB1
#define startReached PORTBbits.RB2
#define endReached PORTBbits.RB3
#define redLed PORTBbits.RB6
#define greenLed PORTBbits.RB7


//#define realButton1  PORTBbits.RB4
//#define realButton2  PORTBbits.RB5

// Test values for Endpoint 1 IN Variables:
// ======================================= 
#define TEST_INVARDIRECTION  31
#define TEST_INVARCOUNTER  39

// Test values for Endpoint 1 OUT Variables:
// ======================================== 
#define TEST_OURVARSPEED  39

// ************************************************************************
// Variable Declarations:
// ************************************************************************

unsigned char  bLSB;
unsigned char  bMSB;
int temp;
int iCount;


#pragma udata access UsbAccess

// Access bank variables used by both the USB library and the main program
near unsigned char HLL_IdleRate;
near unsigned char HLL_ActiveProtocol;
near unsigned char USB_Curr_Config;
near unsigned char USB_Curr_Identity;
near unsigned char USB_Enum_Complete;

#ifdef USB_WATCH
// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------

// Variables needed by USBwatch
// ============================
// USB Advisor:  You can set variable USBW_On to 0 to turn off
// USBwatch reporting in your code. Set it to a non-zero value to
// turn USBwatch reporting back on.  Use this feature to get USBwatch
// debug info in selected sections of your code.

near unsigned char USBW_On;    // Set this to a non-zero value to send USBwatch reports

// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
#endif  //  USB_WATCH

#pragma udata



// ************************************************************************
// Declare other global variables you will need HERE:
// ************************************************************************

// USB Advisor:  This would be a good place to define app-specific variables
// for your particular device. For example:

// Defines for "Real I/O" on a Pic Proto USB board
//#define realLED1  PORTBbits.RB0
//#define realLED2  PORTBbits.RB1
//#define realButton1  PORTBbits.RB4
//#define realButton2  PORTBbits.RB5

// Enable the next line to declare a buffer for USBwatch user defined messages:
//static unsigned char MsgBuf[6] = {0,0,0,0,0,0};



// ************************************************************************
// Report Variables, which you defined in HIDmaker's Visual Data Designer,
// to be sent to/from PC via USB:
// ************************************************************************
//
// For your convenience, multi-bit data items are declared as byte or word
// size variables, even if only a few bits are needed.  Single-bit data items,
// while not natively supported by Microchip C18, are packed into holding bytes.
// Subroutines are provided by HIDmaker and called by this program to pack this
// data into the small packets needed for USB transmission.


union AsByte
{
  unsigned char AsChar;
  struct As_Bits
  {
    unsigned b0 : 1;
    unsigned b1 : 1;
    unsigned b2 : 1;
    unsigned b3 : 1;
    unsigned b4 : 1;
    unsigned b5 : 1;
    unsigned b6 : 1;
    unsigned b7 : 1;
  } bits;
};

// Declare the actual storage for the Report variables 

// Endpoint 1 IN variables: 
// ======================== 
unsigned char  InVarDirection;
unsigned char  InVarCounter;

// Endpoint 1 OUT variables: 
// ========================= 
unsigned char  OurVarSpeed;


// ************************************************************************
// Subroutines:
// ************************************************************************

#pragma code


// ************************************************************************
// InitUSBVars:
// Initializes all data items that will be transferred over USB.  This is
// especially important for Feature items, that can be read and written
// by the PC.
//
// HIDmaker will automatically initialize certain variables here, if needed.
// You may add other initialization code here if you choose.
// ************************************************************************

void InitUSBVars(void)
{
  USB_Enum_Complete = 0;
}

// ************************************************************************
// Main program, including USB Init Code:
// ************************************************************************

void main()
{
  unsigned char ReportInProgress;   // Set to true if more data needs to be sent or received
  unsigned char EP1XmtDataReady;   // Set to true if data needs to be sent again
  unsigned char EP2XmtDataReady;   // Set to true if data needs to be sent again
  unsigned char HandleEp1Rcv;      // We need to handle the data received from EP1Out
  unsigned char HandleEp2Rcv;      // We need to handle the data received from EP2Out

	// initialise counter
	iCount = 0;
	
	TRISD = 0b00000000; // PORTD to all outputs
	TRISB = 0b00001101; // PORTB 3 in, 7 out

  InitUSBVars();

// USB Advisor: You may wish to initialize some things here, before the
// USB initialization happens.  Initialization code placed here is sure
// to run, even if the USB initialization fails (perhaps because the
// device was never connected to a USB cable).
// For example:

// The following lines initialize real I/O on a Pic Proto USB board
//  INTCON2bits.NOT_RBPU = 0;  // Enable PortB Pullups
//  TRISB = 0b11111100;  // PORTB to all inputs except LED1 and LED2
//  TRISA = 0b11111111;  // PORTA to all inputs, esp POT1 and POT2
//  ADCON0 = 0;
//  ADCON1 = 0b00001101; // Only A/D channels 0 and 1 are enabled
//  ADCON2 = 0b00100101; // Left justified, 8TAD, FOSC/16 

#ifdef USB_WATCH
// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------

// Enable the next line to use USBWatch feature (uses h/w serial port)
  TRISC = 0xC0;             // Set PORTC pins to enable h/w serial port

// BAUD RATE CONSTANTS for USBwatch
// ================================
// IMPORTANT NOTE: the following values are *only* valid for a 20 MHz MCU clock,
// which will be met if your device uses a 20 MHz crystal and the default
// oscillator settings in the Configuration Bits. (See file "CfgBits.inc")
//
// Enable only ONE of the next 3 lines to use USBWatch feature
//  SPBRG =  10;             // 115K Baud
  SPBRG =  21;             // 56K Baud   (Default baud rate)
//  SPBRG = 129;             // 9600 Baud

// Enable BOTH of the following lines to use USBWatch feature
  TXSTA = 0x24;             // TX enabled, High speed range
  RCSTA = 0x90;             // Serial port enabled, continuous receive

// USB Advisor:  Here are some examples of using and controlling
// USBwatch in your code:
//
// Turn on USBwatch reporting
// You MUST enable the next line to be able to see any USBwatch data!
  USBW_On = 1;

// User-defined USBwatch message examples:
// Ex. 1) Sending a literal string (10 bytes or less, unless you increase 
//    the size of UmsgBuf in file "USB18MEM.ASM")
//    Send a 3-byte literal string:
//  UsbwSendU_R(3, "Hi!");
//
// Ex. 2) Sending data stored in a buffer in data RAM
//  MsgBuf[0] = 0x22;   // Just put some numbers into the buffer
//  MsgBuf[1] = 0x33;
//  MsgBuf[2] = 0x44;
//  MsgBuf[3] = 0x55;
//  UsbwSendU(4, MsgBuf);

// How to turn off USBwatch reporting
//  USBW_On = 0;

// -----u-s-b-w-a-t-c-h----------------u-s-b-w-a-t-c-h------------
#endif

  // Turn on the USB module and start the enumeration process
  USBInit();
  

// USB Advisor: On the other hand, you may prefer to initialize some things HERE,
// AFTER the USB initialization. Note that if USB enumeration process is not
// successful, perhaps because the device was never connected to a USB cable,
// the program will never reach this point. You could use that fact to initialize
// or do some things here that only make sense after a USB connection to a PC
// has been established.

// Initialise PORTD

PORTD = 0x00;


// ************************************************************************
// Main loop:
// This code is structured so that it looks for data to receive, or send,
// without getting stuck on any one of the endpoints until a report
// from or to the PC has been started.  Once a report HAS been started,
// we stay with that endpoint until the entire report has been completed.
// ************************************************************************

// Main Loop:
while (1)
  {
MainLoop:

	// Set direction
	InVarDirection = PORTB;
	InVarCounter = (unsigned char)iCount;

	if(endReached == (unsigned char)1) // if RB3 pin is high, end has been reached, set RB1 (direction pin) to low (reverse), set RB6 (red led) to high
	{	stepperMotorDirection = 0;
		redLed = 1;
		greenLed = 0;
	}
	if(startReached == (unsigned char)1) // if RB2 pin is high, start has been reached, set RB1 (direction pin) to high (forward), set RB7 (green led) to high
	{	stepperMotorDirection = 1;
		redLed = 0;
		greenLed = 1;
	}


    USBService();      // Service USB functions periodically

    // This is a NORMAL or "simple" device. It has a single
    // USB Configuration, which contains a single USB Interface.


    // If a Report is coming to us via Endpoint 1 Out, get it all...
    //
    HandleEp1Rcv = 0;
    ReportInProgress = 0;

    do
      {
        USBService();  // Must service USB regularly
        ReportInProgress = ReadAndUnpackOnePacket(1, (rom unsigned char const *)&Ep1RcvVarTable);

        if ( (ReportInProgress == (unsigned char)0xFF) || (ReportInProgress == (unsigned char)0) )
          {
            HandleEp1Rcv = TRUE;
          }

      } while (ReportInProgress == 0xFF);


    if (HandleEp1Rcv)
      {
        // --------------- ADD USER "EP1 RCV" CODE HERE: ------------------

        // Add code here to handle the newly-received data from Endpoint 1 Out
        // C1 I0

        // USB Advisor: Here is where you add code to make use of the data that
        // has arrived from the PC.
        // For example:

        // The following 2 lines provide real I/O for a PicProto USB board
        //realLED1 = LED1;
        //realLED2 = LED2;

		PORTD = OurVarSpeed;

        // "Real I/O" code for a particular project using a PicProto USB board
        //realLED1 = LED1;
        //realLED2 = LED2;

		// Send speed to 16F84A

        // --------------- END USER "EP1 RCV" CODE -----------------

        HandleEp1Rcv = 0;    // Indicate that received EP1 data has been handled now
        
      }  //  if (HandleEp1Rcv)

    // --------------- ADD USER "EP1 XMT" CODE HERE: ------------------

    //  C1 I0

    // Add code here to generate data to transmit to PC via Endpoint 1 In
    // This code should:
    //   set flag EP1XmtDataReady = 1 if there is new data to send, or
    //   set flag EP1XmtDataReady = 0 if data has NOT changed yet



    // USB Advisor: This is where you add code to generate data that gets
    // send to the PC over the USB. Use the variables you defined in HIDmaker's
    // Visual Data Designer. Variables having the correct names and convenient
    // sizes (e.g. word, byte, bit) have been allocated for your use.
    // Here is an example:
    //
    // The following lines provide real I/O for a PicProto USB board
    //adc_read(0);
    //Pot1 = ADRESH;
    //adc_read(1);
    //Pot2 = ADRESH;
    //Button1 = realButton1;
    //Button2 = realButton2;

    // Test values for EP1 In (In to PC host):
    //InVarDirection = TEST_INVARDIRECTION;
    //InVarCounter = TEST_INVARCOUNTER;


    EP1XmtDataReady = 1;

    // --------------- END USER "EP1 XMT" CODE ------------------

    if (EP1XmtDataReady)
      {
        do
          {
            // Now keep constructing and sending packets until the data is all sent
            USBService();   // Must service USB regularly

            ReportInProgress = PackAndSendOnePacket(1, (rom unsigned char const *)&Ep1XmtVarTable);

          } while (ReportInProgress);
      } // if (EP1XmtDataReady)


  }   // Bottom of main loop

}  // end of main()

// ************************************************************************
// Callback function to transmit one packet of a Feature IN report, if any
// ************************************************************************

void FeatureIn(void)
{
  // This device does not transmit any FEATURE reports
}

// ************************************************************************
// Callback function to receive one packet of a Feature Report, if any
// ************************************************************************

void RcvFeatureRpt(void)
{
  // This device does not receive any FEATURE reports
}

// ************************************************************************
// Callback function to receive one packet of an OUT report by Control transfers, if any
// ************************************************************************

void RcvOutRpt(void)
{
  // This device does not use Control transfers to receive any OUT reports
}

