/*
Author: Daniel Sikar
Date: 17.02.2014

Create and populate base table for Dip Coater speeds, to generate Assembler and C# code.

For other gear ratios adjust variable @step_length_mm.

For different speeds adjust variables @count_dec, @count_inc  and associated while loops.
*/

/******************************************
	CREATE BASE TABLE
******************************************/

USE [SCRAP]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[tblUFMGFrequencyValuesCMM_0.01To13cmm]') AND type in (N'U'))
DROP TABLE [dbo].[tblUFMGFrequencyValuesCMM_0.01To13cmm]


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[tblUFMGFrequencyValuesCMM_0.01To13cmm](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[Frequency] [float] NULL,
	[PulseWidth] [numeric](18, 0) NULL,
	[TotalInstructions] [int] NULL,
	[Bonus] [int] NULL,
	[Instructions] [bigint] NULL,
	[CMM] [decimal](4, 2) NULL,
	[MMS] [float] NULL,
	[d1] [char](4) COLLATE Latin1_General_CI_AS NULL,
	[d2] [char](4) COLLATE Latin1_General_CI_AS NULL,
	[d3] [char](4) COLLATE Latin1_General_CI_AS NULL,
	[Remainder] [int] NULL
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF

/******************************************
	POPULATE BASE TABLE
******************************************/
GO
Declare @count_dec decimal(4,2), @count_int int, @mms float
-- raise an error when overflow occurs
SET ARITHABORT ON 

-- TODO 
-- 1. Perhaps this can be done with @count_dec only
-- 2. Substitute magic numbers for descriptive variables

-- create values from 0.01cm/m to 0.49cm/min
set @count_dec = 0.01
while @count_dec < 0.5
	BEGIN
	set @mms = @count_dec/6.000000
	insert into [tblUFMGFrequencyValuesCMM_0.01To13cmm] (cmm, mms)
	values(@count_dec, @mms)
	Set @count_dec = @count_dec + 0.01
END

-- create values from 0.50cm/m to 0.95cm/min
	set @count_dec = 0.50
while @count_dec < 1
	BEGIN
	set @mms = @count_dec/6.000000
	insert into [tblUFMGFrequencyValuesCMM_0.01To13cmm] (cmm, mms)
	values(@count_dec, @mms)
	Set @count_dec = @count_dec + 0.05
END

-- create values from 1cm/min to 10cm/min
Set @count_dec = 1
while @count_dec < 10.5
	BEGIN
	set @mms = @count_dec/6.000000
	insert into [tblUFMGFrequencyValuesCMM_0.01To13cmm] (cmm, mms)
	values(@count_dec, @mms)
	Set @count_dec = @count_dec + 0.5
END

-- create values from 11cm/min to 13cm/min
Set @count_int = 11
while @count_int < 13
	BEGIN
	set @mms = @count_int/6.000000
	insert into [tblUFMGFrequencyValuesCMM_0.01To13cmm] (cmm, mms)
	values(@count_int, @mms)
	Set @count_int = @count_int + 1
END

/******************************************
	CALCULATE NUMBER OR INSTRUCTIONS
	FOR EACH SPEED
******************************************/
GO
-- update number of instructions
declare @step_length_mm decimal, @microseconds int
-- adjust steph length to calibrate speed
-- stepper turning M8x1.25mm threaded rod ~ 0.00625mm/step
set @step_length_mm = 0.00625 
Set @microseconds = 1000000 

-- 1 millionths of a second, divided by (speed in mm/s by step length), 
-- divided by execution time in millionths of a second = number of instructions required to generate delay.

update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set Totalinstructions = @microseconds / (MMS / 0.00625) / 0.2

-- magic numbers defined in .asm relate to instructions used to service request
-- 326398 = maximum number of instructions generated by 2 var algorithm ~ 5*(@d1-1)+(1280*(@d2-1))+8
Declare @max_instructions_2_var int 
SET @max_instructions_2_var = 326398

update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set bonus = 250 + 33 + (id * 3) -- where CMM <= 0.5 -- 3 var delay loop

update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set bonus = 250 + 30 + (id * 3) where TotalInstructions <= @max_instructions_2_var  -- 2 var delay loop

update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set Instructions = TotalInstructions - bonus

/******************************************
	FIND VALUES FOR d1, d2 and remainder
******************************************/

-- 326398 = maximum number of instructions generated by 2 var algorithm ~ 5*(@d1-1)+(1280*(@d2-1))+8
Declare @max_inst_2_var int
Set @max_inst_2_var = 326398

declare @id int, @maxid int, @instructions int, @instructions_found int, @d1 int, @d2 int, @d3 int

--  NB This works because id increases while instructions decrease
select @id = min(id) from [tblUFMGFrequencyValuesCMM_0.01To13cmm] where Instructions <= @max_inst_2_var

-- 2 var delay, 3rd var not used
set @d3 = 0

-- last id to update
select @maxid = max(id) from [tblUFMGFrequencyValuesCMM_0.01To13cmm]

-- Open poor man's cursor
while @id <= @maxid
BEGIN
	select @instructions = instructions from [tblUFMGFrequencyValuesCMM_0.01To13cmm] where id = @id
	set @d2 = 1
	set @d1 = 256
	while @d1 > 255
	BEGIN
		-- Golovchenko algorithm for 20mHz CPU. Function calls and returns not included
		set @d1 = (@instructions - (1280*@d2) + 1277) / 5
		set @d2 = @d2 + 1
	END
	set @d2 = @d2 - 1
	set @instructions_found = 5*(@d1-1)+(1280*(@d2-1))+8 -- function calls and returns not included
	update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set d1 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d1)), 
	d2 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d2)),
	d3 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d3)),
	remainder = @instructions - @instructions_found
	where id = @id
	set @id = @id + 1
END

/***********************************************************************
	FIND VALUES FOR d1, d2, d3 and remainder, for instructions > 326398
***********************************************************************/

set @id = 1
-- See notes above on limits and table structure
select @maxid = max(id) from [tblUFMGFrequencyValuesCMM_0.01To13cmm] where Instructions > @max_inst_2_var 

-- Open poor man's cursor
while @id <= @maxid
BEGIN
	select @instructions = instructions from [tblUFMGFrequencyValuesCMM_0.01To13cmm] where id = @id
	set @d3 = 1
	set @d2 = 1
	set @d1 = 256
	while @d1 > 255
	BEGIN
		-- Golovchenko algorithm for 20mHz CPU.
		set @d1 = (@instructions - (1792*@d2) - (458752*@d3) + 460539) / 7
		set @d2 = @d2 + 1
		if @d2 > 255
		BEGIN
			set @d2 = 1
			set @d3 = @d3 + 1
		END
	END
	set @d2 = @d2 - 1 -- broke out of loop and adjusted @d2
	-- NB Minimum delay that can be generated by this delay = 12, so all values in current table could be generated with  3 vars
	set @instructions_found = (7*@d1) + (1792*@d2) + (458752*@d3) - 460539
	update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set d1 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d1)), 
	d2 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d2)),
	d3 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d3)),
	remainder = @instructions - @instructions_found
	where id = @id
	set @id = @id + 1

/*
NB ID 41 generates a negative remainder - this is a bug that needs to be fixed. 
Meanwhile, using these values

declare @id int, @maxid int, @instructions int, @instructions_found int, @d1 int, @d2 int, @d3 int

	set @d1 = 248
	set @d2 = 255
	set @d3 = 1
	
	update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set d1 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d1)), 
	d2 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d2)),
	d3 = master.dbo.fn_varbintohexstr(convert(varbinary(1), @d3)),
	remainder = 2
	where id = 41

See 

http://www.golovchenko.org/cgi-bin/delay?Delay=456911&Type=cycles&Regs=d1+d2+d3&clock=20&name=Delay&CPU=PIC
*/

END

/******************************************
	UPDATE PulseWidth and Frequency
******************************************/

Update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set PulseWidth = TotalInstructions * 0.2 -- (0.2 microseconds per instruction)

Update [tblUFMGFrequencyValuesCMM_0.01To13cmm] set Frequency = 1000000.0 / PulseWidth 


/**********************************
	OUTPUT ASSEMBLY CODE
**********************************/

-- cleaner text for copy and paste
SET NOCOUNT ON 

-- select case
select '	MOVF factor, W
  	XORLW ' + master.dbo.fn_varbintohexstr(convert(varbinary(1), id)) + '
	bz case_' + convert(varchar,id) + '
' from [tblUFMGFrequencyValuesCMM_0.01To13cmm] order by id

-- case
PRINT '; CASES

case_0	
	; Speed = 0cm/m
	; assign 1 to d1 and d2 to increase system responsiveness i.e. shorter delay
	movlw	0x01
	movwf	d1
	movlw	0x01
	movwf	d2
	goto Lookup_end 
'

select '
case_' + convert(varchar,id) + '
	; Speed = ' + convert(varchar,CMM) + ' cm m^-1 pulse width = ' + Convert(varchar, pulsewidth) + ' µs, frequency = ' + convert(varchar, frequency) + ' Hz
	; ' + convert(varchar,Totalinstructions) + ' instructions on 20 MHz CPU
	; Bonus instructions (execution of main loop, function calls and returns) = ' + Convert(varchar, bonus) + '
	; Actual delay loop instructions (instructions - bonus) = ' + convert(varchar, Instructions) + '
	; Variable assignment
	; ' + 
	case d3
		when '0x00' then '2 var d1 and d2'
		else '3 var d1, d2 and d3 loop'
	end + '
	movlw	' + d1 + '
	movwf	d1
	movlw	' + d2 + '
	movwf	d2 ' +
	case d3
		when '0x00' then ''
		else '
	movlw	' + d3 + '
	movwf	d3' 
	end + '
	; Remainder = ' + convert(varchar, remainder) 
	+
	case remainder 
		when 0 then ''
		when 1 then char(10) + '	nop'
		when 2 then char(10) + '	goto $+1'
		when 3 then char(10) + '	nop' + char(10) + '	goto $+1'
		when 4 then char(10) + '	goto $+1' + char(10) + '	goto $+1'
		when 5 then char(10) + '	goto $+1' + char(10) + '	goto $+1' + char(10) + '	nop'
		when 6 then char(10) + '	goto $+1' + char(10) + '	goto $+1' + char(10) + '	goto $+1'
	end
	+ '
	goto Lookup_end
'  from [tblUFMGFrequencyValuesCMM_0.01To13cmm] 
	order by id

/**********************************
	OUTPUT C# CODE
**********************************/

PRINT '// Drop down box values'

 select 
	'            "' + REPLACE(CONVERT(VARCHAR,cmm), '.', ',') +'",'
	from [tblUFMGFrequencyValuesCMM_0.01To13cmm] order by id

-- speed array, from desktop executable to PIC18F4550 via USB, to 16F84A via parallel port, long way.
PRINT '// Array values'' assignment'

PRINT '        arrSpeed[0] = 0;'
Select '        arrSpeed['+ convert(varchar,id) +'] = ' + convert(varchar,id) + ';' 
from [tblUFMGFrequencyValuesCMM_0.01To13cmm] order by id

SET NOCOUNT ON 


-- PIC 18F4550 eeprom write code

-- NOTE: lines such as 	eepromWrite(25,09); and eepromWrite(238,00);
-- need to be changed to eepromWrite(25,9); and eepromWrite(238,0);
-- then dealt with in the .asm code as special cases

select '	eepromWrite(' +	CONVERT(VARCHAR, ((ID - 1) * 3)) + ',' + left(CMM, CHARINDEX('.', CMM) - 1) + ');' + '
	eepromWrite(' +	CONVERT(VARCHAR, ((ID - 1) * 3) + 1) + ',' + right(CMM, 2)  + ');' + '
	eepromWrite(' +	CONVERT(VARCHAR, ((ID - 1) * 3) + 2) + ',' + CONVERT(VARCHAR, ID) + ');'
	from [tblUFMGFrequencyValuesCMM_0.01To13cmm]